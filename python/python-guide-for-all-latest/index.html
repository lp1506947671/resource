

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Python中文指南 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/js/readmore.js"></script>
        <script type="text/javascript" src="_static/js/baidutongji.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html#document-index" class="icon icon-home"> Python中文指南
          

          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-preface">前言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">关于博客</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p01">第一章：安装运行</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/c01_01">1.1 【环境】快速安装 Python 解释器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/c01_02">1.2 【环境】Python 开发环境的搭建</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/c01_03">1.3 【基础】两种运行 Python 程序方法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p02">第二章：数据类型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_01">2.1 【基础】常量与变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_02">2.2 【基础】字符串类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_03">2.3 【基础】整数与浮点数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_04">2.4 【基础】布尔值：真与假</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_05">2.5 【基础】学会输入与输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_06">2.6 【基础】字符串格式化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/c02_07">2.6 【基础】运算符（超全整理）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p03">第三章：数据结构</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/c03_01">3.1 【基础】列表</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/c03_02">3.2 【基础】元组</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/c03_03">3.3 【基础】字典</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/c03_04">3.4 【基础】集合</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/c03_05">3.5 【基础】迭代器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/c03_06">3.6 【基础】生成器</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p04">第四章：控制流程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/c04_01">4.1 【基础】条件语句：if</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/c04_02">4.2 【基础】循环语句：for</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/c04_03">4.3 【基础】循环语句：while</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/c04_04">4.4 【进阶】五种推导式</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p05">第五章：学习函数</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_01">5.1 【基础】普通函数创建与调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_02">5.2. 【基础】11个案例讲解函数参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_03">5.3 【基础】匿名函数的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_04">5.4 【基础】必学高阶函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_05">5.5 【基础】反射函数的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_06">5.6 【基础】偏函数的妙用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_07">5.7 【进阶】泛型函数的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_08">5.8 【基础】变量的作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_09">5.9 【进阶】上下文管理器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/c05_10">5.10 【进阶】装饰器的六种写法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p06">第六章：错误异常</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/c06_01">6.1 【基础】什么是异常？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/c06_02">6.2 【基础】如何抛出和捕获异常？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/c06_03">6.3 【基础】如何自定义异常？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/c06_04">6.4 【进阶】如何关闭异常自动关联上下文？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/c06_05">6.5 【进阶】异常处理的三个好习惯</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p07">第七章：类与对象</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_01">7.1 【基础】类的理解与使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_02">7.2 【基础】静态方法与类方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_03">7.3 【基础】私有变量与私有方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_04">7.4 【基础】类的封装（Encapsulation）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_05">7.5 【基础】类的继承（Inheritance）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_06">7.6 【基础】类的多态（Polymorphism）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_07">7.7 【基础】类的 property 属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_08">7.8 【进阶】类的 Mixin 设计模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_09">7.9 【进阶】类的魔术方法（超全整理）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_10">7.10 【进阶】神奇的元类编程（metaclass）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/c07_11">7.11 【进阶】深藏不露的描述符（Descriptor）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p08">第八章：包与模块</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_01">8.1 【基础】什么是包、模块和库？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_02">8.2 【基础】安装第三方包的八种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_03">8.3 【基础】导入单元的构成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_04">8.4 【基础】导入包的标准写法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_05">8.5 【进阶】常规包与空间命名包</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_06">8.6 【进阶】花式导包的八种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_07">8.7 【进阶】包导入的三个冷门知识点</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_08">8.8 【基础】pip 的超全使用指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_09">8.9 【进阶】理解模块的缓存</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_10">8.10 【进阶】理解查找器与加载器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_11">8.11 【进阶】实现远程导入模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_12">8.12 【基础】分发工具：distutils和setuptools</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_13">8.13 【基础】源码包与二进制包有什么区别？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_14">8.14 【基础】eggs与wheels 有什么区别？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_15">8.15 【进阶】超详细讲解 setup.py 的编写</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_16">8.16 【进阶】打包辅助神器 PBR 是什么？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/c08_17">8.17 【进阶】开源自己的包到 PYPI 上</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p09">第九章：调试技巧</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_01">9.1 【调试技巧】超详细图文教你调试代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_02">9.2 【调试技巧】PyCharm 中指定参数调试程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_03">9.3 【调试技巧】PyCharm跑完后立即进入调试模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_04">9.4 【调试技巧】脚本报错后立即进入调试模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_05">9.5 【调试技巧】使用 PDB 进行无界面调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_06">9.6 【调试技巧】如何调试已经运行的程序？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_07">9.7 【调试技巧】使用 PySnopper 调试疑难杂症</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_08">9.8 【调试技巧】使用 PyCharm 进行远程调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/c09_09">9.9 【调试技巧】如何调试已经运行的程序？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p10">第十章：并发编程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_01">10.1 【并发编程】从性能角度初探并发编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_02">10.2 【并发编程】创建多线程的几种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_03">10.3 【并发编程】谈谈线程中的“锁机制”</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_04">10.4 【并发编程】线程消息通信机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_05">10.5 【并发编程】线程中的信息隔离</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_06">10.6 【并发编程】线程池创建的几种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_07">10.7 【并发编程】从 yield 开始入门协程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_08">10.8 【并发编程】深入理解yield from语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_09">10.9 【并发编程】初识异步IO框架：asyncio 上篇</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_10">10.10 【并发编程】深入异步IO框架：asyncio 中篇</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_11">10.11 【并发编程】实战异步IO框架：asyncio 下篇</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_12">10.12 【并发编程】生成器与协程，你分清了吗？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/c10_13">10.14 【并发编程】浅谈线程安全那些事儿</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p11">第十一章：代码美化</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_01">11.1 【代码美化】如何更好进行变量的命名？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_02">11.2 【代码美化】写好函数的 6 个建议</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_03">11.3 【代码美化】自觉遵守 PEP8 代码风格</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_04">11.4 【代码美化】Pythonic 代码的 15 个案例</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_05">11.5 【代码美化】写出漂亮 Python 代码的 20条准则</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_06">11.6 【代码美化】择优选择 EAFP 和 LBYL 代码风格</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/c11_07">11.7 【代码美化】使用 flake8 保证代码风格</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p12">第十二章：虚拟环境</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/c12_01">12.1 【虚拟环境】为什么要有虚拟环境？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/c12_02">12.2 【虚拟环境】方案一：使用 virtualenv</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/c12_03">12.3 【虚拟环境】方案二：使用 pipenv</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/c12_04">12.4 【虚拟环境】方案三：使用 pipx</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/c12_05">12.5 【虚拟环境】方案四：使用 poetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/c12_06">12.6 【虚拟环境】方案五：使用 venv</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p13">第十三章：绝佳工具</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/c13_01">13.1 【静态检查】mypy 的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/c13_02">13.2 【代码测试】pytest 的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/c13_03">13.3 【代码提交】pre-commit hook</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/c13_04">13.4 【项目生成】cookiecutter 的使用</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p14">第十四章：数据可视化</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_01">6.1 【可视化之matplotlib】一图带你入门matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_02">6.2 【可视化之matplotlib】详解六种可视化图表</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_03">14.3 【可视化之matplotlib】 绘制正余弦函数图象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_04">14.4 【可视化之matplotlib】难点：子图与子区</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_05">14.5 【可视化之matplotlib】绘制酷炫的gif动态图</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_06">14.6 【可视化之matplotlib】自动生成图像视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/c14_07">14.7 【可视化神器】最高级的可视化神器： plotly_express</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-aboutme">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-roadmap">Roadmap</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html#document-index">Python中文指南</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html#document-index">Docs</a> &raquo;</li>
        
      <li>Python中文指南 1.0 documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/iswbm/python-guide/blob/master/source/index.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="python">
<h1>Python中文指南<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-preface"></span><div class="section" id="id1">
<h2>前言<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>关于博客<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>这个博客于2020年12月25日发布完成，使用的是 Sphinx 来生成文档，使用 Github 托管文档，并使用 Read the Doc 发布文档。</p>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
</div>
<span id="document-chapters/p01"></span><div class="section" id="id1">
<h2>第一章：安装运行<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c01/c01_01"></span><div class="section" id="python">
<h3>1.1 【环境】快速安装 Python 解释器<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<p>Python 是一门解释性脚本语言，因此要想让你编写的代码得以运行，需要先安装
CPython 解释器。</p>
<p>根据你电脑的系统以及位数不同，安装步骤也有所差异。</p>
<ul class="simple">
<li><p>Windows 系统：系统无自带 Python 解释器，需要自行安装</p></li>
<li><p>Mac 系统：系统自带 Python 2.7，需要自行安装 Python 3</p></li>
</ul>
<p>由于 Python 2.x 已经不再维护了，因此本文会带大家安装CPython 最新版本：
Python 3.9 （截止撰稿时最新：2020/12/16）。</p>
<p>同时本系列教程都将以 Python 3.9
版本进行讲解，不负责任的讲，可能是全网最新的 零基础系列教程。</p>
<div class="section" id="id1">
<h4>1. 下载解释器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>进入 <a class="reference external" href="https://www.python.org/downloads/windows/">Python 官网</a>，目前
Python 最新 Python 稳定版为 3.9，点击如下链接</p>
<p><img alt="image0" src="http://image.iswbm.com/image-20201129172024424.png" /></p>
<p>直接跳到最后，根据你电脑系统以及的位数</p>
<ul class="simple">
<li><p>Win 32 位：选择 <a class="reference external" href="https://www.python.org/ftp/python/3.9.0/python-3.9.0.exe">Windows x86 executable
installer</a></p></li>
<li><p>Win 64 位：选择 <a class="reference external" href="https://www.python.org/ftp/python/3.9.0/python-3.9.0-amd64.exe">Windows x86-64 executable
installer</a></p></li>
<li><p>Mac
：<a class="reference external" href="https://www.python.org/ftp/python/3.9.1/python-3.9.1-macosx10.9.pkg">Python-3.9.1-macosx10.9.pkg</a></p></li>
</ul>
<p><img alt="image1" src="http://image.iswbm.com/image-20201129172153677.png" /></p>
<p>下载下来后，根据你的电脑系统选择后面的内容进行阅读。</p>
</div>
<div class="section" id="win">
<h4>2. Win 安装<a class="headerlink" href="#win" title="Permalink to this headline">¶</a></h4>
<p>下载到本地后，双击打开开始安装</p>
<p><img alt="image2" src="http://image.iswbm.com/20201207164009.png" /></p>
<p>记得勾选 <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Python</span> <span class="pre">3.9</span> <span class="pre">to</span> <span class="pre">PATH</span></code>，这是把你的 Python
路径加入到系统环境变量中。如果不想自定义选择安装路径，可以直接点击
<code class="docutils literal notranslate"><span class="pre">Install</span> <span class="pre">Now</span></code>，如果要选择安装路径，点击下图位置。</p>
<p><img alt="image3" src="http://image.iswbm.com/20201207164148.png" /></p>
<p>然后全部选上，然后点击 Next</p>
<p><img alt="image4" src="http://image.iswbm.com/20201207164207.png" /></p>
<p>这里根据需要进行打勾，一般默认就行，然后点击 <code class="docutils literal notranslate"><span class="pre">Browse</span></code> ，选择你想要把
Python 安装到的哪那个目录里。</p>
<p>然后再直接点击 Install 开始安装。</p>
<p><img alt="image5" src="http://image.iswbm.com/20201207164309.png" /></p>
<p>安装过程只要几分钟就行</p>
<p><img alt="image6" src="http://image.iswbm.com/20201207164451.png" /></p>
<p>出现如下界面，说明安装过程已经结束。</p>
<p><img alt="image7" src="http://image.iswbm.com/20201207164957.png" /></p>
<p>安装是安装上了，那么如何验证呢？</p>
<p>使用 windows 搜索 cmd，选择 <code class="docutils literal notranslate"><span class="pre">命令提示符</span></code> （我们把这个称之为你的终端）</p>
<p><img alt="image8" src="http://image.iswbm.com/20201207165111.png" /></p>
<p>然后敲入 python ，若出现如下界面，则说明 Python
已经成功安装到你的机器上。</p>
<p><img alt="image9" src="http://image.iswbm.com/20201218200632.png" /></p>
</div>
<div class="section" id="mac">
<h4>3. Mac 安装<a class="headerlink" href="#mac" title="Permalink to this headline">¶</a></h4>
<p>下载到本地后，双击打开开始安装</p>
<p><img alt="image10" src="http://image.iswbm.com/image-20201215124444268.png" /></p>
<p>出现如下界面，一直点继续</p>
<p><img alt="image11" src="http://image.iswbm.com/image-20201215124456818.png" /></p>
<p>直到出现如下界面，输入密码开始安装</p>
<p><img alt="image12" src="http://image.iswbm.com/image-20201215124710859.png" /></p>
<p>安装的速度非常地快，大概在一分钟左右</p>
<p><img alt="image13" src="http://image.iswbm.com/image-20201215124720398.png" /></p>
<p><img alt="image14" src="http://image.iswbm.com/image-20201215124935041.png" /></p>
<p>打开Terminal 或者 iTerm（同样我们把这个称之为你的终端），输入 Python 3
，如果进入如下界面，说明 Python3 已经安装完成。</p>
<p><img alt="image15" src="http://image.iswbm.com/image-20201215125120591.png" /></p>
</div>
</div>
<span id="document-c01/c01_02"></span><div class="section" id="python">
<h3>1.2 【环境】Python 开发环境的搭建<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<p>理论上只需要你安装了 CPython 解释器后，就可以开始写 Python
代码了。为了让你的在写代码时，有一个更加友好的编码体验。就有人开发了一堆的编辑器。</p>
<p>这些编辑器，具有代码高亮，代码提示自动补全的各种功能，如果没有这些编辑器，我想你没两天就会放弃编程这条路了。</p>
<p>因此在开始学习使用 Python 写代码时，首先要教大家搭建一个舒适的开发环境。</p>
<p>在这里我推荐大家使用 PyCharm
这个软件，它不只是一个简单编辑器，而是一个由 Jetbrain 公司为 Python
专门开发的 Python 语言集成开发环境。</p>
<p>也许你还不知道 Jetbrain ，我来简要介绍一下，Jetbrain 是一家专业的 IDE
（Integrated Development Environment
）生产商，只要是市面上主流的编程语言，Jetbrain 都有相应的产品。</p>
<p>比如：Python 对应 PyCharm ，Golang 对应 Goland，Java 对应 IntelliJ
IDEA，C 语言对应 Clion 等等。</p>
<p>在这些众多的 IDE 中，有一些提供了多种版本：<code class="docutils literal notranslate"><span class="pre">教育版</span></code>、<code class="docutils literal notranslate"><span class="pre">社区版</span></code>
和 <code class="docutils literal notranslate"><span class="pre">专业版</span></code>。</p>
<blockquote>
<div><p>PyCharm Edu is based on PyCharm Community Edition and comprises all
its features, making it just perfectly suitable for writing
professional projects with Python.</p>
</div></blockquote>
<p>教育版：教育版是免费的，具备社区版的所有功能，除此之外，还提供有一个教学功能，因此它更适合学生。老师可以用它创建教学，学生可以通过他完成教学任务。</p>
<p>社区版：就是阉割版的专业版，它也是免费的，如果你并不需要使用专业版才有那些功能，可以选择社区版。</p>
<p>专业版：提供所有 PyCharm 的功能，虽然是收费的，但是可以试用一个月。</p>
<p>社区版和专业版在功能上有哪些区别呢？你可以看下面这个表格。</p>
<p>可以看出专业版比社区版多了
<code class="docutils literal notranslate"><span class="pre">科学工具</span></code>、<code class="docutils literal notranslate"><span class="pre">WEB</span> <span class="pre">开发</span></code>、<code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">Web</span> <span class="pre">框架</span></code>、<code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">代码分析</span></code>、<code class="docutils literal notranslate"><span class="pre">远程开发调试</span></code>、<code class="docutils literal notranslate"><span class="pre">数据库支持</span></code>。</p>
<p><img alt="image0" src="http://image.iswbm.com/20190506150523.png" /></p>
<p>社区版的功能有限，有些非常好用的功能只有专业版才有，比如 远程调试。</p>
<p>如果你想使用到专业版，那有什么办法呢？</p>
<ol class="arabic simple">
<li><p>有钱的就是大爷，付费购买。</p></li>
<li><p>穷人自有穷活法，每次试用一个月，试用期到，卸载干净，再来一次。</p></li>
<li><p>利用学生与教师的特权，可申请免费使用</p></li>
<li><p>若你有开源项目，也可以申请免费使用</p></li>
<li><p>用一些 <code class="docutils literal notranslate"><span class="pre">非寻常手段</span></code> （也就是破解）来实现。</p></li>
</ol>
<p>破解的方法，其实还分很多种：</p>
<ol class="arabic simple">
<li><p>可以使用注册服务器的方式，优点是非常方便，缺点是过一段时间就有可能失效，不稳定。</p></li>
<li><p>还可以使用破解补丁的方式，优点是永久破解（使用期限到 2099 或者
2100年，某种意义上算是永久了），缺点是对于最新版的 PyCharm
你可能找不到相应的破解补丁。如果要使用这种方法，就意味着你得使用旧版的
PyCharm 。</p></li>
<li><p>使用绿色免安装的 PyCharm
安装包，其实原理和第二种一样，这一种只是别人帮你破解好，你直接用而已。只适用于
Windows 。</p></li>
</ol>
<p>那么这么多版本，该怎么选择呢？</p>
<p>一般来说：</p>
<ul class="simple">
<li><p>如果你是学生，那么可以直接向 Jetbrain 免费申请专业版。</p></li>
<li><p>如果你是新手，直接安装社区版就行了，功能已经够用了。</p></li>
<li><p>如果你想使用更多好用的 专业版功能，那么花钱去购买吧。</p></li>
</ul>
<p>如果你暂时付不起购买费用，可以加下面微信，我这有
<code class="docutils literal notranslate"><span class="pre">绿色免安装的专业版</span></code>，对，就是那种连安装都不用安装的 专业版。</p>
<p><img alt="image1" src="http://image.iswbm.com/image-20201218210141865.png" /></p>
<div class="section" id="id1">
<h4>1. 下载链接<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>PyCharm for Windows
：<a class="reference external" href="https://www.jetbrains.com/pycharm/download/#section=windows">https://www.jetbrains.com/pycharm/download/#section=windows</a></p>
<p>PyCharm for Mac
：<a class="reference external" href="https://www.jetbrains.com/pycharm/download/#section=mac">https://www.jetbrains.com/pycharm/download/#section=mac</a></p>
<p>PyCharm for Linux
：<a class="reference external" href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></p>
<p><img alt="image2" src="http://image.iswbm.com/20200901213017.png" /></p>
</div>
<div class="section" id="id2">
<h4>2. 安装步骤<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>下载完成后，双击 exe 文件</p>
<p><img alt="image3" src="http://image.iswbm.com/20200901213223.png" /></p>
<p>选择安装目录，Pycharm需要的内存较多，建议将其安装在D盘或者E盘，不建议放在系统盘C盘：</p>
<p><img alt="image4" src="http://image.iswbm.com/20200901213310.png" /></p>
<p>选好路径后，点击 Next ，创建桌面快捷方式等一系列选项参照下图勾选！</p>
<p><img alt="image5" src="http://image.iswbm.com/20200901213325.png" /></p>
<p>最后默认安装即可，直接点击Install。</p>
<p><img alt="image6" src="http://image.iswbm.com/20200901213415.png" /></p>
<p>7、耐心的等待两分钟左右。</p>
<p>之后就会得到下面的安装完成的界面</p>
<p><img alt="image7" src="http://image.iswbm.com/20200901213504.png" /></p>
<p>点击Finish，Pycharm安装完成。</p>
<p>接下来对Pycharm进行配置，双击运行桌面上的Pycharm图标，进入下图界面：</p>
<p><img alt="image8" src="http://image.iswbm.com/20200901213526.png" /></p>
<p>选择Do not import settings，之后选择OK，进入下一步。</p>
<p>下面是选择主题</p>
<p>-&gt; 这里默认选择黑色(左边黑色,右边白色)</p>
<p>-&gt; 点击Next:Featured plugins</p>
<p><img alt="image9" src="http://image.iswbm.com/20200901213602.png" /></p>
<p>建议选择Darcula主题，该主题更有利于保护眼睛。</p>
<p>一切配置完成后，就会进入 PyCharm 的主界面。</p>
<p>首先，点击 <code class="docutils literal notranslate"><span class="pre">View</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Appearance</span></code> 勾上
<code class="docutils literal notranslate"><span class="pre">Toolbar</span></code>，来调出工具栏，个人认为这个工具栏对于新手非常有用，使用频率很高。</p>
<p><img alt="image10" src="http://image.iswbm.com/20201218203225.png" /></p>
<p>再然后，应该告诉 PyCharm 你的 CPython 解释器在哪里？不然后面要执行
Python 代码的时候，都不知道去哪里找。</p>
<p>点击 <code class="docutils literal notranslate"><span class="pre">File</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Settings</span></code> ，就会出现如下界面，在搜索框输入
<code class="docutils literal notranslate"><span class="pre">interpreter</span></code> ，点击右上角的 <code class="docutils literal notranslate"><span class="pre">Add</span></code></p>
<p><img alt="image11" src="http://image.iswbm.com/20201218203836.png" /></p>
<p>跳到如下界面，再选择 <code class="docutils literal notranslate"><span class="pre">System</span> <span class="pre">Interpreter</span></code>
，然后右边选择你在上一节中安装 CPython 的路径。</p>
<p><img alt="image12" src="http://image.iswbm.com/20201218203632.png" /></p>
<p>然后在文件夹下，新建一个 <code class="docutils literal notranslate"><span class="pre">demo.py</span></code>
的文件，并写入如下代码，然后再点击上面的 <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Configuration</span></code>
配置脚本运行的参数</p>
<p><img alt="image13" src="http://image.iswbm.com/20201218204204.png" /></p>
<p>接下来，我们要在 PyCharm 中运行这个 <code class="docutils literal notranslate"><span class="pre">demo.py</span></code> 这个脚本了。右键然后选择
<code class="docutils literal notranslate"><span class="pre">Run</span> <span class="pre">'demo'</span></code> ，或者直接按住快捷键：<code class="docutils literal notranslate"><span class="pre">Ctrl+Shift+F10</span></code></p>
<p><img alt="image14" src="http://image.iswbm.com/image-20201218204355375.png" /></p>
<p>运行后，在下面就会弹出一个 <code class="docutils literal notranslate"><span class="pre">Run</span></code> 窗口，你在执行 Python
脚本时，所有的输出内容，都会出现在这里。</p>
<p><img alt="image15" src="http://image.iswbm.com/image-20201218204718039.png" /></p>
<p>至此， PyCharm
这个非常好用的集成开发环境就配置完成了，后面我们就要正式开始接触代码了。</p>
<p>另外，关于 PyCharm
的使用，我花了两个月的时间，整理了一份非常实用且全面的 <a class="reference external" href="http://pycharm.iswbm.com/">《PyCharm
中文指南》</a>，点击这个链接，即可跳转学习：<a class="reference external" href="http://pycharm.iswbm.com/">http://pycharm.iswbm.com/</a></p>
<p><img alt="image16" src="http://image.iswbm.com/20200901220204.png" /></p>
</div>
</div>
<span id="document-c01/c01_03"></span><div class="section" id="python">
<h3>1.3 【基础】两种运行 Python 程序方法<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<p>前两节我们安装好了 CPython 解释器，有了解释器，就可以运行 Python
程序了。</p>
<p>Python 程序的执行分为两种：</p>
<ol class="arabic simple">
<li><p>使用Python Console 界面上执行 Python 语句</p></li>
<li><p>使用命令行执行 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 后缀的脚本文件</p></li>
</ol>
<p>下面分别对这两种方法进行演示。</p>
<div class="section" id="id1">
<h4>1. 第一种方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>首先打开你的终端，直接输入 <code class="docutils literal notranslate"><span class="pre">python3</span></code> 回车，然后输入
<code class="docutils literal notranslate"><span class="pre">print(&quot;Hello,</span> <span class="pre">World&quot;)</span></code>，就时候就会在屏幕上打印出 <code class="docutils literal notranslate"><span class="pre">Hello,</span> <span class="pre">World</span></code>
这几个字符。<code class="docutils literal notranslate"><span class="pre">print</span></code> 是 Python
的一个函数，通过它可以把你内容输出到终端屏幕上。这是我们写的第一行
Python 代码，调用的第一个 Python 函数，也是第一个 Python 程序。</p>
<p><img alt="image0" src="http://image.iswbm.com/20201218210312.png" /></p>
</div>
<div class="section" id="id2">
<h4>2. 第二种方法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>还记得我们在上一节中新建了个 Python 脚本文件 <code class="docutils literal notranslate"><span class="pre">demo.py</span></code> 吗？</p>
<p>当时我是使用 PyCharm 直接执行的，隐藏了一些运行细节，如果我不想通过
PyCharm 来执行脚本，有什么办法呢？</p>
<p>首先先进入脚本所在的文件夹，然后按住 <code class="docutils literal notranslate"><span class="pre">Shift</span></code> 和
右键，再点击如图位置打开 <code class="docutils literal notranslate"><span class="pre">PowerShell</span></code></p>
<p><img alt="image1" src="http://image.iswbm.com/image-20201218210755151.png" /></p>
<p>然后在 <code class="docutils literal notranslate"><span class="pre">PowerShell</span></code> 中输入 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">dmeo.py</span></code>，就可以执行这个 python
脚本啦。</p>
<p><img alt="image2" src="http://image.iswbm.com/image-20201218210911124.png" /></p>
<p>以上介绍了两种最原始的 Python 程序的执行方式。</p>
</div>
<div class="section" id="id3">
<h4>3. 重要提示<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>在后面学习 Python
基础的时候，我在演示案例的时候，都会使用第一种方法（代码框里最前面会有
<code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code> 标识），请你注意，后面不再提及。</p></li>
<li><p>实际上不管你使用哪个编辑器和 IDE 执行 Python
文件，它们的本质都是采用的第二种方法，因此这里很有必要向你介绍。</p></li>
</ol>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p02"></span><div class="section" id="id1">
<h2>第二章：数据类型<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c02/c02_01"></span><div class="section" id="id1">
<h3>2.1 【基础】常量与变量<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><strong>变量</strong>：在程序运行过程中，值会发生变化的量</p>
<p><strong>常量</strong>：在程序运行过程中，值不会发生变化的量</p>
<p>无论是变量还是常量，在创建时都会在内存中开辟一块空间，用于保存它的值。</p>
<div class="section" id="id2">
<h4>1. 变量不需要声明类型<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Python
的变量和常量不需要事先声明类型，这是根据Python的动态语言特性而来。</p>
<p>例如下面的 <code class="docutils literal notranslate"><span class="pre">age</span></code> 和 <code class="docutils literal notranslate"><span class="pre">name</span></code> 两个变量，在使用前没有进行任何的诸如
<code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">int</span></code> 和 <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">string</span></code> 的类型声明，而这在一些静态语言中，比如
JAVA 和 Golang 中是必须的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;王炳明&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 赋值与比较<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Python 中 用 <code class="docutils literal notranslate"><span class="pre">=</span></code> 号来给变量赋值，比如下面这个表达式，age
这个变量的值就是 18</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
</pre></div>
</div>
<p>与之相似的，新手会容易混淆的是 两个等号 <code class="docutils literal notranslate"><span class="pre">==</span></code>
，它表示的是比较两个值是否相等，如果相等返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，如果不相等返回
<code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">==</span> <span class="mi">18</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">==</span> <span class="mi">17</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. 先创建再使用<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p>
<p>新的变量通过赋值的动作，创建并开辟内存空间，保存值。</p>
<p>如果没有赋值而直接使用，会抛出变量未定义的异常。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NameError</span>: <span class="n">name &#39;age&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span>
<span class="go">18</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>4. 赋值的方式<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>赋值的两种方式</p>
<p>第一种：单个直接赋值</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span>
<span class="go">18</span>
</pre></div>
</div>
<p>第二种：多个批量赋值</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">1</span>
</pre></div>
</div>
<p>第三种：先计算再赋值</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 先计算 17+1，再把结果赋值给age</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">17</span><span class="o">+</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">age</span>
<span class="mi">18</span>
</pre></div>
</div>
<p>第四种：分别赋值</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>5. 理解赋值的背后<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>理解变量在计算机内存中的表示也非常重要。</p>
<p>当我们写：<code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">&quot;Jack&quot;</span></code> 时，Python解释器干了两件事情：</p>
<ol class="arabic simple">
<li><p>在内存中创建了一个‘ABC’的字符串对象；</p></li>
<li><p>在内存中创建了一个名为a的变量，并把它指向 <code class="docutils literal notranslate"><span class="pre">'Jack'</span></code>。</p></li>
</ol>
<p>而当你把一个变量a赋值给另一个变量b，这个操作实际上是将变量b指向变量a所指向的数据，例如下面的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;Jack&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;Jack&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&#39;Jack&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4332916664</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4332916664</span>
</pre></div>
</div>
<p>通过<code class="docutils literal notranslate"><span class="pre">id()</span></code> 可以查看变量值的内存地址，打印出来的 name 和 name_bak
的内存地址是一样的，因此二者其实是一个数据。</p>
<p>但如果继续对 a 进行赋值其他值， 会发现 a 的内存地址变了，而 b 的并没有变</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;Tom&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;Tom&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4332974128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4332916664</span>
</pre></div>
</div>
<p>请牢记：<strong>Python中的一切都是对象，变量是对象的引用！</strong>：</p>
<ul class="simple">
<li><p>执行a =
‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</p></li>
<li><p>执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象；</p></li>
<li><p>执行a =
‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</p></li>
</ul>
<div class="figure align-default" id="id8">
<img alt="image.png-43.8kB" src="https://img2020.cnblogs.com/blog/1762677/202010/1762677-20201007160345007-1420712915.png" />
<p class="caption"><span class="caption-text">image.png-43.8kB</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id7">
<h4>6. 简单介绍常量<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>说完变量，还要说下常量。</p>
<p>常量就是不变的变量，比如常用的数学常数圆周率就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">3.14159265359</span>
</pre></div>
</div>
<p>但事实上，从Python语法角度看，PI仍然是一个变量，因为Python根本没有任何机制保证PI不会被改变。你完全可以给PI赋值为10，不会弹出任何错误。所以，用全部大写的变量名表示常量只是一个习惯上的用法。</p>
<p>常量通常放置在代码的最上部，并作为全局使用。</p>
</div>
</div>
<span id="document-c02/c02_02"></span><div class="section" id="id1">
<h3>2.2 【基础】字符串类型<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 如何定义字符串？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>字符串是Python中最常用的数据类型之一。</p>
<p>使用单引号或双引号来创建字符串，使用三引号创建多行字符串。字符串要么使用两个单引号，要么两个双引号，不能一单一双！Python不支持单字符类型，单字符在Python中也是作为一个字符串使用。</p>
<p>以下四种写法是等价的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name_1</span> <span class="o">=</span> <span class="s1">&#39;Jack&#39;</span>  <span class="c1"># 单引号</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_2</span> <span class="o">=</span> <span class="s2">&quot;Jack&quot;</span>  <span class="c1"># 双引号</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_3</span> <span class="o">=</span>  <span class="s1">&#39;&#39;&#39;Jack&#39;&#39;&#39;</span> <span class="c1"># 三个单引号</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_4</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Jack&quot;&quot;&quot;</span>  <span class="c1"># 三个双引号</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_1</span> <span class="o">==</span> <span class="n">name_2</span> <span class="o">==</span> <span class="n">name_3</span> <span class="o">==</span> <span class="n">name_4</span>
<span class="go">True</span>
</pre></div>
</div>
<p>如果一个字符串里，要有引号，那么最好和外部包裹的引号类型不同，比如</p>
<ul class="simple">
<li><p>外层使用单引号，那么里层使用双引号</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;my name is &#39;Jack&#39;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span>
<span class="go">&quot;my name is &#39;Jack&#39;&quot;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>外层使用双引号，那么里层使用单引号</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;my name is &quot;Jack&quot;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span>
<span class="go">&#39;my name is &quot;Jack&quot;&#39;</span>
</pre></div>
</div>
<p>若想使用一样的符号呢？那字符串里的引号前记得加转义符号：<code class="docutils literal notranslate"><span class="pre">\</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;what</span><span class="se">\&#39;</span><span class="s1">s you name?&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span>
<span class="go">&quot;what&#39;s you name?&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 常用的方法<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>字符串对象本身自带了许多非常实用的方法，考虑到新手的接受程序，在这里也没必要一一给你介绍。</p>
<p>本篇文章只会为你介绍最常用的那些方法，而剩下的你只要在需要的时候去过一下文档就
OK了。</p>
<p><strong>去除首尾空格</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;    Python编程时光    &quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>  <span class="c1"># 去除左边空格</span>
<span class="go">&#39;Python编程时光    &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>  <span class="c1"># 去除右边空格</span>
<span class="go">&#39;    Python编程时光&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># 去除左右两边空格</span>
<span class="go">&#39;Python编程时光&#39;</span>
</pre></div>
</div>
<p><strong>判断字符串是否以某字符串开头</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Hello, Python&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p><strong>判断字符串是否以某字符串结尾</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Hello, Python&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Python&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p><strong>格式化字符串</strong>：格式化字符串非常重要，在后面的章节中我有非常详细的讲解，这里你简单了解即可</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;王炳明&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;你好，我是{name}&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span>
<span class="go">&#39;你好，我是王炳明&#39;</span>
</pre></div>
</div>
<p><strong>分割字符串</strong>：以逗号为分割符分割字符串</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">languages</span> <span class="o">=</span> <span class="s2">&quot;Python,Java,Golang&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">languages</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="go">[&#39;Python&#39;, &#39;Java&#39;, &#39;Golang&#39;]</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/c02_03"></span><div class="section" id="id1">
<h3>2.3 【基础】整数与浮点数<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Python 支持的数字类型有三种：整数、浮点数和复数。</p>
<div class="section" id="int">
<h4>1. 整数（Int）<a class="headerlink" href="#int" title="Permalink to this headline">¶</a></h4>
<p>通常被称为整型，是正或负整数，不带小数点。例如：1，100，-8080，0，等等。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>表示数字的时候，有时我们还会用八进制或十六进制来表示：</p>
<ul class="simple">
<li><p>十六进制：用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2。</p></li>
<li><p>八进制：用0o前缀和0-7表示，例如0o12</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mh">0x0001</span> <span class="c1"># 十六进制</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="n">o01</span>  <span class="c1"># 八进制</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="float">
<h4>2. 浮点数(Float)<a class="headerlink" href="#float" title="Permalink to this headline">¶</a></h4>
<p>浮点数也就是小数，如1.23，3.14，-9.01，等等。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;float&#39;&gt;</span>
</pre></div>
</div>
<p>之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，<code class="docutils literal notranslate"><span class="pre">1.23x10^9</span></code>和<code class="docutils literal notranslate"><span class="pre">12.3x10^8</span></code>是完全相等的。浮点数可以用数学写法，如<code class="docutils literal notranslate"><span class="pre">1.23</span></code>，<code class="docutils literal notranslate"><span class="pre">3.14</span></code>，<code class="docutils literal notranslate"><span class="pre">-9.01</span></code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code class="docutils literal notranslate"><span class="pre">1.23e9</span></code>，或者<code class="docutils literal notranslate"><span class="pre">12.3e8</span></code>，0.000012可以写成<code class="docutils literal notranslate"><span class="pre">1.2e-5</span></code>，等等。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.23e9</span>
<span class="go">1230000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">12.3e8</span>
<span class="go">1230000000.0</span>
</pre></div>
</div>
</div>
<div class="section" id="complex">
<h4>3. 复数(Complex)<a class="headerlink" href="#complex" title="Permalink to this headline">¶</a></h4>
<p>复数由实数部分和虚数部分构成，可以用<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">bj</span></code>，或者
<code class="docutils literal notranslate"><span class="pre">complex(a,b)</span></code>
表示，复数的实部a和虚部b都是浮点型。关于复数，不做科学计算或其它特殊需要，通常很难遇到，这里不做过多解释。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mf">0.2j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">(10+0.2j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;complex&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">(10+0.2j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;class &#39;complex&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>4. 常用方法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p><strong>两数运算</strong></p>
<p>两数相加减</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
<span class="go">10</span>
</pre></div>
</div>
<p>两数相乘除</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>取模取余</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">//</span> <span class="n">b</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="go">1</span>
</pre></div>
</div>
<p><strong>计算绝对值</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p><strong>数值直接取整</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">3.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">3.78</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p><strong>数值四舍五入</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">3.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">3.78</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/c02_04"></span><div class="section" id="id1">
<h3>2.4 【基础】布尔值：真与假<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 什么是布尔值<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>但在Python语言中，布尔类型只有两个值</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>：表示真值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>：表示假值</p></li>
</ul>
<p>请注意，首字母要大写，不能是其它花式变型。</p>
<p>所有的计算结果，判断表达式调用返回值是True或者False的过程都可以称为布尔运算，例如比较运算。</p>
<p>布尔值通常用来判断条件是否成立。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">age</span> <span class="o">=</span> <span class="mi">16</span>

<span class="k">if</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;你是个成年人&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;你还未成年&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>在 Python Shell 的模式下，很容易看出表达式返回的是真值还是假值。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">False</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">5</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">==</span> <span class="mi">9</span><span class="o">/</span><span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 布尔类型的转换<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Python内置的 <code class="docutils literal notranslate"><span class="pre">bool()</span></code> 函数可以用来测试一个表达式的布尔值结果。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">([])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(())</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">({})</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="s2">&quot;False&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="s2">&quot;True&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="o">-</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>看完上面的例子，可以总结出</p>
<p>下面这些值经过 bool 转换后是假值：</p>
<ul class="simple">
<li><p>0、0.0、-0.0</p></li>
<li><p>None：这个后面会讲到</p></li>
<li><p>空字符串、空列表、空元组、空字典</p></li>
</ul>
<p>而这些会转换成真值</p>
<ul class="simple">
<li><p>-1、1或者其他非0数值</p></li>
<li><p>所有非空字符串，包括 <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code></p></li>
<li><p>所有非空字典、非空列表、非空集合，非空元组</p></li>
</ul>
</div>
<div class="section" id="id4">
<h4>3. 布尔运算<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>布尔类型可以进行 and、or和 not运算。</p>
<p>and 运算是与运算，只有所有都为True，and运算的结果才是True：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">and</span> <span class="bp">True</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">and</span> <span class="bp">False</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">False</span> <span class="ow">and</span> <span class="bp">False</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>or运算是或运算，只要其中有一个为True，or运算结果就是True：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">or</span> <span class="bp">True</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">or</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">False</span> <span class="ow">or</span> <span class="bp">False</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>not运算是非运算，它是单目运算符，把True变成False，False变成True：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="bp">True</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>再开下脑洞，布尔类型还能做别的运算吗？试试就知道了！</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="o">&gt;</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="o">&lt;</span> <span class="bp">False</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="o">&gt;=</span><span class="bp">False</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="o">-</span><span class="mi">1</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="o">*</span><span class="mi">3</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">False</span> <span class="o">-</span><span class="mi">1</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>真的可以！比较运算，四则运算都没有问题。并且在做四则运算的时候，明显把True看做1，False看做0。往往是我们不知道的细节，有时候给我们带来巨大的困扰和疑惑。更多的运算种类支持，请大家自行测试。</p>
</div>
<div class="section" id="none">
<h4>4. 空值：None<a class="headerlink" href="#none" title="Permalink to this headline">¶</a></h4>
<p>空值不是布尔类型，严格的来说放在这里是不合适的，只不过和布尔关系比较紧密。</p>
<p>空值是Python里一个特殊的值，用None表示（首字母大写）。None不能理解为
0，因为0是整数类型，而None是一个特殊的值。</p>
<p><strong>None也不是布尔类型，而是NoneType</strong>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">&lt;class &#39;NoneType&#39;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/c02_05"></span><div class="section" id="id1">
<h3>2.5 【基础】学会输入与输出<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>无论是从我们一开始的“hello
world”，还是前面章节的里各种例子，基本都是些“自说自话”，展示类的代码片段。只有能够接收用户输入，根据输入动态生成结果，并输出到屏幕上展示出来，才算一个较为完整，起码是有那么点乐趣或者说成就的简单程序。</p>
<div class="section" id="input">
<h4>1. input 输入函数<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h4>
<p>input函数：获取用户输入，保存成一个<strong>字符串</strong>。重要的话，说两遍，input函数的返回值是一个字符串类型。哪怕你输入的是个数字1，返回给你的只会是字符串“1”，而不是
整数1。下面是一些简单的展示例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>  <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;please input your name: &quot;</span><span class="p">)</span>
<span class="go">please input your name: jack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;jack&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="go">&lt;class &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>第一个例子中，<code class="docutils literal notranslate"><span class="pre">inp</span> <span class="pre">=</span> <span class="pre">input(&quot;please</span> <span class="pre">input</span> <span class="pre">your</span> <span class="pre">name:</span> <span class="pre">&quot;)</span></code>，input函数里可以提供一个字符串，用来给用户进行输入提示。input函数的返回值赋值给inp这个变量后，inp里就保存了用户输入的值。</p>
<p><code class="docutils literal notranslate"><span class="pre">type()</span></code>
是Python内置的函数之一，非常有用，用于查看对象的数据类型。例子中的 name
是一个str字符串类型，这验证了我们前面说的话。</p>
<p>如果你想要输入的是数值，那么需要你手动使用 <code class="docutils literal notranslate"><span class="pre">int()</span></code> 函数转一下类型</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;please input your age: &quot;</span><span class="p">)</span>
<span class="go">please input your age: 18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span>
<span class="go">&#39;18&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>有时候可能输入两边会多敲入几个空格，这时候可以使用 <code class="docutils literal notranslate"><span class="pre">strip()</span></code>
函数去除首尾空格</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>  <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;please input your name: &quot;</span><span class="p">)</span>
<span class="go">please input your name:      jack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;     jack&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;jack&#39;</span>
</pre></div>
</div>
<p>有时候用户输入的内容会不符合程序的预期，比如我想要获取年龄，那输入必然是全数字，而不能是其他非数值，这时候就可以使用
<code class="docutils literal notranslate"><span class="pre">isdigit</span></code> 函数进行判断</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;please input your age: &quot;</span><span class="p">)</span>
<span class="go">please input your age: jack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">age</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">age</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;你的年龄是: &quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;输入不合法！&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">输入不合法！</span>
</pre></div>
</div>
<p>input函数有时可以巧妙地用于阻塞或暂停程序</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;程序前面部分执行完毕......&quot;</span><span class="p">)</span>

<span class="nb">input</span><span class="p">(</span><span class="s2">&quot;请按回车继续......&quot;</span><span class="p">)</span>       <span class="c1"># 在这里程序会暂停，等待你的回车动作</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;继续执行程序的后面部分......&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>此时的input函数不会将输入保存下来，只是用作暂停程序动作。</p>
</div>
<div class="section" id="print">
<h4>2. print 输入函数<a class="headerlink" href="#print" title="Permalink to this headline">¶</a></h4>
<p>print函数我们其实已经不陌生了，前前后后也用了不少次，多少有点经验，明白点它的用法了。</p>
<p>print函数用于将内容格式化显示在标准输出上，主要指的是屏幕显示器。</p>
<p>print可以接受多个字符串，字符串类型的变量或者可print的对象。每个字符串用逗号“,”隔开，连成一串输出。print会依次打印每个字符串，同时，每遇到一个逗号“,”就输出一个空格。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;i am&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;student&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="s2">&quot;a&quot;</span> <span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">i am a student      # 自动以空格分隔</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="s2">&quot;a&quot;</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
<span class="go">i amastudent        # 无分隔</span>
</pre></div>
</div>
<p>对于形如<code class="docutils literal notranslate"><span class="pre">print(a+&quot;a&quot;+b)</span></code>的语句，其实是先计算<code class="docutils literal notranslate"><span class="pre">a+&quot;a&quot;+b</span></code>的值，然后再通过print打印它。print()会自动执行内部的语句，输出想要的结果。再看一个例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)))</span>        <span class="c1"># 先求a*b，再求和，再打印</span>
<span class="go">30</span>
</pre></div>
</div>
<p>我们看一下print函数的原型：<code class="docutils literal notranslate"><span class="pre">print(self,</span> <span class="pre">*args,</span> <span class="pre">sep='</span> <span class="pre">',</span> <span class="pre">end='\n',</span> <span class="pre">file=None)</span></code></p>
<p><strong>sep参数</strong>: 分隔的符号，默认是一个空格；</p>
<p><strong>end参数</strong>:
打印后的结束方式，默认为换行符<code class="docutils literal notranslate"><span class="pre">\n</span></code>。如果，设置<code class="docutils literal notranslate"><span class="pre">end=''</span></code>，则可以不换行，让print在一行内连续打印。活用print的参数，可以实现灵活的打印控制。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;i am&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;student&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="s2">&quot;a&quot;</span> <span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>
<span class="go">i am*a*student</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/c02_06"></span><div class="section" id="id1">
<h3>2.6 【基础】字符串格式化<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>格式化输出，主要有三种方式</p>
<ol class="arabic simple">
<li><p>使用 % 进行格式化</p></li>
<li><p>使用 format 函数进行格式化</p></li>
<li><p>使用 f-string 进行格式化</p></li>
</ol>
<p>由于这三种格式化的内容都非常的多，这里仅为了你看本教程后面的内容，我只介绍最常用的几种</p>
<div class="section" id="id2">
<h4>第一种方法：使用 %<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">%s</span></code> 表示这个位置接的是一个字符串变量</p>
<p><code class="docutils literal notranslate"><span class="pre">%d</span></code> 表示这个位置接的是一个整型变量</p>
<p>前面有多少个 %，后面就要有多少个变量，一一对应，多个变量要括号括起来</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Jack&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;我的名字是: </span><span class="si">%s</span><span class="s2">，今年 </span><span class="si">%d</span><span class="s2"> 岁&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>
<span class="go">我的名字是: Jack，今年 18 岁</span>
</pre></div>
</div>
<p>更多的格式化式符号，可以参考这张表</p>
<p><img alt="image0" src="http://image.iswbm.com/20201209211318.png" /></p>
</div>
<div class="section" id="format">
<h4>第二种方法：使用 format<a class="headerlink" href="#format" title="Permalink to this headline">¶</a></h4>
<p>在字符串中，使用 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 进行占位，然后在字符串后跟上 <code class="docutils literal notranslate"><span class="pre">.format()</span></code>
函数，这个函数的参数就是我们要往字符串中填充的变量。</p>
<p>format 函数会依次填充，比如第一个 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 会取到第一个参数 name，第二个
<code class="docutils literal notranslate"><span class="pre">{}</span></code> 会取到第二个参数 age</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Jack&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;我的名字是:{}, 今年 {} 岁&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>
<span class="go">我的名字是:Jack, 今年 18 岁</span>
</pre></div>
</div>
<p>然后如果变量值比较多的话，这样往往会看错乱掉。你可以改成使用索引</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;我的名字是:{0}, 今年 {1} 岁&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>
<span class="go">我的名字是:Jack, 今年 18 岁</span>
</pre></div>
</div>
<p>甚至还可以直接用变量名进行替代</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Jack&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;我的名字是:{name}, 今年 {age} 岁&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age</span><span class="p">))</span>
<span class="go">我的名字是:Jack, 今年 18 岁</span>
</pre></div>
</div>
<p>更多 format
函数的用法，可详读我另一篇文章：<a class="reference external" href="https://www.cnblogs.com/wongbingming/p/6848701.html">Python强大的格式化format</a></p>
</div>
<div class="section" id="f-string">
<h4>第三种方法：使用 f-string<a class="headerlink" href="#f-string" title="Permalink to this headline">¶</a></h4>
<p>这种方法是 Python 3.9 才支持的写法，只要你在字符串前面加一个
<code class="docutils literal notranslate"><span class="pre">f</span></code>，开启 f-string ，就可以在字符中写入变量。</p>
<p>直接看案例了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Jack&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;我的名字是:{name}, 今年 {age} 岁&quot;</span><span class="p">)</span>
<span class="go">我的名字是:Jack, 今年 18 岁</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/c02_07"></span><div class="section" id="id1">
<h3>2.6 【基础】运算符（超全整理）<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>0. 什么是运算符？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>本章节主要说明Python的运算符。举个简单的例子 <strong>4 +5 = 9</strong> 。
例子中，4和5被称为操作数，“+”号为运算符。</p>
<p>Python语言支持以下类型的运算符:</p>
<ul class="simple">
<li><p>算术运算符</p></li>
<li><p>比较（关系）运算符</p></li>
<li><p>赋值运算符</p></li>
<li><p>逻辑运算符</p></li>
<li><p>位运算符</p></li>
<li><p>成员运算符</p></li>
<li><p>身份运算符</p></li>
<li><p>运算符优先级</p></li>
</ul>
<p>接下来让我们一个个来学习Python的运算符。</p>
</div>
<hr class="docutils" />
<div class="section" id="python">
<h4>1. Python算术运算符<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h4>
<p>以下假设变量a为10，变量b为20：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>运算符</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>实例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>加 - 两个对象相加</p></td>
<td><p>a + b 输出结果 30</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td colspan="2"><p>减 -                  | a - b 输出结果 -10
得到负数或是一个数减去另一个数 |</p></td>
</tr>
<tr class="row-even"><td><p>*</p></td>
<td colspan="2"><p>乘 -                  | a * b 输出结果 200
两个数相乘或是返回一个被重复若干次的字符串 |</p></td>
</tr>
<tr class="row-odd"><td><p>/</p></td>
<td><p>除 - x除以y</p></td>
<td><p>b / a 输出结果 2</p></td>
</tr>
<tr class="row-even"><td><p>%</p></td>
<td><p>取模 - 返回除法的余数</p></td>
<td><p>b % a 输出结果 0</p></td>
</tr>
<tr class="row-odd"><td><p>**</p></td>
<td><p>幂 - 返回x的y次幂</p></td>
<td><p>a**b 为10的20次方，
输出结果
100000000000000000000</p></td>
</tr>
<tr class="row-even"><td><p>//</p></td>
<td><p>取整除 -
返回商的整数部分</p></td>
<td><p>9//2 输出结果 4 ,
9.0//2.0 输出结果 4.0</p></td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有算术运算符的操作</p>
<p><strong>两数相加减</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
<span class="go">10</span>
</pre></div>
</div>
<p><strong>两数相乘除</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p><strong>取模取余</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">//</span> <span class="n">b</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. Python比较运算符<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>以下假设变量a为10，变量b为20：</p>
<p>以下实例演示了Python所有比较运算符的操作：</p>
<p>判断两数是否相等</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>判断 a 是否大于 b</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. Python赋值运算符<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>以下假设变量a为10，变量b为20：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 28%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>运算符</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>实例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>=</p></td>
<td><p>简单的赋值运算符</p></td>
<td><p>c = a + b 将 a + b 的运算结果赋值为 c</p></td>
</tr>
<tr class="row-odd"><td><p>+=</p></td>
<td><p>加法赋值运算符</p></td>
<td><p>c += a 等效于 c = c + a</p></td>
</tr>
<tr class="row-even"><td><p>-=</p></td>
<td><p>减法赋值运算符</p></td>
<td><p>c -= a 等效于 c = c - a</p></td>
</tr>
<tr class="row-odd"><td><p>*=</p></td>
<td><p>乘法赋值运算符</p></td>
<td><p>c <em>= a 等效于 c = c</em> a</p></td>
</tr>
<tr class="row-even"><td><p>/=</p></td>
<td><p>除法赋值运算符</p></td>
<td><p>c /= a 等效于 c = c / a</p></td>
</tr>
<tr class="row-odd"><td><p>%=</p></td>
<td><p>取模赋值运算符</p></td>
<td><p>c %= a 等效于 c = c % a</p></td>
</tr>
<tr class="row-even"><td><p>**=</p></td>
<td><p>幂赋值运算符</p></td>
<td><p>c <strong>= a 等效于 c = c</strong> a</p></td>
</tr>
<tr class="row-odd"><td><p>//=</p></td>
<td><p>取整除赋值运算符</p></td>
<td><p>c //= a 等效于 c = c // a</p></td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有赋值运算符的操作：</p>
<p>这里只以加减为例，其它的同理</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>4. Python位运算符<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p>
<p>以下实例演示了Python所有位运算符的操作：</p>
<p>与运算</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># 60 = 0011 1100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">13</span>  <span class="c1"># 13 = 0000 1101</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>  <span class="c1"># 12 = 0000 1100</span>
<span class="go">12</span>
</pre></div>
</div>
<p>或运算</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span>  <span class="c1">#  61 = 0011 1101</span>
<span class="go">61</span>
</pre></div>
</div>
<p>异或运算</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>  <span class="c1"># 49 = 0011 0001</span>
<span class="go">49</span>
</pre></div>
</div>
<p>取反运算</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># 60 = 0011 1100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">a</span>        <span class="c1"># -61 = 1100 0011</span>
<span class="go">-61</span>
</pre></div>
</div>
<p>左移动运算符</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># 60 = 0011 1100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>  <span class="c1"># 240 = 1111 0000</span>
<span class="go">240</span>
</pre></div>
</div>
<p>右移动运算符</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># 60 = 0011 1100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>  <span class="c1"># 15 = 0000 1111</span>
<span class="go">15</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>5. Python逻辑运算符<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 9%" />
<col style="width: 64%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="3"><p>运 | 逻辑表达 | 描述
算 | 式  |
符 |     |</p></th>
<th class="head"><p>实例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>a
n
d</p></td>
<td><p>x
and
y</p></td>
<td><p>布尔“与” - 如果 x 为 False，x and y 返回
False，否则它返回 y 的计算值。</p></td>
<td><p>(a and b)
返回 20。</p></td>
</tr>
<tr class="row-odd"><td><p>o
r</p></td>
<td><p>x or
y</p></td>
<td><p>布尔“或” - 如果 x 是非 0，它返回 x
的值，否则它返回 y 的计算值。</p></td>
<td><p>(a or b) 返回
10。</p></td>
</tr>
<tr class="row-even"><td><p>n
o
t</p></td>
<td><p>not
x</p></td>
<td><p>布尔“非” - 如果 x 为 True，返回 False
。如果 x 为 False，它返回 True。</p></td>
<td><p>not(a and b)
返回 False</p></td>
</tr>
</tbody>
</table>
<p>以上实例输出结果：</p>
<p>and：必须都为True，才能返回True，否则返回False</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">and</span> <span class="bp">True</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">and</span> <span class="bp">False</span>
<span class="go">False</span>
</pre></div>
</div>
<p>or：只要有一个为True，就返回True，其他返回False</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">or</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">True</span> <span class="ow">or</span> <span class="bp">True</span>
<span class="go">True</span>
</pre></div>
</div>
<p>not：与原值取反</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="bp">True</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>6. Python成员运算符<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<p>以下实例演示了Python所有成员运算符的操作：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Apple&quot;</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">]</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Vivo&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>7. Python身份运算符<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>身份运算符用于比较两个对象的存储单元</p>
<p>以下实例演示了Python所有身份运算符的操作：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4532310864</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4532311632</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>8. Python运算符优先级<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>运算符</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>**</p></td>
<td><p>指数 (最高优先级)</p></td>
</tr>
<tr class="row-odd"><td><p>~ + -</p></td>
<td><p>按位翻转, 一元加号和减号
(最后两个的方法名为 +&#64; 和 -&#64;)</p></td>
</tr>
<tr class="row-even"><td><p>* / % //</p></td>
<td><p>乘，除，取模和取整除</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li><ul>
<li></li>
</ul>
</li>
</ul>
</td>
<td><p>加法减法</p></td>
</tr>
<tr class="row-even"><td><p>&gt;&gt; &lt;&lt;</p></td>
<td><p>右移，左移运算符</p></td>
</tr>
<tr class="row-odd"><td><p>&amp;</p></td>
<td><p>位 ‘AND’</p></td>
</tr>
<tr class="row-even"><td><p>^ |</p></td>
<td><p>位运算符</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;= &lt; &gt; &gt;=</p></td>
<td><p>比较运算符</p></td>
</tr>
<tr class="row-even"><td><p>&lt;&gt; == !=</p></td>
<td><p>等于运算符</p></td>
</tr>
<tr class="row-odd"><td><p>= %= /= //= -= += *= **=</p></td>
<td><p>赋值运算符</p></td>
</tr>
<tr class="row-even"><td><p>is is not</p></td>
<td><p>身份运算符</p></td>
</tr>
<tr class="row-odd"><td><p>in not in</p></td>
<td><p>成员运算符</p></td>
</tr>
<tr class="row-even"><td><p>not or and</p></td>
<td><p>逻辑运算符</p></td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python运算符优先级的操作：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">20</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">5</span>
<span class="go">32.0</span>
</pre></div>
</div>
<p>计算顺序是</p>
<ol class="arabic simple">
<li><p>30*2 = 60</p></li>
<li><p>60/5 = 12.0</p></li>
<li><p>20 + 12.0 = 32.0</p></li>
</ol>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p03"></span><div class="section" id="id1">
<h2>第三章：数据结构<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c03/c03_01"></span><div class="section" id="id1">
<h3>3.1 【基础】列表<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>列表（英文名 list），是由一系列元素按顺序进行排列而成的容器。</p>
<p>这里面有两个重点：</p>
<ul class="simple">
<li><p><strong>元素</strong>：没有要求同一类型，所以可以是任意类型。</p></li>
<li><p><strong>顺序</strong>：按顺序排列而成，说明列表是有序的。</p></li>
</ul>
<p>在接下来的例子中，我会向你演示，列表的一些特性和常用的方法。</p>
<div class="section" id="id2">
<h4>1. 创建列表<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>创建列表有两种方法</p>
<p><strong>第一种方法</strong>：先创建空列表实例，再往实例中添加元素</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>   <span class="c1"># 实例化</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Apple&quot;</span><span class="p">)</span>  <span class="c1"># 添加元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Huawei&quot;</span><span class="p">)</span>  <span class="c1"># 添加元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">)</span>  <span class="c1"># 添加元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;Huawei&#39;, &#39;Xiaomi&#39;]</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：直接定义列表，并填充元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;Huawei&#39;, &#39;Xiaomi&#39;]</span>
</pre></div>
</div>
<p>很明显，第二种最简单直接，容易理解。并且经过测试，第二种的效率也比第一种的要高。因此推荐新手使用第二种。</p>
</div>
<div class="section" id="id3">
<h4>2. 增删改查<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p><strong>增删改查</strong>：是 新增元素、删除元素、修改元素、查看元素的简写。</p>
<p>由于，内容比较简单，让我们直接看演示</p>
<div class="section" id="id4">
<h5>查看元素<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>使用 <code class="docutils literal notranslate"><span class="pre">[i]</span></code> 的方式查看第 <code class="docutils literal notranslate"><span class="pre">i+1</span></code> 个元素。例如 x 的起始值为 0
，代表第一个元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;Apple&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;Huawei&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;Xiaomi&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 index 方法，查看第一个值为 x 的索引。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;Huawei&quot;</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 count 方法，查看该列表中有几个值为 x</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;Huawei&quot;</span><span class="p">)</span>
<span class="go">2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用内置函数<code class="docutils literal notranslate"><span class="pre">len()</span></code>，可以查看该列表中有几个值</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">phones</span><span class="p">)</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>新增元素<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>使用列表的 append 、insert、和 extend 方法</p>
<ul class="simple">
<li><p>append 方法：将元素插入在列表的最后一个位置</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Apple&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Huawei&quot;</span><span class="p">)</span>  <span class="c1"># append 后 Huawei 会在最后一个位置</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;Huawei&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>insert 方法：将元素插入在列表的指定的位置</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;OPPO&quot;</span><span class="p">)</span>  <span class="c1"># 把 OPPO 插入到索引为 1 的位置</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;OPPO&#39;, &#39;Huawei&#39;, &#39;Xiaomi&#39;]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>extend：将一个新的列表直接连接在旧的列表后面</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;OPPO&quot;</span><span class="p">,</span> <span class="s2">&quot;VIVO&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_phones</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;Huawei&#39;, &#39;Xiaomi&#39;, &#39;OPPO&#39;, &#39;VIVO&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>修改元素<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>直接使用 <code class="docutils literal notranslate"><span class="pre">list[x]=new_item</span></code> 的方法直接替换</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;OPPO&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;OPPO&#39;, &#39;Xiaomi&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>删除元素<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>使用 pop ，remove 、clear 方法或者 del 语句删除元素</p>
<ul class="simple">
<li><p>pop 方法：删除指定位置的元素。默认删除最后一个元素，并返回</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># 删除最后一个元素</span>
<span class="go">&#39;Xiaomi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 删除索引为0的元素</span>
<span class="go">&#39;Apple&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Huawei&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>remove：删除第一个值为 x 的元素。</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;Huawei&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Apple&#39;, &#39;Xiaomi&#39;, &#39;Huawei&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>clear 方法：把所有的元素清空</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>del 语句：清空列表，还有另一种方法</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">phones</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 del 语句，还可以删除某一个或者某几个连续的元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;OPPO&quot;</span><span class="p">,</span> <span class="s2">&quot;VIVO&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">phones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 删除索引为0的元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Huawei&#39;, &#39;Xiaomi&#39;, &#39;OPPO&#39;, &#39;VIVO&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">phones</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># 删除索引在 [1:3) 区间内元素，注意是左闭右开区间</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span>
<span class="go">[&#39;Huawei&#39;, &#39;VIVO&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h4>3. 列表反转<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>列表反转有两种方法</p>
<p><strong>第一种方法</strong>：使用自带的 reverse 方法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span>
<span class="go">[5, 4, 3, 2, 1]</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：使用切片的方法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[5, 4, 3, 2, 1]</span>
</pre></div>
</div>
<p>这两种方法，区别在于：</p>
<ul class="simple">
<li><p>reverse 方法是原地反转，作用在原对象上</p></li>
<li><p>切片反转是返回一个新对象，原对象不改变</p></li>
</ul>
</div>
<div class="section" id="id9">
<h4>4. 列表排序<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>列表的排序同样有两种方法：</p>
<p><strong>第一种方法</strong>：列表对象内置了 sort 方法，可方便我们对元素进行排序。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span>
<span class="go">[1, 2, 4, 7, 8]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：Python 有个内置的 sorted
函数，它不仅可用作列表的排序，后面我们还会学到 字典
等其他数据结构的排序也会用到它。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="go">[1, 2, 4, 7, 8]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>不管用哪种方法，都要保证列表内的元素俩俩是可比较的。</p>
<p>比如，数值和数值是可比较的，字符串和字符串之间是可比较的。</p>
<p>但是数值和字符串是不可比较的，示例如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="s2">&quot;k&quot;</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;&lt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>除了上面介绍的俩种之外，其实利用 sort
函数还可以实现自定义排序，这部分内容对于新手来说学习起来稍有点难度，且用到的场景也不多，因此这边我就不介绍啦。</p>
</div>
</div>
<span id="document-c03/c03_02"></span><div class="section" id="id1">
<h3>3.2 【基础】元组<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>元组（英文名
tuple），和列表非常的相似，它也是由一系列元素按顺序进行排列而成的容器。</p>
<p>不同的是，元组是不可变的，而列表是可变的。</p>
<div class="section" id="id2">
<h4>1. 创建元组<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>创建元组有三种方法</p>
<p><strong>第一种方法</strong>：直接使用 圆括号
将所有的元素进行包围。这有别于创建列表时使用的是中括号：<code class="docutils literal notranslate"><span class="pre">[]</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atuple</span>
<span class="go">(1, 2, 3, 4)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：有时候，创建元组时，圆括号可有可无的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">btuple</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">btuple</span>
<span class="go">(1, 2, 3, 4)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>第三种方法</strong>：使用元组推导式，由于元组是不可变的，所以生成一个生成器对象。这一种对于新手来说可能会比较难以理解，我会放在后面专门进行讲解，这里先作了解，新手可直接跳过。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctuple</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x10a288f90&gt;</span>
</pre></div>
</div>
<p>上面三种方法介绍完毕~</p>
<p>你以为就这么简单？</p>
<p>当你在创建只有一个元素的元组时，你有可能会这样子创建</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ctuple</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctuple</span>
<span class="go">1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>却发现，创建出来的并不是 tuple，而是一个 int 对象。</p>
<p>此时千万要记住，当你创建只包含一个元素的元组时，要在第一个元素后面加一个逗号</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ctuple</span><span class="p">)</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctuple</span>
<span class="go">(1,)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtuple</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">dtuple</span><span class="p">)</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtuple</span>
<span class="go">(1,)</span>
</pre></div>
</div>
<p>另外，创建空元组可以这样</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>  <span class="c1"># 第一种方法</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># 第二种方法</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 增删改查<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>最前面我们说过，元组是不可变的。因此，你想对元组进行修改的行为都是不被允许的。</p>
<p>呐，看一下示例，查看元素可以，但是修改元素和删除元素都报错了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># 查看元素</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
<span class="go">  &gt;&gt;&gt;</span>
<span class="go">  &gt;&gt;&gt; del atuple[0]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object doesn&#39;t support item deletion</span>
</pre></div>
</div>
<p>新增元素呢？当然同样也是不支持的，这里不再演示。</p>
</div>
<div class="section" id="id4">
<h4>3. 元组与列表的转换<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>虽然元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。</p>
<p>元组是 immutable
（不可变的），其序列通常包含不同种类的元素，并且通过解包或者索引来访问（如果是
<code class="docutils literal notranslate"><span class="pre">namedtuples</span></code> 的话甚至还可以通过属性访问）。</p>
<p>列表是 mutable
（可变的），并且列表中的元素一般是同种类型的，并且通过迭代访问。</p>
<p>那有办法可以实现二者的转换吗？</p>
<p>当然有，而且非常简单。</p>
<p><strong>将元组转成列表</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">atuple</span><span class="p">)</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">atuple</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>将列表转成元组</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="go">(1, 2, 3, 4)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c03/c03_03"></span><div class="section" id="id1">
<h3>3.3 【基础】字典<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>字典（英文名
dict），它是由一系列的键值（key-value）对组合而成的数据结构。</p>
<p>字典中的每个键都与一个值相关联，其中</p>
<ol class="arabic simple">
<li><p>键，必须是可 hash 的值，如字符串，数值等</p></li>
<li><p>值，则可以是任意对象</p></li>
</ol>
<div class="section" id="id2">
<h4>1. 创建字典<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>创建一个字典有三种方法</p>
<p><strong>第一种方法</strong>：先使用 <code class="docutils literal notranslate"><span class="pre">dict()</span></code> 创建空字典实例，再往实例中添加元素</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; profile = dict(name=&quot;王炳明&quot;, age=27, 众号=&quot;ython编程时光&quot;)
&gt;&gt;&gt; profile
{&#39;name&#39;: &#39;王炳明&#39;, &#39;age&#39;: 27, &#39;众号&#39;: &#39;ython编程时光&#39;}
</pre></div>
</div>
<p><strong>第二种方法</strong>：直接使用 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 定义字典，并填充元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span>
<span class="go">{&#39;name&#39;: &#39;王炳明&#39;, &#39;age&#39;: 27, &#39;公众号&#39;: &#39;Python编程时光&#39;}</span>
</pre></div>
</div>
<p><strong>第三种方法</strong>：使用 <code class="docutils literal notranslate"><span class="pre">dict()</span></code>
构造函数可以直接从键值对序列里创建字典。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">info</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;王炳明 &#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="mi">27</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;公众号&#39;</span><span class="p">,</span> <span class="s1">&#39;Python编程时光&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
<span class="go">{&#39;name&#39;: &#39;王炳明 &#39;, &#39;age&#39;: 27, &#39;公众号&#39;: &#39;Python编程时光&#39;}</span>
</pre></div>
</div>
<p><strong>第四种方法</strong>：使用字典推导式，这一种对于新手来说可能会比较难以理解，我会放在后面专门进行讲解，这里先作了解，新手可直接跳过。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span>
<span class="go">{2: 4, 4: 16, 6: 36}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 增删改查<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p><strong>增删改查</strong>：是 新增元素、删除元素、修改元素、查看元素的简写。</p>
<p>由于，内容比较简单，让我们直接看演示</p>
<div class="section" id="id4">
<h5>查看元素<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>查看或者访问元素，直接使用 <code class="docutils literal notranslate"><span class="pre">dict[key]</span></code> 的方式就可以</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;公众号&quot;</span><span class="p">]</span>
<span class="go">&#39;Python编程时光&#39;</span>
</pre></div>
</div>
<p>但这种方法，在 key 不存在时会报 KeyValue 的异常</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;gender&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">KeyError</span>: <span class="n">&#39;gender&#39;</span>
</pre></div>
</div>
<p>所以更好的查看获取值的方法是使用 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 函数，当不存在 gender
的key时，默认返回 male</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gender&quot;</span><span class="p">,</span> <span class="s2">&quot;male&quot;</span><span class="p">)</span>
<span class="go">&#39;male&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>新增元素<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>新增元素，直接使用 <code class="docutils literal notranslate"><span class="pre">dict[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> 就可以</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;王炳明&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;公众号&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Python编程时光&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span>
<span class="go">{&#39;name&#39;: &#39;王炳明&#39;,&#39;age&#39;: 27,&#39;公众号&#39;: &#39;Python编程时光&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>修改元素<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>修改元素，直接使用 <code class="docutils literal notranslate"><span class="pre">dict[key]</span> <span class="pre">=</span> <span class="pre">new_value</span></code> 就可以</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span>
<span class="go">{&#39;name&#39;: &#39;王炳明&#39;, &#39;age&#39;: 28, &#39;公众号&#39;: &#39;Python编程时光&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>删除元素<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>删除元素，有三种方法</p>
<p><strong>第一种方法</strong>：使用 pop 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span>
<span class="go">{&#39;name&#39;: &#39;王炳明&#39;, &#39;公众号&#39;: &#39;Python编程时光&#39;}</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：使用 del 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span>
<span class="go">{&#39;name&#39;: &#39;王炳明&#39;, &#39;公众号&#39;: &#39;Python编程时光&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h4>3. 重要方法<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="section" id="key">
<h5>判断key是否存在<a class="headerlink" href="#key" title="Permalink to this headline">¶</a></h5>
<p>在 Python 2 中的字典对象有一个 has_key 函数，可以用来判断一个 key
是否在该字典中</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s2">&quot;gender&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>但是这个方法在 Python 3
中已经取消了，原因是有一种更简单直观的方法，那就是使用 <code class="docutils literal notranslate"><span class="pre">in</span></code> 和
<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> 来判断。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">profile</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;gender&quot;</span> <span class="ow">in</span> <span class="n">profile</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h5>设置默认值<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>要给某个 key 设置默认值，最简单的方法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>

<span class="k">if</span> <span class="s2">&quot;gender&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">:</span>
    <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;male&quot;</span>
</pre></div>
</div>
<p>实际上有个更简单的方法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;公众号&quot;</span><span class="p">:</span> <span class="s2">&quot;Python编程时光&quot;</span><span class="p">}</span>
<span class="n">profile</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;gender&quot;</span><span class="p">,</span> <span class="s2">&quot;male&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-c03/c03_04"></span><div class="section" id="id1">
<h3>3.4 【基础】集合<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>集合（英文名 set），它是一个无序的不重复元素序列。</p>
<p>这里面有两个重点：</p>
<ol class="arabic simple">
<li><p>无序，</p></li>
<li><p>不重复</p></li>
</ol>
<div class="section" id="id2">
<h4>1. 创建集合<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>集合的创建有两种方法</p>
<p><strong>第一种方法</strong>：使用 花括号 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 直接创建，创建的时候，<code class="docutils literal notranslate"><span class="pre">{}</span></code>
可以包含有重要的元素，但是创建完后，集合会去重，只留第一个。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Xiaomi&#39;, &#39;Apple&#39;])</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：使用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 方法进行创建，当<code class="docutils literal notranslate"><span class="pre">set()</span></code>
函数不接任何参数时，创建的是空集合，如果不创建空集合，可以传入一个列表。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># 空集合</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span>
<span class="go">set([])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;, &#39;Xiaomi&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 增删改查<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id4">
<h5>增加元素<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>使用 <code class="docutils literal notranslate"><span class="pre">add</span></code> 函数可以往集合中传入函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;Apple&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;Huawei&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;])</span>
</pre></div>
</div>
<p>另外，还可以使用 <code class="docutils literal notranslate"><span class="pre">update</span></code> 函数，来往集合中添加元素，<code class="docutils literal notranslate"><span class="pre">update</span></code>
函数后可接集合，列表，元组，字典等。</p>
<p>这是接集合的例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 接集合</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;Apple&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Apple&#39;])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 接列表</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="s2">&quot;Huawei&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 接元组</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;, &#39;Xiaomi&#39;])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 接字典</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;VIVO&quot;</span><span class="p">:</span> <span class="s2">&quot;xxxx&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;, &#39;VIVO&#39;, &#39;Xiaomi&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>删除元素<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>使用 <code class="docutils literal notranslate"><span class="pre">remove</span></code> 函数可以删除集合中的元素</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;])</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">remove</span></code> 函数，如果对应的元素不存在，是会报错的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;VIVO&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">KeyError</span>: <span class="n">&#39;VIVO&#39;</span>
</pre></div>
</div>
<p>对于这种情况，你可以使用 <code class="docutils literal notranslate"><span class="pre">discard</span></code>
函数，存在元素则移除，不存在也不会报错。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s2">&quot;VIVO&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Xiaomi&#39;, &#39;Apple&#39;])</span>
</pre></div>
</div>
<p>此外，还有一个 <code class="docutils literal notranslate"><span class="pre">pop</span></code> 函数，用于从集合中随机删除元素，和列表、字典的
<code class="docutils literal notranslate"><span class="pre">pop</span></code> 不一样，这里的 pop 不能加任何的参数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">&#39;Huawei&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">&#39;Xiaomi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">&#39;Apple&#39;</span>
</pre></div>
</div>
<p>最后，还要介绍一个 <code class="docutils literal notranslate"><span class="pre">clear</span></code> 函数，它用于清空集合的元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Xiaomi&#39;, &#39;Apple&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([])</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>修改元素<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>文章开头处，已经说明了集合是 <code class="docutils literal notranslate"><span class="pre">无序</span></code> 的，因此集合是没有索引的。</p>
<p>既然没有索引，修改也无从谈起。</p>
<p><strong>记住</strong>：集合只有添加元素、删除元素。</p>
</div>
<div class="section" id="id7">
<h5>查询元素<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>同上，没有顺序，也就没有索引，没有索引，查询也无从谈起。</p>
<p>但是我们可以查看集合的其他内容</p>
<p>比如，查看集合的长度</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">aset</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h4>3. 集合运算<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id9">
<h5>求合集<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>将两个集合进行合并并去重，可以使用 <code class="docutils literal notranslate"><span class="pre">union</span></code> 函数，下面的示例中，由于
<code class="docutils literal notranslate"><span class="pre">Huawei</span></code> 是重复的元素，只会保留一个。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;, &#39;Xiaomi&#39;])</span>
</pre></div>
</div>
<p>另外还可以使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> 的操作符</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">|</span> <span class="n">bset</span>
<span class="go">set([&#39;Huawei&#39;, &#39;Apple&#39;, &#39;Xiaomi&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h5>求差集<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>要找出存在集合 A 但是不存在 集合 B 的元素，就是对两个集合求差集。</p>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">difference</span></code> 函数，下面的示例中， <code class="docutils literal notranslate"><span class="pre">Apple</span></code> 在 aset
中存在，但在 bset 中不存在。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="go">set([&#39;Apple&#39;])</span>
</pre></div>
</div>
<p>另外还可以使用 <code class="docutils literal notranslate"><span class="pre">-</span></code> 的操作符，更加直观</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">-</span> <span class="n">bset</span>
<span class="go">set([&#39;Apple&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h5>求交集<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>要找出存在集合 A 并且存在集合 B 的元素，就是对两个集合求交集。</p>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">intersection</span></code> 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="go">set([&#39;Huawei&#39;])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>和 <code class="docutils literal notranslate"><span class="pre">intersection</span></code> 相似的还有一个 <code class="docutils literal notranslate"><span class="pre">intersection_update</span></code>
函数，它们的区别是，<code class="docutils literal notranslate"><span class="pre">intersection_update</span></code> 会原地更新在 aset
上，而不是会回交集。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Huawei&#39;])</span>
</pre></div>
</div>
<p>另外还可以使用 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 的操作符</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">&amp;</span> <span class="n">bset</span>
<span class="go">set([&#39;Huawei&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h5>求不重合集<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>如果计算两个集合中不重复的元素集合，可以使用 <code class="docutils literal notranslate"><span class="pre">symmetric_difference</span></code>
函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="go">set([&#39;Xiaomi&#39;, &#39;Apple&#39;])</span>
</pre></div>
</div>
<p>和 <code class="docutils literal notranslate"><span class="pre">symmetric_difference</span></code> 相似的还有一个
<code class="docutils literal notranslate"><span class="pre">symmetric_difference_update</span></code>
函数，它们的区别是，<code class="docutils literal notranslate"><span class="pre">symmetric_difference_update</span></code> 会原地更新在 aset
上，而不是直接返回。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">symmetric_difference_update</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span>
<span class="go">set([&#39;Apple&#39;, &#39;Xiaomi&#39;])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h4>4. 集合判断<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id14">
<h5>判断是否有某元素<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Apple&quot;</span> <span class="ow">in</span> <span class="n">aset</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h5>判断两集合是否有相同元素<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>如果两集合有相同元素，则返回 False，如果没有相同元素，则返回 True</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xiaomi&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h5>判断是否是子集<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Huawei&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bset</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">aset</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-c03/c03_05"></span><div class="section" id="id1">
<h3>3.5 【基础】迭代器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 可迭代对象<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>可以利用 for 循环的对象，都叫可迭代对象。</p>
<p>譬如我们前面学过的 列表、元组、字典、字符串等都是可迭代对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 以列表为例</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="o">...</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 是否可迭代？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>对 Python
比较熟悉的朋友，肯定知道哪些数据类型是可迭代的，哪些是不可迭代的。</p>
<p>但是对新手来说，可能需要借助一些函数来判别，比如 Python 内置的
<code class="docutils literal notranslate"><span class="pre">collections.abc</span></code> 模块，这个模块只有在 Python
中才有噢，在这个模块中提供了一个 Iterable 类，可以用 isinstance 来判断。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">)</span> <span class="c1"># 列表</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">},</span> <span class="n">Iterable</span><span class="p">)</span> <span class="c1"># 字典</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">Iterable</span><span class="p">)</span> <span class="c1"># 元组</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="c1"># 字符串</span>
<span class="go">True</span>
</pre></div>
</div>
<p>但是这种方法并不是百分百准确（具体下面会说到），最准确的方法，还是应该使用
for 循环。</p>
</div>
<div class="section" id="id4">
<h4>3. 可迭代协议<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>可迭代对象内部是如何实现在你对其进行 for
循环时，可以一个一个元素的返回出来呢？</p>
<p>这就要谈到迭代器协议。</p>
<p><strong>第一种场景</strong>：如果一个对象内部实现了 <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> 方法
，并返回一个迭代器实例，那么该对象就是可迭代对象</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">:</span>
    <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># 返回迭代器类的实例</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mylist</span><span class="p">)</span>

<span class="c1"># 得到可迭代对象</span>
<span class="n">my_list</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">))</span> <span class="c1"># True</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>第二种场景</strong>：假设一个对象没有实现 <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> ，Python 解释器
<code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code> 方法获取元素，如果可行，那么该对象也是一个可迭代对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">:</span>
    <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mylist</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

<span class="c1"># 得到一个可迭代对象</span>
<span class="n">my_list</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">))</span> <span class="c1"># False</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>此时如果你使用 <code class="docutils literal notranslate"><span class="pre">isinstance(my_list,</span> <span class="pre">Iterable)</span></code>
去判断是否是可迭代，就会返回 False，因为 isinstance
这种方法就是检查对象是否有 <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> 方法。这也论证了使用
<code class="docutils literal notranslate"><span class="pre">isinstance(my_list,</span> <span class="pre">Iterable)</span></code> 去判断是否可迭代是不准确的。</p>
</div>
<div class="section" id="id5">
<h4>4. 什么是迭代器<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>当你对一个可迭代对象使用 iter
函数后，它会返回一个迭代器对象，对于迭代器对象，我们可以使用 next
函数，去获取元素，每执行一次，获取一次，等到全部获取完毕，会抛出
StopIteration 提示无元素可取。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>5. 迭代器协议<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>对比可迭代对象，<code class="docutils literal notranslate"><span class="pre">迭代器</span></code>的内部只是多了一个函数而已 –
<code class="docutils literal notranslate"><span class="pre">__next__()</span></code></p>
<p>正因为有了它，我们才可以用 next 来获取元素。</p>
<p>迭代器，是在可迭代的基础上实现的。要创建一个迭代器，我们首先，得有一个可迭代对象。
现在就来看看，如何创建一个可迭代对象，并以可迭代对象为基础创建一个迭代器。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># 返回该对象的迭代器类的实例</span>
    <span class="c1"># 因为自己就是迭代器，所以返回self</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># 当无元素时，必要抛出 StopIteration</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mylist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>

<span class="n">my_iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">Array</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_iterator</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">))</span> <span class="c1"># output: True</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">my_iterator</span><span class="p">))</span>  <span class="c1"># output: 0</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">my_iterator</span><span class="p">))</span>  <span class="c1"># output: 1</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">my_iterator</span><span class="p">))</span>  <span class="c1"># output: 2</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">my_iterator</span><span class="p">))</span>  <span class="c1"># StopIteration</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c03/c03_06"></span><div class="section" id="id1">
<h3>3.6 【基础】生成器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 什么是生成器？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>生成器（英文名 Generator
），是一个可以像迭代器那样使用for循环来获取元素的函数。</p>
<p>生成器的出现（Python 2.2
+），实现了延时计算，从而缓解了在大量数据下内存消耗过猛的问题。</p>
<p>当你在 Python Shell 中敲入一个生成器对象，会直接输出
<code class="docutils literal notranslate"><span class="pre">generator</span> <span class="pre">object</span></code> 提示你这是一个生成器对象</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x10cae50b0&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 如何创建生成器？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id4">
<h5>使用列表推导式<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>在上面已经演示过，正常我们使用列表推导式时是下面这样子，使用 <code class="docutils literal notranslate"><span class="pre">[]</span></code>
，此时生成的是列表。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mylist</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>而当你把 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 换成 <code class="docutils literal notranslate"><span class="pre">()</span></code> ，返回的就不是列表了，而是一个生成器</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x10cae50b0&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="yield">
<h5>使用 yield<a class="headerlink" href="#yield" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">yield</span></code> 是什么东西呢? 它相当于我们函数里的 return，但与 return
又有所不同。</p>
<ul class="simple">
<li><p>当一个函数运行到 yield 后，函数的运行会暂停，并且会把 yield
后的值返回出去。</p></li>
<li><p>若 yield 没有接任何值，则返回 None</p></li>
<li><p>yield 虽然返回了，但是函数并没有结束</p></li>
</ul>
<p>请看如下代码，我定义了一个 <code class="docutils literal notranslate"><span class="pre">generator_factory</span></code> 函数，当我执行
<code class="docutils literal notranslate"><span class="pre">gen</span> <span class="pre">=</span> <span class="pre">generator_factory()</span></code> 时，gen 就是一个生成器对象</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator_factory</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;index 值为: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="gp">... </span>        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">index</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">StopIteration</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generator_factory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object generator_factory at 0x1018340b0&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h4>3. 生成器的使用<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>从一个生成器对象中取出元素，和我们前面学过的通过切片访问列表中的元素不一样，它没有那么直观。</p>
<p>想要从生成器对象中取出元素，只有两种方法：</p>
<p><strong>第一种方法</strong>：使用 next
方法一个一个地把元素取出来，如果元素全部取完了，生成器会抛出
<code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> 的异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x1072400b0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p><strong>第二种方法</strong>：使用 for 循环一个一个地迭代出来</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>4. 生成器的激活<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>生成器对象，在创建后，并不会执行任何的代码逻辑。</p>
<p>想要从生成器对象中获取元素，那么第一步要触发其运行，在这里称之为激活。</p>
<p>方法有两种：</p>
<ol class="arabic simple">
<li><p>使用<code class="docutils literal notranslate"><span class="pre">next()</span></code> ：上面已经讲过</p></li>
<li><p>使用<code class="docutils literal notranslate"><span class="pre">generator.send(None)</span></code></p></li>
</ol>
<p>还以下面这段代码为例，可以看到 <code class="docutils literal notranslate"><span class="pre">gen.send(None)</span></code> 相当于执行了
<code class="docutils literal notranslate"><span class="pre">next(gen)</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator_factory</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;index 值为: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="gp">... </span>        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">index</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">StopIteration</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generator_factory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">index 值为: 0</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">index 值为: 1</span>
<span class="go">2</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>5. 生成器的状态<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>生成器在其生命周期中，会有如下四个状态</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GEN_CREATED</span></code> # 生成器已创建，还未被激活</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GEN_RUNNING</span></code> #
解释器正在执行（只有在多线程应用中才能看到这个状态）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GEN_SUSPENDED</span></code> # 在 yield 表达式处暂停</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GEN_CLOSED</span></code> # 生成器执行结束</p></li>
</ul>
<p>通过下面的示例可以很轻松地理解这一过程（<code class="docutils literal notranslate"><span class="pre">GEN_RUNNING</span></code>
这个状态只有在多线程中才能观察到，这里就不演示啦）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getgeneratorstate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">&#39;GEN_CREATED&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">&#39;GEN_SUSPENDED&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">&#39;GEN_CLOSED&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>6. 生成器的异常<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>在最前面，我有定义了一个生成器函数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generator_factory</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="n">index</span>
    <span class="k">raise</span> <span class="ne">StopIteration</span>
</pre></div>
</div>
<p>在没有元素可返回时，我最后抛出了 <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>
异常，这是为了满足生成器的协议。</p>
<p>实际上，如果你不手动抛出 <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>，在生成器遇到函数 return
时，会我自动抛出 <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>。</p>
<p>请看下面代码，我将 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">StopIteration</span></code> 去掉后，仍然会抛出异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator_factory</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">index</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generator_factory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p04"></span><div class="section" id="id1">
<h2>第四章：控制流程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c04/c04_01"></span><div class="section" id="if">
<h3>4.1 【基础】条件语句：if<a class="headerlink" href="#if" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 简单小例子<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>如果满足条件 A，则执行代码块 a，否则执行代码块
b。类似这样的控制流程语句，称之为条件语句。</p>
<p>它的基本形式是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>if 判断条件：
    执行语句……
else：
    执行语句……
</pre></div>
</div>
<p>举个最简单的例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">age</span> <span class="o">&gt;=</span><span class="mi">18</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;已经是成年人&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;还是未成年人&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">已经是成年人</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 多条件语句<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>如果需要多次判断可以利用 <code class="docutils literal notranslate"><span class="pre">elif</span></code>，它的基本形式是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>if 判断条件1：
    执行语句……
elif 判断条件2：
    执行语句……
elif 判断条件3：
    执行语句……
else:
    执行语句……
</pre></div>
</div>
<p>举个最简单的例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="mi">75</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span><span class="mi">90</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;优秀&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">elif</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">80</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;良好&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">elif</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;一般&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">elif</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;合格&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;不合格&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">一般</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 判断的条件<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>在 Python 中，值可以分为</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">假值</span></code> ：None、空列表、空集合、空字典，空元组、空字符串、0、False
等</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">真值</span></code> ：非空列表、非空集合、非空字典，非空元组、非空字符串、非 0
数值、True 等</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 和 <code class="docutils literal notranslate"><span class="pre">elif</span></code>
后面可以接一个表达式（上面已经举例过），也可以接一个对象。</p>
<p>只要这个对象是真假，代码就会进入相应分支，如果为对象为假值，则继续下一判断。</p>
<p>这边随便以 0 和 1 举例</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aint</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">aint</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;ok&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">ok</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>4. 多个条件组合<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>在讲多个条件组合时，先来了解一下 Python 中的逻辑运算符。</p>
<p>以下假设变量 a 为 10, b为 20: | 运算符 | 逻辑表达式 | 描述| 实例 |
| — | — | — | — | | and | x and y | 布尔“与” - 如果 x 为
False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回
20。 | | or | x or y | 布尔“或” - 如果 x 是非 0，它返回 x
的值，否则它返回 y 的计算值。 | (a or b) 返回 10。 | | not | not x
| 布尔“非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回
True。 | not(a and b) 返回 False |</p>
<p>学习完逻辑运算符，就可以开始写多条件语句</p>
<ul class="simple">
<li><p>如果一个 if 条件需要同时满足多个条件，那么可以使用 <code class="docutils literal notranslate"><span class="pre">and</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></li>
<li><p>如果一个 if 条件只需要满足多个条件的其中一个，那么可以使用 <code class="docutils literal notranslate"><span class="pre">or</span></code>
或者 <code class="docutils literal notranslate"><span class="pre">|</span></code></p></li>
<li><p>如果一个 if 要求不满足某个条件，那么可以使用 <code class="docutils literal notranslate"><span class="pre">not</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">!</span></code></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 需要同时满足条件 A 和条件 B
if 条件A and 条件B:
    ...

# 只需要满足条件A或者条件B即可
if 条件A or 条件B:
    ...

# 要求不满足条件A
if not 条件A:
    ...
</pre></div>
</div>
</div>
</div>
<span id="document-c04/c04_02"></span><div class="section" id="for">
<h3>4.2 【基础】循环语句：for<a class="headerlink" href="#for" title="Permalink to this headline">¶</a></h3>
<p>for 循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p>
<p>它的基本语法是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>for 元素 in 序列对象:
   代码块
</pre></div>
</div>
<div class="section" id="id1">
<h4>1. 普通循环<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>直接上案例</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">phone</span> <span class="ow">in</span> <span class="n">phones</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;当前手机是: &quot;</span> <span class="o">+</span> <span class="n">phone</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">当前手机是: Apple</span>
<span class="go">当前手机是: Huawei</span>
<span class="go">当前手机是: Xiaomi</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 带索引循环<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>如果想在循环的时候，把索引也取出来，可以加一个 <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Apple&quot;</span><span class="p">,</span> <span class="s2">&quot;Huawei&quot;</span><span class="p">,</span> <span class="s2">&quot;Xiaomi&quot;</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">phone</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phones</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;我的第 {} 把手机是: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">phone</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">我的第 1 把手机是: Apple</span>
<span class="go">我的第 2 把手机是: Huawei</span>
<span class="go">我的第 3 把手机是: Xiaomi</span>
</pre></div>
</div>
</div>
<div class="section" id="break">
<h4>3. break 中断<a class="headerlink" href="#break" title="Permalink to this headline">¶</a></h4>
<p>正常情况下，我们都需要 for
循环能够全部循环完，但在某些情况下，需要中断循环的执行，中断循环使用的是
<code class="docutils literal notranslate"><span class="pre">break</span></code> 关键字。</p>
<p>举个例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;当前的数是 {i}, 将退出循环&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;当前的数是 &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">当前的数是 0</span>
<span class="go">当前的数是 1, 将退出循环</span>
</pre></div>
</div>
</div>
<div class="section" id="continue">
<h4>4. continue 下一循环<a class="headerlink" href="#continue" title="Permalink to this headline">¶</a></h4>
<p>在有些循环中，不需要把 for
的循环体内的代码全部执行完毕，这种情况下，可以使用 <code class="docutils literal notranslate"><span class="pre">continue</span></code>
关键字，直接进入下一循环。</p>
<p>举个例子，下面的循环中当 i 等于 1 时，就直接跳过了循环。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">continue</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;当前的数是 &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">当前的数是 0</span>
<span class="go">当前的数是 2</span>
</pre></div>
</div>
</div>
<div class="section" id="for-else">
<h4>5. for - else 循环<a class="headerlink" href="#for-else" title="Permalink to this headline">¶</a></h4>
<p>其实在 for 循环语句的后面，可以加一个 else 分支，当代码在 for
循环体中<strong>正常执行完</strong>，自然就会走到 else 分支中。</p>
<p>那么什么叫做 <strong>正常执行完</strong> 呢？就是只要不通过 break
语句中断的，都算正常执行完。</p>
<p>先以 continue 为例，所有的循环都非常正常，会走到 else 分支</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">continue</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;当前的数是 &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;循环非常正常&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">当前的数是 0</span>
<span class="go">当前的数是 2</span>
<span class="go">循环非常正常</span>
</pre></div>
</div>
<p>再把 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 改成 <code class="docutils literal notranslate"><span class="pre">break</span></code> 后，发现不会走到 else 分支</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;当前的数是 &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;循环非常正常&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">当前的数是 0</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c04/c04_03"></span><div class="section" id="while">
<h3>4.3 【基础】循环语句：while<a class="headerlink" href="#while" title="Permalink to this headline">¶</a></h3>
<p>while
语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。</p>
<p>其基本形式为：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>while 判断条件：
    执行语句
</pre></div>
</div>
<div class="section" id="id1">
<h4>1. 普通的循环<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>直接上案例</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">age</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;孩子当前 {age} 岁，还不能上幼儿园&quot;</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;年龄够了，可以上幼儿园了&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行后，输出结果</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>孩子当前 1 岁，还不能上幼儿园
孩子当前 2 岁，还不能上幼儿园
孩子当前 3 岁，还不能上幼儿园
年龄够了，可以上幼儿园了
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 无限的循环<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>当 while 后面的条件一直满足且循环体内一直没有 break ，此时 while
就会变成死循环，就是写 while 循环时千万要注意的。</p>
<p>会造成死循环，无非两种情况：</p>
<p>1、 使用 while True，而且循环体内又没有 break 或者 走不到 break</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">age</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>2、 使用一个永远都会成立的判断条件，而且循环体内又没有 break 或者 走不到
break</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">age</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="while-else">
<h4>3. while - else 语句<a class="headerlink" href="#while-else" title="Permalink to this headline">¶</a></h4>
<p>和 for 循环一样， while 循环同样可以加一个 else 分支，当代码在 while
循环体中<strong>正常执行完</strong>，就会走到 else 分支中。</p>
<p>那么什么叫做 <strong>正常执行完</strong> 呢？就是只要不通过 break
语句中断的，都算正常执行完。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;我已经 {age} 岁了&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;可以上幼儿园了&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">我已经 1 岁了</span>
<span class="go">我已经 2 岁了</span>
<span class="go">我已经 3 岁了</span>
<span class="go">可以上幼儿园了</span>
</pre></div>
</div>
<p>如果在循环体内加 break ，就算是异常退出</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">age</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;我已经 {age} 岁了&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;可以上幼儿园了&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">我已经 1 岁了</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c04/c04_04"></span><div class="section" id="id1">
<h3>4.4 【进阶】五种推导式<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>推导式（英文名：comprehensions），也叫解析式，是Python的一种独有特性。</p>
<p>推导式是可以从一个数据序列构建另一个新的数据序列的结构体。</p>
<p>总共有四种推导式：</p>
<ol class="arabic simple">
<li><p>列表(list)推导式</p></li>
<li><p>字典(dict)推导式</p></li>
<li><p>集合(set)推导式</p></li>
<li><p>生成器推导式</p></li>
</ol>
<div class="section" id="id2">
<h4>1. 列表推导式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>列表推导式的基本格式</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">expression</span> <span class="n">for_loop_expression</span> <span class="k">if</span> <span class="n">condition</span><span class="p">]</span>
</pre></div>
</div>
<p>举个例子。</p>
<p>我想找出一个数值列表中为偶数的元素，并组成新列表，通常不用列表推导式，可以这么写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">old_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

<span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">old_list</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">item</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span> <span class="c1"># output: [0, 2, 4]</span>
</pre></div>
</div>
<p>一个简单的功能，写的代码倒是不少。</p>
<p>如果使用了列表推导式，那就简洁多了，而且代码还变得更加易读了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">old_list</span> <span class="k">if</span> <span class="n">item</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span> <span class="c1"># output: [0, 2, 4]</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 字典推导式<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>列表推导式的基本格式，和 列表推导式相似，只是把 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 改成了
<code class="docutils literal notranslate"><span class="pre">{}</span></code>，并且组成元素有两个：key 和 value，要用
<code class="docutils literal notranslate"><span class="pre">key_expr:</span> <span class="pre">value_expr</span></code> 表示。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_dict</span> <span class="o">=</span><span class="p">{</span> <span class="n">key_expr</span><span class="p">:</span> <span class="n">value_expr</span> <span class="n">for_loop_expression</span> <span class="k">if</span> <span class="n">condition</span> <span class="p">}</span>
</pre></div>
</div>
<p>举个例子。</p>
<p>我想从一个包含所有学生成绩信息的字典中，找出数学考满分的同学。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">old_student_score_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;Jack&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;chinese&quot;</span><span class="p">:</span> <span class="mi">87</span><span class="p">,</span>
        <span class="s2">&quot;math&quot;</span><span class="p">:</span> <span class="mi">92</span><span class="p">,</span>
        <span class="s2">&quot;english&quot;</span><span class="p">:</span> <span class="mi">78</span>
    <span class="p">},</span>
    <span class="s2">&quot;Tom&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;chinese&quot;</span><span class="p">:</span> <span class="mi">92</span><span class="p">,</span>
        <span class="s2">&quot;math&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;english&quot;</span><span class="p">:</span> <span class="mi">89</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">new_student_score_info</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">scores</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">scores</span> <span class="ow">in</span> <span class="n">old_student_score_info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;math&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">}</span>
<span class="k">print</span><span class="p">(</span><span class="n">new_student_score_info</span><span class="p">)</span>
<span class="c1"># output: {&#39;Tom&#39;: {&#39;chinese&#39;: 92, &#39;math&#39;: 100, &#39;english&#39;: 89}}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. 集合推导式<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>集合推导式跟列表推导式也是类似的。
唯一的区别在于它使用大括号<code class="docutils literal notranslate"><span class="pre">{}</span></code>，组成元素也只要一个。</p>
<p>基本格式</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_set</span> <span class="o">=</span> <span class="p">{</span> <span class="n">expr</span> <span class="n">for_loop_expression</span> <span class="k">if</span> <span class="n">condition</span> <span class="p">}</span>
</pre></div>
</div>
<p>举个例子</p>
<p>我想把一个数值列表里的数进行去重处理</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">old_list</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>
<span class="go">{0, 1, 2, 3}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>4. 生成器推导式<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>生成器推导式跟列表推导式，非常的像，只是把 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 换成了 <code class="docutils literal notranslate"><span class="pre">()</span></code></p>
<ul class="simple">
<li><p>列表推导式：生成的是新的列表</p></li>
<li><p>生成器推导式：生成的是一个生成器</p></li>
</ul>
<p>直接上案例了，找出一个数值列表中所有的偶数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">old_list</span> <span class="k">if</span> <span class="n">item</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_list</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x10292df10&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>5. 嵌套推导式<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>for
循环可以有两层，甚至更多层，同样的，上面所有的推导式，其实都可以写成嵌套的多层推导式。</p>
<p>但建议最多嵌套两层，最多的话，代码就会变得非常难以理解。</p>
<p>举个例子。</p>
<p>我想打印一个乘法表，使用两个for可以这样写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}x{}={}</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>输出如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span>
<span class="mi">1</span><span class="n">x2</span><span class="o">=</span><span class="mi">2</span>   <span class="mi">2</span><span class="n">x2</span><span class="o">=</span><span class="mi">4</span>
<span class="mi">1</span><span class="n">x3</span><span class="o">=</span><span class="mi">3</span>   <span class="mi">2</span><span class="n">x3</span><span class="o">=</span><span class="mi">6</span>   <span class="mi">3</span><span class="n">x3</span><span class="o">=</span><span class="mi">9</span>
<span class="mi">1</span><span class="n">x4</span><span class="o">=</span><span class="mi">4</span>   <span class="mi">2</span><span class="n">x4</span><span class="o">=</span><span class="mi">8</span>   <span class="mi">3</span><span class="n">x4</span><span class="o">=</span><span class="mi">12</span>  <span class="mi">4</span><span class="n">x4</span><span class="o">=</span><span class="mi">16</span>
<span class="mi">1</span><span class="n">x5</span><span class="o">=</span><span class="mi">5</span>   <span class="mi">2</span><span class="n">x5</span><span class="o">=</span><span class="mi">10</span>  <span class="mi">3</span><span class="n">x5</span><span class="o">=</span><span class="mi">15</span>  <span class="mi">4</span><span class="n">x5</span><span class="o">=</span><span class="mi">20</span>  <span class="mi">5</span><span class="n">x5</span><span class="o">=</span><span class="mi">25</span>
<span class="mi">1</span><span class="n">x6</span><span class="o">=</span><span class="mi">6</span>   <span class="mi">2</span><span class="n">x6</span><span class="o">=</span><span class="mi">12</span>  <span class="mi">3</span><span class="n">x6</span><span class="o">=</span><span class="mi">18</span>  <span class="mi">4</span><span class="n">x6</span><span class="o">=</span><span class="mi">24</span>  <span class="mi">5</span><span class="n">x6</span><span class="o">=</span><span class="mi">30</span>  <span class="mi">6</span><span class="n">x6</span><span class="o">=</span><span class="mi">36</span>
<span class="mi">1</span><span class="n">x7</span><span class="o">=</span><span class="mi">7</span>   <span class="mi">2</span><span class="n">x7</span><span class="o">=</span><span class="mi">14</span>  <span class="mi">3</span><span class="n">x7</span><span class="o">=</span><span class="mi">21</span>  <span class="mi">4</span><span class="n">x7</span><span class="o">=</span><span class="mi">28</span>  <span class="mi">5</span><span class="n">x7</span><span class="o">=</span><span class="mi">35</span>  <span class="mi">6</span><span class="n">x7</span><span class="o">=</span><span class="mi">42</span>  <span class="mi">7</span><span class="n">x7</span><span class="o">=</span><span class="mi">49</span>
<span class="mi">1</span><span class="n">x8</span><span class="o">=</span><span class="mi">8</span>   <span class="mi">2</span><span class="n">x8</span><span class="o">=</span><span class="mi">16</span>  <span class="mi">3</span><span class="n">x8</span><span class="o">=</span><span class="mi">24</span>  <span class="mi">4</span><span class="n">x8</span><span class="o">=</span><span class="mi">32</span>  <span class="mi">5</span><span class="n">x8</span><span class="o">=</span><span class="mi">40</span>  <span class="mi">6</span><span class="n">x8</span><span class="o">=</span><span class="mi">48</span>  <span class="mi">7</span><span class="n">x8</span><span class="o">=</span><span class="mi">56</span>  <span class="mi">8</span><span class="n">x8</span><span class="o">=</span><span class="mi">64</span>
<span class="mi">1</span><span class="n">x9</span><span class="o">=</span><span class="mi">9</span>   <span class="mi">2</span><span class="n">x9</span><span class="o">=</span><span class="mi">18</span>  <span class="mi">3</span><span class="n">x9</span><span class="o">=</span><span class="mi">27</span>  <span class="mi">4</span><span class="n">x9</span><span class="o">=</span><span class="mi">36</span>  <span class="mi">5</span><span class="n">x9</span><span class="o">=</span><span class="mi">45</span>  <span class="mi">6</span><span class="n">x9</span><span class="o">=</span><span class="mi">54</span>  <span class="mi">7</span><span class="n">x9</span><span class="o">=</span><span class="mi">63</span>  <span class="mi">8</span><span class="n">x9</span><span class="o">=</span><span class="mi">72</span>  <span class="mi">9</span><span class="n">x9</span><span class="o">=</span><span class="mi">81</span>
</pre></div>
</div>
<p>如果使用嵌套的列表推导式，可以这么写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%2d</span><span class="s1"> *</span><span class="si">%2d</span><span class="s1"> = </span><span class="si">%2d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">*</span> <span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]))</span>
<span class="go"> 1 * 1 =  1</span>
<span class="go"> 1 * 2 =  2  2 * 2 =  4</span>
<span class="go"> 1 * 3 =  3  2 * 3 =  6  3 * 3 =  9</span>
<span class="go"> 1 * 4 =  4  2 * 4 =  8  3 * 4 = 12  4 * 4 = 16</span>
<span class="go"> 1 * 5 =  5  2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25</span>
<span class="go"> 1 * 6 =  6  2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36</span>
<span class="go"> 1 * 7 =  7  2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49</span>
<span class="go"> 1 * 8 =  8  2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64</span>
<span class="go"> 1 * 9 =  9  2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p05"></span><div class="section" id="id1">
<h2>第五章：学习函数<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c05/c05_01"></span><div class="section" id="id1">
<h3>5.1 【基础】普通函数创建与调用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>函数是一种仅在调用时运行的代码块。您可以将数据（称为参数）传递到函数中，然后由函数可以把数据作为结果返回。</p>
<p>如果将函数比喻成蛋糕店的话，那么函数的参数就是生产蛋糕的原材料，而函数的返回值就是蛋糕成品。</p>
<div class="section" id="id2">
<h4>1. 函数的创建<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在 Python 中，使用 def 关键字定义函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>def 函数名(参数):
    # 内部代码
    return 表达式
</pre></div>
</div>
<p>举个例子，我这边手动实现一个计算两个数平均值的函数，这边这样子写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    计算平均值</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>在定义函数的过程中，需要注意以下几点：</p>
<ul class="simple">
<li><p>函数代码块以<code class="docutils literal notranslate"><span class="pre">def</span></code>关键词开头，一个空格之后接函数标识符名称和圆括号()，再接个冒号。</p></li>
<li><p>任何传入的参数必须放在圆括号中间。</p></li>
<li><p>函数的第一行语句后可以选择性地使用文档字符串—用于存放函数说明。</p></li>
<li><p>函数内容以冒号起始，并且缩进。</p></li>
<li><p>使用return，返回值给调用者，并结束函数。return
关键并不是必须要加，可根据实际需要决定是否要写，若不写的话，默认返回None。</p></li>
<li><p>return语句依然在函数体内部，不能回退缩进。直到函数的所有代码写完，才回退缩进，表示函数体结束。</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>2. 函数的调用<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>函数编写出来就是给人调用的。要调用一个函数，必须使用函数名后跟圆括号的方式才能调用函数。</p>
<p>调用的同时要根据函数的定义体，提供相应个数和类型的参数，每个参数之间用逗号分隔。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    计算平均值</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="n">average</span> <span class="o">=</span> <span class="n">get_average</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">average</span><span class="p">)</span>  <span class="c1"># output: 4</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>4. 函数的返回<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>函数的返回值，可以是多种多样的，非常灵活：</p>
<ul class="simple">
<li><p>可以是任意类型的对象，比如字符串，数值，列表，字典等等</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">10</span>
</pre></div>
</div>
<ul class="simple">
<li><p>可以是一个表达式，函数会直接运行表达式，然后返回</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
<ul class="simple">
<li><p>可以是函数本身，利用这点可以实现递归调用。</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>另外还可以返回多个值</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">,</span><span class="mf">2.3</span>
</pre></div>
</div>
<ul class="simple">
<li><p>可以是其他函数，利用这点可以实现装饰器。这部分属于进阶内容，感兴趣可查看另一章节内容：<a class="reference external" href="https://python.iswbm.com/en/latest/c05/c05_06.html">5.6
精通装饰器的八种用法</a></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c05/c05_02"></span><div class="section" id="id1">
<h3>5.2. 【基础】11个案例讲解函数参数<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 参数分类<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>函数，在定义的时候，可以有参数的，也可以没有参数。</p>
<p>从函数定义的角度来看，参数可以分为两种：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">必选参数</span></code>：调用函数时必须要指定的参数，在定义时没有等号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">可选参数</span></code>：也叫<code class="docutils literal notranslate"><span class="pre">默认参数</span></code>，调用函数时可以指定也可以不指定，不指定就默认的参数值来。</p></li>
</ol>
<p>例如下面的代码中，a 和 b 属于必选参数， c 和 d 属于可选参数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>从函数调用的角度来看，参数可以分为两种：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">关键字参数</span></code>：调用时，使用 key=value
形式传参的，这样传递参数就可以不按定义顺序来。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">位置参数</span></code>：调用时，不使用关键字参数的 key-value
形式传参，这样传参要注意按照函数定义时参数的顺序来。</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">pass</span>

  <span class="c1"># 关键字参数传参方法</span>
<span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>

  <span class="c1"># 位置参数传参方法</span>
<span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>最后还有一种非常特殊的参数，叫做<code class="docutils literal notranslate"><span class="pre">可变参数</span></code>。</p>
<p>意思是参数个数可变，可以是 0
个或者任意个，但是传参时不能指定参数名，通常使用 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">**kw</span></code>
来表示：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">*args</span></code>：接收到的所有按照位置参数方式传递进来的参数，是一个元组类型</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**kw</span></code>
：接收到的所有按照关键字参数方式传递进来的参数，是一个字典类型</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

<span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>输出如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">40</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 十一个案例<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p><strong>案例一</strong>：在下面这个函数中， a 是必选参数，是必须要指定的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">()</span>  <span class="c1"># 不指定会报错</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">demo_func() missing 1 required positional argument: &#39;a&#39;</span>
</pre></div>
</div>
<p><strong>案例二</strong>：在下面这个函数中，b
是可选参数（默认参数），可以指定也可以不指定，不指定的话，默认为10</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p><strong>案例三</strong>：在下面这个函数中， name 和 age
都是必选参数，在调用指定参数时，如果不使用关键字参数方式传参，需要注意顺序</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_profile</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;我的名字叫{name}，今年{age}岁了&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_profile</span><span class="p">(</span><span class="s2">&quot;王炳明&quot;</span><span class="p">,</span> <span class="mi">27</span><span class="p">)</span>
<span class="go">&#39;我的名字叫王炳明，今年27岁了&#39;</span>
</pre></div>
</div>
<p>如果参数太多，你不想太花精力去注意顺序，可以使用关键字参数方式传参，在指定参数时附上参数名，比如这样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_profile</span><span class="p">(</span><span class="n">age</span><span class="o">=</span><span class="mi">27</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;王炳明&quot;</span><span class="p">)</span>
<span class="go">&#39;我的名字叫王炳明，今年27岁了&#39;</span>
</pre></div>
</div>
<p><strong>案例四</strong>：在下面这个函数中，<code class="docutils literal notranslate"><span class="pre">args</span></code>
参数和上面的参数名不太一样，在它前面有一个
<code class="docutils literal notranslate"><span class="pre">*</span></code>，这就表明了它是一个可变参数，可以接收任意个数的不指定参数名的参数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="go">(10, 20, 30)</span>
</pre></div>
</div>
<p><strong>案例五</strong>：在下面这个函数中，<code class="docutils literal notranslate"><span class="pre">kw</span></code> 参数和上面的 <code class="docutils literal notranslate"><span class="pre">*args</span></code>
还多了一个 <code class="docutils literal notranslate"><span class="pre">*</span></code> ，总共两个 <code class="docutils literal notranslate"><span class="pre">**</span></code> ，这个意思是 <code class="docutils literal notranslate"><span class="pre">kw</span></code>
是一个可变关键字参数，可以接收任意个数的带参数名的参数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 10, &#39;b&#39;: 20, &#39;c&#39;: 30}</span>
</pre></div>
</div>
<p><strong>案例六</strong>：在定义时，必选参数一定要在可选参数的前面，不然运行时会报错</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="gr">SyntaxError</span>: <span class="n">non-default argument follows default argument</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>案例七</strong>：在定义时，可变位置参数一定要在可变关键字参数前面，不然运行时也会报错</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                        <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>案例八</strong>：可变位置参数可以放在必选参数前面，但是在调用时，必选参数必须要指定参数名来传入，否则会报错</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">demo_func() missing 1 required keyword-only argument: &#39;b&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">(1, 2)</span>
<span class="go">100</span>
</pre></div>
</div>
<p><strong>案例九</strong>：可变关键字参数则不一样，可变关键字参数一定得放在最后，下面三个示例中，不管关键字参数后面接位置参数，还是默认参数，还是可变参数，都会报错。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
                        <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                        <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                        <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
<p><strong>案例十</strong>：将上面的知识点串起来，四种参数类型可以在一个函数中出现，但一定要注意顺序</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;arg1: &quot;</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;arg2: &quot;</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;args: &quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;kw: &quot;</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>试着调用这个函数，输出如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
<span class="go">arg1:  1</span>
<span class="go">arg2:  12</span>
<span class="go">args:  (100, 200)</span>
<span class="go">kw:  {&#39;d&#39;: 1000, &#39;e&#39;: 2000}</span>
</pre></div>
</div>
<p><strong>案例十一</strong>：使用单独的
<code class="docutils literal notranslate"><span class="pre">*</span></code>，当你在给后面的位置参数传递时，对你传参的方式有严格要求，你在传参时必须要以关键字参数的方式传参数，要写参数名，不然会报错。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">demo_func() takes 2 positional arguments but 3 were given</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. 传参的坑<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>函数参数传递的是实际对象的内存地址。如果参数是引用类型的数据类型（列表、字典等），在函数内部修改后，就算没有把修改后的值返回回去，外面的值其实也已经发生了变化。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_item</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">source_list</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_item</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">alist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c05/c05_03"></span><div class="section" id="id1">
<h3>5.3 【基础】匿名函数的使用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>匿名函数（英语：anonymous
function）是指一类无需定义标识符（函数名）的函数。通俗来说呢，就是它可以让我们的函数，可以不需要函数名。</p>
<p>正常情况下，我们定义一个函数，使用的是 <code class="docutils literal notranslate"><span class="pre">def</span></code>
关键字，而当你学会使用匿名函数后，替代 <code class="docutils literal notranslate"><span class="pre">def</span></code> 的是 <code class="docutils literal notranslate"><span class="pre">lambda</span></code>。</p>
<p>这边使用<code class="docutils literal notranslate"><span class="pre">def</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 分别举个例子，你很快就能理解。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mySum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="n">mySum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># 5</span>

<span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1"># 6</span>
</pre></div>
</div>
<p>从上面的示例，我们可以看到匿名函数直接运行，省下了很多行的代码，有没有？</p>
<p>接下来，我们的仔细看一下它的用法</p>
<p>带 if/else</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;( lambda x, y: x if x &lt; y else y )( 1, 2 )</span>
<span class="go">1</span>
</pre></div>
</div>
<p>嵌套函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;( lambda x: ( lambda y: ( lambda z: x + y + z  )( 1 ) )( 2 ) )( 3 )</span>
<span class="go">6</span>
</pre></div>
</div>
<p>递归函数</p>
<div class="highlight-pyhton notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; func = lambda n:1 if n == 0 else n * func(n-1)
&gt;&gt;&gt; func(5)
120
</pre></div>
</div>
<p>或者</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">func</span><span class="p">(</span> <span class="n">func</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
<p>从以上示例来看，lambda
表达式和常规的函数相比，写法比较怪异，可读性相对较差。除了可以直接运行之外，好像并没有其他较为突出的功能，为什么在今天我们要介绍它呢？</p>
<p>首先我们要知道 lambda
是一个表达式，而不是一个语句。正因为这个特点，我们可以在一些特殊的场景中去使用它。具体是什么场景呢？接下来我们会介绍到几个非常好用的内置函数。</p>
</div>
<span id="document-c05/c05_04"></span><div class="section" id="id1">
<h3>5.4 【基础】必学高阶函数<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="map">
<h4>1. map 函数<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p>map
函数，它接收两个参数，第一个参数是一个函数对象（当然也可以是一个lambda表达式），第二个参数是一个序列。</p>
<p>它可以实现怎样的功能呢，我举个例子你就明白了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">[2, 4, 6, 8, 10]</span>
</pre></div>
</div>
<p>可以很清楚地看到，它可以将后面序列中的每一个元素做为参数传入lambda中。</p>
<p>当我们不使用 map 函数时，你也许会这样子写。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]:</span>
    <span class="n">mylist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="filter">
<h4>2. filter 函数<a class="headerlink" href="#filter" title="Permalink to this headline">¶</a></h4>
<p>filter 函数，和 map 函数相似。同样也是接收两个参数，一个lambda
表达式，一个序列。它会遍历后面序列中每一个元素，并将其做为参数传入lambda表达式中，当表达式返回
True，则元素会被保留下来，当表达式返回 False ，则元素会被丢弃。</p>
<p>下面这个例子，将过滤出一个列表中小于0的元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;filter(lambda x: x &lt; 0, range(-5, 5))</span>
<span class="go">[-5, -4, -3, -2, -1]</span>
</pre></div>
</div>
</div>
<div class="section" id="reduce">
<h4>3. reduce 函数<a class="headerlink" href="#reduce" title="Permalink to this headline">¶</a></h4>
<p>reduce 函数，也是类似的。它的作用是先对序列中的第 1、2
个元素进行操作，得到的结果再与第三个数据用 lambda
函数运算，将其得到的结果再与第四个元素进行运算，以此类推下去直到后面没有元素了。</p>
<p><img alt="image0" src="http://image.iswbm.com/20200930175131.png" /></p>
<p>这边举个例子你也就明白了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;reduce(lambda x,y: x+y, [1,2,3,4,5])</span>
<span class="go">15</span>
</pre></div>
</div>
<p>它的运算过程分解一下是这样的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">=</span><span class="mi">3</span>
<span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="o">=</span><span class="mi">6</span>
<span class="mi">6</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span>
<span class="mi">10</span><span class="o">+</span><span class="mi">5</span><span class="o">=</span><span class="mi">15</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>4. 注意点<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>以上几个函数，熟练的掌握它们的写法，可以让我们的代码看起来更加的
Pythonic ，在某一程度上代码看起来更加的简洁。</p>
<p>如果你是新手呢，你需要注意的是，以上示例是在 Python2.x
环境下演示的。而在 Python3.x 中，却有所不同，你可以自己尝试一下。</p>
<p>这里总结一下：</p>
<p>第一点，map 和 filter
函数返回的都不再是一个列表，而是一个迭代器对象。这里以map为例</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">map_obj</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>
<span class="go">[4, 6, 8, 10]</span>
</pre></div>
</div>
<p>第二点，reduce 不可以直接调用，而是要先导入才能使用，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c05/c05_05"></span><div class="section" id="id1">
<h3>5.5 【基础】反射函数的使用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>自省，在我们日常生活中，通常是自我反省的意思。</p>
<p>但在计算机编程中，自省并不是这个意思，它的英文单词是
introspection，表示的是自我检查的行为或能力。</p>
<p>它的内容包括</p>
<ol class="arabic simple">
<li><p>告诉别人，我是谁</p></li>
<li><p>告诉别人，我能做什么</p></li>
</ol>
<p>Python
是一门动态语言，有了自省，就能让程序在运行时能够获知对象的类型以及该对象下有哪些方法等。</p>
<div class="section" id="python">
<h4>1. 学习 Python 模块的入口<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h4>
<div class="section" id="help">
<h5>help()<a class="headerlink" href="#help" title="Permalink to this headline">¶</a></h5>
<p>在 console 模式下，输入 <code class="docutils literal notranslate"><span class="pre">help()</span></code>
，可以看到输出了一段帮助文档，教你如何使用这个
help，当你看到提示符变成了 <code class="docutils literal notranslate"><span class="pre">help&gt;</span></code> 时，这时候就进入了 help 模式。</p>
<p><img alt="image0" src="http://image.iswbm.com/image-20200606121047415.png" /></p>
<p>此时你可以键入你想要了解的模块、语法等，help 告诉你如何使用。</p>
<p>比如我输入 keywords ，就可以看到 Python 里所有的关键字。再输入 modules
就可以查看 Python 中所有的内置模块。</p>
<p><img alt="image1" src="http://image.iswbm.com/image-20200606121544062.png" /></p>
<p>输入 modules + <code class="docutils literal notranslate"><span class="pre">指定包名</span></code>，就可以查看这个包下有哪些模块</p>
<p><img alt="image2" src="http://image.iswbm.com/image-20200606121942898.png" /></p>
<p>如果你想学习某个包要如何使用，可以直接在 help 模式下输入
<code class="docutils literal notranslate"><span class="pre">包名</span></code>，就像下面这样，我就可以获得一份 json 的帮助文档。</p>
<p><img alt="image3" src="http://image.iswbm.com/image-20200606122408522.png" /></p>
<p>如果你想学习某个关键字的用法，可以在 help 模式下直接键入 <code class="docutils literal notranslate"><span class="pre">关键字</span></code>
查询用法，比如我直接键入 <code class="docutils literal notranslate"><span class="pre">for</span></code> 。</p>
<p><img alt="image4" src="http://image.iswbm.com/image-20200606133933401.png" /></p>
<p>查完后，使用 quit 就可以退出 help 模式了。</p>
<p><img alt="image5" src="http://image.iswbm.com/image-20200606123145109.png" /></p>
<p>如果你觉得进入 help 模式太麻烦，可以在 console 模式下直接查询</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="s2">&quot;json&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dir">
<h5>dir()<a class="headerlink" href="#dir" title="Permalink to this headline">¶</a></h5>
<p>dir() 函数可能是 Python
自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则
dir() 返回当前作用域中的名称。让我们将 dir() 函数应用于 keyword
模块，并观察它揭示了什么：</p>
<p><img alt="image6" src="http://image.iswbm.com/image-20200606134519352.png" /></p>
</div>
</div>
<div class="section" id="id2">
<h4>2. 应用到实际开发中<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<div class="section" id="type">
<h5>type()<a class="headerlink" href="#type" title="Permalink to this headline">¶</a></h5>
<p>type()
函数有助于我们确定对象是字符串还是整数，或是其它类型的对象。它通过返回类型对象来做到这一点，可以将这个类型对象与
types 模块中定义的类型相比较：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">([])</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="hasattr">
<h5>hasattr()<a class="headerlink" href="#hasattr" title="Permalink to this headline">¶</a></h5>
<p>使用 dir() 函数会返回一个对象的属性列表。</p>
<p>但是，有时我们只想测试一个或多个属性是否存在。如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由
hasattr() 来完成.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="s2">&quot;dumps&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="getattr">
<h5>getattr()<a class="headerlink" href="#getattr" title="Permalink to this headline">¶</a></h5>
<p>使用 hasattr 获知了对象拥有某个属性后，可以搭配 getattr()
函数来获取其属性值。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="s2">&quot;__path__&quot;</span><span class="p">)</span>
<span class="go">[&#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 getattr
获取函数后，可以很方便地使用这个函数，比如下面这样，可以不再使写
json.dumps 这么字。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dumps</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="s2">&quot;dumps&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;MING&quot;</span><span class="p">})</span>
<span class="go">&#39;{&quot;name&quot;: &quot;MING&quot;}&#39;</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="go"># 当然你还有更简单的方法</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mydumps</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mydumps</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;MING&quot;</span><span class="p">})</span>
<span class="go">&#39;{&quot;name&quot;: &quot;MING&quot;}&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id">
<h5>id()<a class="headerlink" href="#id" title="Permalink to this headline">¶</a></h5>
<p><strong>id()</strong> 函数返回对象的唯一标识符，标识符是一个整数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;world&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4470767944</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4499487408</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="isinstance">
<h5>isinstance()<a class="headerlink" href="#isinstance" title="Permalink to this headline">¶</a></h5>
<p>使用 isinstance() 函数可以确定一个对象是否是某个特定类型或定制类的实例。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="s2">&quot;python&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="callable">
<h5>callable()<a class="headerlink" href="#callable" title="Permalink to this headline">¶</a></h5>
<p>使用 callable
可以确定一个对象是否是可调用的，比如函数，类这些对象都是可以调用的对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">callable</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">callable</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="modules">
<h4>3. 模块（Modules）<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h4>
<div class="section" id="doc">
<h5>__doc__<a class="headerlink" href="#doc" title="Permalink to this headline">¶</a></h5>
<p>使用 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 这个魔法方法，可以查询该模块的文档，它输出的内容和
help() 一样。</p>
<p><img alt="image7" src="http://image.iswbm.com/image-20200606134858285.png" /></p>
</div>
<div class="section" id="name">
<h5>__name__<a class="headerlink" href="#name" title="Permalink to this headline">¶</a></h5>
<p>始终是定义时的模块名；即使你使用import .. as
为它取了别名，或是赋值给了另一个变量名。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;json&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span> <span class="kn">as</span> <span class="nn">js</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;json&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="file">
<h5>__file__<a class="headerlink" href="#file" title="Permalink to this headline">¶</a></h5>
<p>包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="vm">__file__</span>
<span class="go">&#39;/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/json/__init__.py&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="dict">
<h5>__dict__<a class="headerlink" href="#dict" title="Permalink to this headline">¶</a></h5>
<p>包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。</p>
</div>
</div>
<div class="section" id="class">
<h4>4. 类（Class）<a class="headerlink" href="#class" title="Permalink to this headline">¶</a></h4>
<div class="section" id="doc-1">
<span id="id3"></span><h5>__doc__<a class="headerlink" href="#doc-1" title="Permalink to this headline">¶</a></h5>
<p>文档字符串。如果类没有文档，这个值是None。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">People</span><span class="p">:</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="sd">    people class</span>
<span class="gp">... </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">People</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

<span class="go">    people class</span>

<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="name-1">
<span id="id4"></span><h5>__name__<a class="headerlink" href="#name-1" title="Permalink to this headline">¶</a></h5>
<p>始终是定义时的类名。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">People</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;People&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="dict-1">
<span id="id5"></span><h5>__dict__<a class="headerlink" href="#dict-1" title="Permalink to this headline">¶</a></h5>
<p>包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">People</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">mappingproxy({&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: &#39;\n    people class\n    &#39;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;People&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;People&#39; objects&gt;})</span>
</pre></div>
</div>
</div>
<div class="section" id="module">
<h5>__module__<a class="headerlink" href="#module" title="Permalink to this headline">¶</a></h5>
<p>包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。</p>
<p>由于我是在 交互式命令行的环境下，所以模块是 <code class="docutils literal notranslate"><span class="pre">__main__</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">People</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
<p>如果将上面的代码放入 demo.py，并且从 people 模块导入 People 类，其值就是
people 模块</p>
<p><img alt="image8" src="http://image.iswbm.com/image-20200905115039771.png" /></p>
</div>
<div class="section" id="bases">
<h5>__bases__<a class="headerlink" href="#bases" title="Permalink to this headline">¶</a></h5>
<p>直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">People</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Teenager</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">Teenager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Student</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;__main__.Teenager&#39;&gt;,)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-c05/c05_06"></span><div class="section" id="id1">
<h3>5.6 【基础】偏函数的妙用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>假如一个函数定义了多个位置参数，那你每次调用时，都需要把这些个参数一个一个地传递进去。</p>
<p>比如下面这个函数，是用来计算 <code class="docutils literal notranslate"><span class="pre">x的n次方</span></code> 的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>那我每次计算 x 的 n 次方，都要传递两个参数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>后来我发现，我很多时候都是计算平方值，很多会去计算三次方，四次方。</p>
<p>那有什么办法可以偷个懒吗？</p>
<p>答案是，有。可以使用 <code class="docutils literal notranslate"><span class="pre">偏函数</span></code>。</p>
<p>偏函数（Partial
Function），可以将某个函数的常用参数进行固定，避免每次调用时都要指定。</p>
<p>使用偏函数，需要导入 <code class="docutils literal notranslate"><span class="pre">functools.partial</span></code>
，然后利用它创建一个新函数，新函数的 n 固定等2。</p>
<p>具体使用请看下面的示例</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_2</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_2</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
</div>
<span id="document-c05/c05_07"></span><div class="section" id="id1">
<h3>5.7 【进阶】泛型函数的使用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>根据传入参数类型的不同而调用不同的函数逻辑体，这种实现我们称之为泛型。在
Python 中叫做 <code class="docutils literal notranslate"><span class="pre">singledispatch</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">singledispatch</span></code> 是 PEP443 中引入的，如果你对此有兴趣，PEP443
应该是最好的学习文档：<a class="reference external" href="https://www.python.org/dev/peps/pep-0443/">https://www.python.org/dev/peps/pep-0443/</a></p>
<p>它使用方法极其简单，只要被<code class="docutils literal notranslate"><span class="pre">singledispatch</span></code>
装饰的函数，就是一个<code class="docutils literal notranslate"><span class="pre">single-dispatch</span></code>
的泛函数（<code class="docutils literal notranslate"><span class="pre">generic</span> <span class="pre">functions</span></code>）。</p>
<ul class="simple">
<li><p><strong>单分派</strong>：根据一个参数的类型，以不同方式执行相同的操作的行为。</p></li>
<li><p><strong>多分派</strong>：可根据多个参数的类型选择专门的函数的行为。</p></li>
<li><p><strong>泛函数</strong>：多个函数绑在一起组合成一个泛函数。</p></li>
</ul>
<p>这边举个简单的例子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">singledispatch</span>

<span class="nd">@singledispatch</span>
<span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;请传入合法类型的参数！&#39;</span><span class="p">)</span>

<span class="nd">@age.register</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;我已经{}岁了。&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">age</span><span class="p">))</span>

<span class="nd">@age.register</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;I am {} years old.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">age</span><span class="p">))</span>


<span class="n">age</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>  <span class="c1"># int</span>
<span class="n">age</span><span class="p">(</span><span class="s1">&#39;twenty three&#39;</span><span class="p">)</span>  <span class="c1"># str</span>
<span class="n">age</span><span class="p">([</span><span class="s1">&#39;23&#39;</span><span class="p">])</span>  <span class="c1"># list</span>
</pre></div>
</div>
<p>执行结果</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我已经23岁了。
I am twenty three years old.
请传入合法类型的参数！
</pre></div>
</div>
<p>说起泛型，其实在 Python 本身的一些内建函数中并不少见，比如 <code class="docutils literal notranslate"><span class="pre">len()</span></code> ，
<code class="docutils literal notranslate"><span class="pre">iter()</span></code>，<code class="docutils literal notranslate"><span class="pre">copy.copy()</span></code> ，<code class="docutils literal notranslate"><span class="pre">pprint()</span></code> 等</p>
<p>你可能会问，它有什么用呢？实际上真没什么用，你不用它或者不认识它也完全不影响你编码。</p>
<p>我这里举个例子，你可以感受一下。</p>
<p>大家都知道，Python 中有许许多的数据类型，比如 str，list， dict， tuple
等，不同数据类型的拼接方式各不相同，所以我这里我写了一个通用的函数，可以根据对应的数据类型对选择对应的拼接方式拼接，而且不同数据类型我还应该提示无法拼接。以下是简单的实现。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">check_type</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg2</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;【错误】：参数类型不同，无法拼接!!&#39;</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="nd">@singledispatch</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>

<span class="nd">@add.register</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="nd">@check_type</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">+=</span> <span class="n">new_obj</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="nd">@add.register</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="nd">@check_type</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>

<span class="nd">@add.register</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="nd">@check_type</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>

<span class="nd">@add.register</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>
<span class="nd">@check_type</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">new_obj</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span><span class="s1">&#39;, world&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;wangbm&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;age&#39;</span><span class="p">:</span><span class="mi">25</span><span class="p">}))</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">((</span><span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;huawei&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;vivo&#39;</span><span class="p">,</span> <span class="s1">&#39;oppo&#39;</span><span class="p">)))</span>

<span class="c1"># list 和 字符串 无法拼接</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;4,5,6&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>输出结果如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>hello, world
[1, 2, 3, 4, 5, 6]
{&#39;name&#39;: &#39;wangbm&#39;, &#39;age&#39;: 25}
(&#39;apple&#39;, &#39;huawei&#39;, &#39;vivo&#39;, &#39;oppo&#39;)
【错误】：参数类型不同，无法拼接!!
</pre></div>
</div>
<p>如果不使用singledispatch 的话，你可能会写出这样的代码。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">check_type</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg2</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;【错误】：参数类型不同，无法拼接!!&#39;</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@check_type</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="p">:</span>
        <span class="n">obj</span> <span class="o">+=</span> <span class="n">new_obj</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">new_obj</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span><span class="s1">&#39;, world&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;wangbm&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;age&#39;</span><span class="p">:</span><span class="mi">25</span><span class="p">}))</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">((</span><span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;huawei&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;vivo&#39;</span><span class="p">,</span> <span class="s1">&#39;oppo&#39;</span><span class="p">)))</span>

<span class="c1"># list 和 字符串 无法拼接</span>
<span class="k">print</span><span class="p">(</span><span class="n">add</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;4,5,6&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>输出如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>hello, world
[1, 2, 3, 4, 5, 6]
{&#39;name&#39;: &#39;wangbm&#39;, &#39;age&#39;: 25}
(&#39;apple&#39;, &#39;huawei&#39;, &#39;vivo&#39;, &#39;oppo&#39;)
【错误】：参数类型不同，无法拼接!!
</pre></div>
</div>
</div>
<span id="document-c05/c05_08"></span><div class="section" id="id1">
<h3>5.8 【基础】变量的作用域<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 作用域<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Python的作用域可以分为四种：</p>
<ul class="simple">
<li><p>L （Local） 局部作用域</p></li>
<li><p>E （Enclosing） 闭包函数外的函数中</p></li>
<li><p>G （Global） 全局作用域</p></li>
<li><p>B （Built-in） 内建作用域</p></li>
</ul>
<p>变量/函数 的查找顺序： L –&gt; E –&gt; G –&gt;B</p>
<p>意思是，在局部找不到的，便去局部外的局部作用域找（例如
闭包），再找不到的就去全局作业域里找，再找不到就去内建作业域中找。</p>
<p>会影响 变量/函数 作用范围的有</p>
<ul class="simple">
<li><p>函数：def 或 lambda</p></li>
<li><p>类：class</p></li>
<li><p>关键字：global noglobal</p></li>
<li><p>文件：<a href="#id3"><span class="problematic" id="id4">*</span></a>py</p></li>
<li><p>推导式：[],{},()等，仅限Py3.x中，Py2.x会出现变量泄露。</p></li>
</ul>
<p>1、赋值在前，引用在后</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ------同作用域内------</span>
<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MING&quot;</span>
<span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># ------不同作用域内------</span>
<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MING&quot;</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>2、引用在前，赋值在后（同一作用域内）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MING&quot;</span>

<span class="c1"># UnboundLocalError: local variable &#39;name&#39; referenced before assignment</span>
</pre></div>
</div>
<p>3、赋值在低层，引用在高层</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># L -&gt; E -&gt; G -&gt; B</span>
<span class="c1"># 从左到右，由低层到高层</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MING&quot;</span>

<span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># NameError: name &#39;name&#39; is not defined</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>2. 闭包<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>闭包这个概念很重要噢。你一定要掌握。</p>
<blockquote>
<div><p>在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。其实装饰函数，很多都是闭包。</p>
</div></blockquote>
<p>好像并不难理解，为什么初学者会觉得闭包难以理解呢？</p>
<p>我解释一下，你就明白了。</p>
<p>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</p>
<p>你可以看下面这段代码，就构成了闭包。在内函数里可以引用外函数的变量。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deco</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MING&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">deco</span><span class="p">()()</span>
<span class="c1"># 输出：MING</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>3. 改变作用域<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>变量的作用域，与其定义（或赋值）的位置有关，但不是绝对相关。
因为我们可以在某种程度上去改变<code class="docutils literal notranslate"><span class="pre">向上</span></code>的作用范围。</p>
<ul class="simple">
<li><p>关键字：global 将 局部变量 变为全局变量</p></li>
<li><p>关键字：nonlocal
可以在闭包函数中，引用并使用闭包外部函数的变量（非全局的噢）</p></li>
</ul>
<p>global好理解，这里只讲下nonlocal。</p>
<p>先来看个例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deco</span><span class="p">():</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">deco</span><span class="p">()()</span>
</pre></div>
</div>
<p>运行一下，会报错。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># UnboundLocalError: local variable &#39;age&#39; referenced before assignment</span>
</pre></div>
</div>
<p>但是这样就OK</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deco</span><span class="p">():</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">age</span>
        <span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">deco</span><span class="p">()()</span>
<span class="c1"># 输出：11</span>
</pre></div>
</div>
<p>其实，你如果不使用
<code class="docutils literal notranslate"><span class="pre">+=</span></code>、<code class="docutils literal notranslate"><span class="pre">-=</span></code>等一类的操作，不加nonlocal也没有关系。这就展示了闭包的特性。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deco</span><span class="p">():</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">deco</span><span class="p">()()</span>
<span class="c1"># 输出：10</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>4. 变量集合<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>在Python中，有两个内建函数，你可能用不到，但是需要掌握它们。</p>
<ul class="simple">
<li><p>globals() ：以dict的方式存储所有全局变量</p></li>
<li><p>locals()：以dict的方式存储所有局部变量</p></li>
</ul>
<p>globals()</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;I am a func&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="n">foo</span><span class="o">=</span><span class="s2">&quot;I am a string&quot;</span>
    <span class="n">foo_dup</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
    <span class="n">foo_dup</span><span class="p">()</span>

<span class="n">bar</span><span class="p">()</span>
<span class="c1"># 输出</span>
<span class="c1"># I am a func</span>
</pre></div>
</div>
<p>locals()</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">other</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span>

<span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MING&quot;</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="s2">&quot;male&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">foobar</span><span class="p">()</span>
<span class="c1"># 输出</span>
<span class="c1"># name = MING</span>
<span class="c1"># gender = male</span>
</pre></div>
</div>
<hr class="docutils" />
</div>
</div>
<span id="document-c05/c05_09"></span><div class="section" id="id1">
<h3>5.9 【进阶】上下文管理器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>当你准备从一个文件中读取内容时，通常来说，都是这么写的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>  <span class="c1"># 读取并打印</span>
<span class="go">Hello, Python</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭文件句柄</span>
</pre></div>
</div>
<p>上面这种方法，需要你手动关闭文件句柄，但是很多时候，程序员是会忘记这一操作的。</p>
<p>因为推荐你使用下面这种方法，使用 <code class="docutils literal notranslate"><span class="pre">with</span></code>
这个关键字，可以在文件读取结束后，自动关闭文件句柄。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>
</pre></div>
</div>
<p>使用 Python 的专业术语来说，<code class="docutils literal notranslate"><span class="pre">with</span></code> 的这个用法叫做
<code class="docutils literal notranslate"><span class="pre">上下文管理器</span></code>。</p>
<div class="section" id="id2">
<h4>1. 什么是上下文管理器？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p><strong>基本语法</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>with EXPR as VAR:
    代码块
</pre></div>
</div>
<p>从上面这个语法中，先理清几个概念：</p>
<ol class="arabic simple">
<li><p>上下文表达式：<code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">open('test.txt')</span> <span class="pre">as</span> <span class="pre">file:</span></code></p></li>
<li><p>上下文管理器：<code class="docutils literal notranslate"><span class="pre">open('test.txt')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">file</span></code> 不是上下文管理器，应该是资源对象。</p></li>
</ol>
</div>
<div class="section" id="id3">
<h4>2. 如何写上下文管理器？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>要手动实现一个上下文管理器，需要你有对类有一些了解，至少需要知道什么是类，怎么定义类。对于类的知识，我放在了第七章，因此你可以先前往学习下第七章的的第一节内容：<a class="reference external" href="https://python.iswbm.com/en/latest/c07/c07_01.html">7.1
类的理解与使用</a>
。</p>
<p>学习了类的基本知识，想要自己实现这样一个上下文管理，就简单了。</p>
<p>你只要在一个类里实现上下文管理协议，简单点说，就是在一个类里，定义了<code class="docutils literal notranslate"><span class="pre">__enter__</span></code>和<code class="docutils literal notranslate"><span class="pre">__exit__</span></code>的方法，这个类的实例就是一个上下文管理器。</p>
<p>例如这个示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Resource</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===connect to resource===&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===close resource connection===&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===in operation===&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Resource</span><span class="p">()</span> <span class="k">as</span> <span class="n">res</span><span class="p">:</span>
    <span class="n">res</span><span class="o">.</span><span class="n">operate</span><span class="p">()</span>
</pre></div>
</div>
<p>我们执行一下，通过日志的打印顺序。可以知道其执行过程。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">===</span><span class="n">connect</span> <span class="n">to</span> <span class="n">resource</span><span class="o">===</span>
<span class="o">===</span><span class="ow">in</span> <span class="n">operation</span><span class="o">===</span>
<span class="o">===</span><span class="n">close</span> <span class="n">resource</span> <span class="n">connection</span><span class="o">===</span>
</pre></div>
</div>
<p>从这个示例可以很明显的看出，在编写代码时，可以将资源的连接或者获取放在<code class="docutils literal notranslate"><span class="pre">__enter__</span></code>中，而将资源的关闭写在<code class="docutils literal notranslate"><span class="pre">__exit__</span></code>
中。</p>
</div>
<div class="section" id="id4">
<h4>3. 为什么需要上下文管理器？<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>学习时多问自己几个为什么，养成对一些细节的思考，有助于加深对知识点的理解。</p>
<p>为什么要使用上下文管理器？</p>
<p>在我看来，这和 Python 崇尚的优雅风格有关。</p>
<ol class="arabic simple">
<li><p>可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；</p></li>
<li><p>可以以一种更加优雅的方式，处理异常；</p></li>
</ol>
<p>第一种，我们上面已经以资源的连接为例讲过了。</p>
<p>而第二种，会被大多数人所忽略。这里会重点讲一下。</p>
<p>大家都知道，处理异常，通常都是使用 <code class="docutils literal notranslate"><span class="pre">try...execept..</span></code>
来捕获处理的。这样做一个不好的地方是，在代码的主逻辑里，会有大量的异常处理代理，这会很大的影响我们的可读性。</p>
<p>好一点的做法呢，可以使用 <code class="docutils literal notranslate"><span class="pre">with</span></code> 将异常的处理隐藏起来。</p>
<p>仍然是以上面的代码为例，我们将<code class="docutils literal notranslate"><span class="pre">1/0</span></code>
这个<code class="docutils literal notranslate"><span class="pre">一定会抛出异常的代码</span></code>写在 <code class="docutils literal notranslate"><span class="pre">operate</span></code> 里</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Resource</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===connect to resource===&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===close resource connection===&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>

<span class="k">with</span> <span class="n">Resource</span><span class="p">()</span> <span class="k">as</span> <span class="n">res</span><span class="p">:</span>
    <span class="n">res</span><span class="o">.</span><span class="n">operate</span><span class="p">()</span>
</pre></div>
</div>
<p>运行一下，惊奇地发现，居然不会报错。</p>
<p>这就是上下文管理协议的一个强大之处，异常可以在<code class="docutils literal notranslate"><span class="pre">__exit__</span></code>
进行捕获并由你自己决定如何处理，是抛出呢还是在这里就解决了。在<code class="docutils literal notranslate"><span class="pre">__exit__</span></code>
里返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>（没有return 就默认为 return False），就相当于告诉
Python解释器，这个异常我们已经捕获了，不需要再往外抛了。</p>
<p>在 写<code class="docutils literal notranslate"><span class="pre">__exit__</span></code> 函数时，需要注意的事，它必须要有这三个参数：</p>
<ul class="simple">
<li><p>exc_type：异常类型</p></li>
<li><p>exc_val：异常值</p></li>
<li><p>exc_tb：异常的错误栈信息</p></li>
</ul>
<p>当主逻辑代码没有报异常时，这三个参数将都为None。</p>
</div>
<div class="section" id="contextlib">
<h4>4. 学会使用 contextlib<a class="headerlink" href="#contextlib" title="Permalink to this headline">¶</a></h4>
<p>在上面的例子中，我们只是为了构建一个上下文管理器，却写了一个类。如果只是要实现一个简单的功能，写一个类未免有点过于繁杂。这时候，我们就想，如果只写一个函数就可以实现上下文管理器就好了。</p>
<p>这个点Python早就想到了。它给我们提供了一个装饰器，你只要按照它的代码协议来实现函数内容，就可以将这个函数对象变成一个上下文管理器。</p>
<p>我们按照 contextlib 的协议来自己实现一个打开文件（with
open）的上下文管理器。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="nd">@contextlib.contextmanager</span>
<span class="k">def</span> <span class="nf">open_func</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="c1"># __enter__方法</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;open file:&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;in __enter__&#39;</span><span class="p">)</span>
    <span class="n">file_handler</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="c1"># 【重点】：yield</span>
    <span class="k">yield</span> <span class="n">file_handler</span>

    <span class="c1"># __exit__方法</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;close file:&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;in __exit__&#39;</span><span class="p">)</span>
    <span class="n">file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span>

<span class="k">with</span> <span class="n">open_func</span><span class="p">(</span><span class="s1">&#39;/Users/MING/mytest.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_in</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_in</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>在被装饰函数里，必须是一个生成器（带有yield），而yield之前的代码，就相当于<code class="docutils literal notranslate"><span class="pre">__enter__</span></code>里的内容。yield
之后的代码，就相当于<code class="docutils literal notranslate"><span class="pre">__exit__</span></code> 里的内容。</p>
<p>上面这段代码只能实现上下文管理器的第一个目的（管理资源），并不能实现第二个目的（处理异常）。</p>
<p>如果要处理异常，可以改成下面这个样子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="nd">@contextlib.contextmanager</span>
<span class="k">def</span> <span class="nf">open_func</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="c1"># __enter__方法</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;open file:&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;in __enter__&#39;</span><span class="p">)</span>
    <span class="n">file_handler</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">file_handler</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="c1"># deal with exception</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;the exception was thrown&#39;</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;close file:&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;in __exit__&#39;</span><span class="p">)</span>
        <span class="n">file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span>

<span class="k">with</span> <span class="n">open_func</span><span class="p">(</span><span class="s1">&#39;/Users/MING/mytest.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_in</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_in</span><span class="p">:</span>
        <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>好像只要讲到上下文管理器，大多数人都会谈到打开文件这个经典的例子。</p>
<p>但是在实际开发中，可以使用到上下文管理器的例子也不少。我这边举个我自己的例子。</p>
<p>在OpenStack中，给一个虚拟机创建快照时，需要先创建一个临时文件夹，来存放这个本地快照镜像，等到本地快照镜像创建完成后，再将这个镜像上传到Glance。然后删除这个临时目录。</p>
<p>这段代码的主逻辑是<code class="docutils literal notranslate"><span class="pre">创建快照</span></code>，而<code class="docutils literal notranslate"><span class="pre">创建临时目录</span></code>，属于前置条件，<code class="docutils literal notranslate"><span class="pre">删除临时目录</span></code>，是收尾工作。</p>
<p>虽然代码量很少，逻辑也不复杂，但是“<code class="docutils literal notranslate"><span class="pre">创建临时目录，使用完后再删除临时目录</span></code>”这个功能，在一个项目中很多地方都需要用到，如果可以将这段逻辑处理写成一个工具函数作为一个上下文管理器，那代码的复用率也大大提高。</p>
<p>代码是这样的</p>
<p><img alt="image0" src="http://image.iswbm.com/20190310172800.png" /></p>
</div>
<div class="section" id="id5">
<h4>5. 总结起来<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>使用上下文管理器有三个好处：</p>
<ol class="arabic simple">
<li><p>提高代码的复用率；</p></li>
<li><p>提高代码的优雅度；</p></li>
<li><p>提高代码的可读性；</p></li>
</ol>
</div>
</div>
<span id="document-c05/c05_10"></span><div class="section" id="id1">
<h3>5.10 【进阶】装饰器的六种写法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="hello">
<h4>Hello，装饰器<a class="headerlink" href="#hello" title="Permalink to this headline">¶</a></h4>
<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。</p>
<p>它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。</p>
<p>装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
<p>装饰器的使用方法很固定</p>
<ul class="simple">
<li><p>先定义一个装饰器（帽子）</p></li>
<li><p>再定义你的业务函数或者类（人）</p></li>
<li><p>最后把这装饰器（帽子）扣在这个函数（人）头上</p></li>
</ul>
<p>就像下面这样子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义装饰器</span>
<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># 定义业务函数并进行装饰</span>
<span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">function</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello, decorator&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>实际上，装饰器并不是编码必须性，意思就是说，你不使用装饰器完全可以，它的出现，应该是使我们的代码</p>
<ul class="simple">
<li><p>更加优雅，代码结构更加清晰</p></li>
<li><p>将实现特定的功能代码封装成装饰器，提高代码复用率，增强代码可读性</p></li>
</ul>
<p>接下来，我将以实例讲解，如何编写出各种简单及复杂的装饰器。</p>
</div>
<div class="section" id="id2">
<h4>第一种：普通装饰器<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>首先咱来写一个最普通的装饰器，它实现的功能是：</p>
<ul class="simple">
<li><p>在函数执行前，先记录一行日志</p></li>
<li><p>在函数执行完，再记录一行日志</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这是装饰器函数，参数 func 是被装饰的函数</span>
<span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;我准备开始执行：{} 函数了:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="c1"># 真正执行的是这行。</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;主人，我执行完啦。&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>假如，我的业务函数是，计算两个数之和。写好后，直接给它带上帽子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@logger</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{} + {} = {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>然后执行一下 add 函数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>来看看输出了什么？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>我准备开始执行：add 函数了:
200 + 50 = 250
我执行完啦。
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>第二种：带参数的函数装饰器<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>通过上面两个简单的入门示例，你应该能体会到装饰器的工作原理了。</p>
<p>不过，装饰器的用法还远不止如此，深究下去，还大有文章。今天就一起来把这个知识点学透。</p>
<p>回过头去看看上面的例子，装饰器是不能接收参数的。其用法，只能适用于一些简单的场景。不传参的装饰器，只能对被装饰函数，执行固定逻辑。</p>
<p>装饰器本身是一个函数，做为一个函数，如果不能传参，那这个函数的功能就会很受限，只能执行固定的逻辑。这意味着，如果装饰器的逻辑代码的执行需要根据不同场景进行调整，若不能传参的话，我们就要写两个装饰器，这显然是不合理的。</p>
<p>比如我们要实现一个可以定时发送邮件的任务（一分钟发送一封），定时进行时间同步的任务（一天同步一次），就可以自己实现一个
periodic_task
（定时任务）的装饰器，这个装饰器可以接收一个时间间隔的参数，间隔多长时间执行一次任务。</p>
<p>可以这样像下面这样写，由于这个功能代码比较复杂，不利于学习，这里就不贴了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@periodic_task</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">send_mail</span><span class="p">():</span>
     <span class="k">pass</span>

<span class="nd">@periodic_task</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="mi">86400</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ntp</span><span class="p">()</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>那我们来自己创造一个伪场景，可以在装饰器里传入一个参数，指明国籍，并在函数执行前，用自己国家的母语打一个招呼。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 小明，中国人</span>
<span class="nd">@say_hello</span><span class="p">(</span><span class="s2">&quot;china&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">xiaoming</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="c1"># jack，美国人</span>
<span class="nd">@say_hello</span><span class="p">(</span><span class="s2">&quot;america&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">jack</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>那我们如果实现这个装饰器，让其可以实现 <code class="docutils literal notranslate"><span class="pre">传参</span></code> 呢？</p>
<p>会比较复杂，需要两层嵌套。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">contry</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">contry</span> <span class="o">==</span> <span class="s2">&quot;china&quot;</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;你好!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">contry</span> <span class="o">==</span> <span class="s2">&quot;america&quot;</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;hello.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># 真正执行函数的地方</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deco</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>来执行一下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xiaoming</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;------------&quot;</span><span class="p">)</span>
<span class="n">jack</span><span class="p">()</span>
</pre></div>
</div>
<p>看看输出结果。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>你好!
------------
hello.
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>第三种：不带参数的类装饰器<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>以上都是基于函数实现的装饰器，在阅读别人代码时，还可以时常发现还有基于类实现的装饰器。</p>
<p>基于类装饰器的实现，必须实现 <code class="docutils literal notranslate"><span class="pre">__call__</span></code> 和
<code class="docutils literal notranslate"><span class="pre">__init__</span></code>两个内置函数。 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> ：接收被装饰函数 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
：实现装饰逻辑。</p>
<p>还是以日志打印这个简单的例子为例</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[INFO]: the function {func}() is running...&quot;</span>\
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nd">@logger</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;say {}!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">something</span><span class="p">))</span>

<span class="n">say</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>执行一下，看看输出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[INFO]: the function say() is running...
say hello!
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>第四种：带参数的类装饰器<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>上面不带参数的例子，你发现没有，只能打印<code class="docutils literal notranslate"><span class="pre">INFO</span></code>级别的日志，正常情况下，我们还需要打印<code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>
<code class="docutils literal notranslate"><span class="pre">WARNING</span></code>等级别的日志。
这就需要给类装饰器传入参数，给这个函数指定级别了。</p>
<p>带参数和不带参数的类装饰器有很大的不同。</p>
<p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> ：不再接收被装饰函数，而是接收传入参数。 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
：接收被装饰函数，实现装饰逻辑。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span> <span class="c1"># 接受函数</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[{level}]: the function {func}() is running...&quot;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>  <span class="c1">#返回函数</span>

<span class="nd">@logger</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;WARNING&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;say {}!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">something</span><span class="p">))</span>

<span class="n">say</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们指定<code class="docutils literal notranslate"><span class="pre">WARNING</span></code>级别，运行一下，来看看输出。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[WARNING]: the function say() is running...
say hello!
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>第五种：使用偏函数与类实现装饰器<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。</p>
<p>事实上，Python 对某个对象是否能通过装饰器（
<code class="docutils literal notranslate"><span class="pre">&#64;decorator</span></code>）形式使用只有一个要求：<strong>decorator
必须是一个“可被调用（callable）的对象</strong>。</p>
<p>对于这个 callable 对象，我们最熟悉的就是函数了。</p>
<p>除函数之外，类也可以是 callable 对象，只要实现了<code class="docutils literal notranslate"><span class="pre">__call__</span></code>
函数（上面几个例子已经接触过了）。</p>
<p>还有容易被人忽略的偏函数其实也是 callable 对象。</p>
<p>接下来就来说说，如何使用 类和偏函数结合实现一个与众不同的装饰器。</p>
<p>如下所示，DelayFunc 是一个实现了 <code class="docutils literal notranslate"><span class="pre">__call__</span></code> 的类，delay
返回一个偏函数，在这里 delay 就可以做为一个装饰器。（以下代码摘自
Python工匠：使用装饰器的小技巧）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="k">class</span> <span class="nc">DelayFunc</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">duration</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Wait for {self.duration} seconds...&#39;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eager_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Call without delay&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">delay</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    装饰器：推迟某个函数的执行。</span>
<span class="sd">    同时提供 .eager_call 方法立即执行</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 此处为了避免定义额外函数，</span>
    <span class="c1"># 直接使用 functools.partial 帮助构造 DelayFunc 实例</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">DelayFunc</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>
</pre></div>
</div>
<p>我们的业务函数很简单，就是相加</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@delay</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></div>
</div>
<p>来看一下执行过程</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span>    <span class="c1"># 可见 add 变成了 Delay 的实例</span>
<span class="go">&lt;__main__.DelayFunc object at 0x107bd0be0&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 直接调用实例，进入 __call__</span>
<span class="go">Wait for 2 seconds...</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">func</span> <span class="c1"># 实现实例方法</span>
<span class="go">&lt;function add at 0x107bef1e0&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>第六种：能装饰类的装饰器<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>用 Python
写单例模式的时候，常用的有三种写法。其中一种，是用装饰器来实现的。</p>
<p>以下便是我自己写的装饰器版的单例写法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">singleton</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===== 1 ====&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cls_name</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===== 2 ====&#39;</span><span class="p">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">instances</span><span class="p">[</span><span class="n">cls_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">return</span> <span class="n">instances</span><span class="p">[</span><span class="n">cls_name</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">get_instance</span>

<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">User</span><span class="p">:</span>
    <span class="n">_instance</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;===== 3 ====&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>可以看到我们用singleton 这个装饰函数来装饰 User
这个类。装饰器用在类上，并不是很常见，但只要熟悉装饰器的实现过程，就不难以实现对类的装饰。在上面这个例子中，装饰器就只是实现对类实例的生成的控制而已。</p>
<p>其实例化的过程，你可以参考我这里的调试过程，加以理解。</p>
<p><img alt="image0" src="http://image.iswbm.com/20190512113917.png" /></p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p06"></span><div class="section" id="id1">
<h2>第六章：错误异常<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c06/c06_01"></span><div class="section" id="id1">
<h3>6.1 【基础】什么是异常？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>在程序运行过程中，总会遇到各种各样的问题和错误。</p>
<ul>
<li><p>有些错误是我们编写代码时自己造成的，比如语法错误、调用错误，甚至逻辑错误。下面这个例子，在输入
if 后输入回车了，没有按照 Python
的语法规则来，所以直接抛出了语法错误。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">if</span>
     <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
</li>
<li><p>还有一些错误，则是不可预料的错误，但是完全有可能发生的，比如文件不存在、磁盘空间不足、网络堵塞、系统错误等等。下面这个例子，使用
open 函数打开 <code class="docutils literal notranslate"><span class="pre">demo.txt</span></code>
文件，可是在当前目录下并没有这个文件，所以一定会打开失败，抛出了IOError。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;demo.txt&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IOError</span>: <span class="n">[Errno 2] No such file or directory: &#39;demo.txt&#39;</span>
</pre></div>
</div>
</li>
</ul>
<p>这些导致程序在运行过程中出现异常中断和退出的错误，我们统称为异常。正常情况下，异常都不会被程序处理，而是以错误信息的形式展现出来。</p>
<p>异常有很多种类型，Python内置了几十种常见的异常，就在builtins模块内，它们无需特别导入，就可以直接使用。需要注意的是，所有的异常都是异常类，首字母是大写的！</p>
<p>在发生异常的时候，Python会打印出异常信息，信息的前面部分显示了异常发生的上下文环境，并以调用栈的形式显示具体信息。异常类型作为信息的一部分也会被打印出来，例如ZeroDivisionError，TypeError。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">integer division or modulo by zero</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span>
</pre></div>
</div>
<p>正常情况下，我们都不需要去记住 Python
到底内置了哪些错误和异常类型，除非你需要去捕获它，关于捕获的内容，我会放在下一节。这一节先来认识一下
Python
中有哪些常见的错误和异常，对于新手，下面的内容大概过一下就好，不用深究，因为这些在你以后的编码中都会遇到的。</p>
<div class="section" id="syntaxerror">
<h4>1.SyntaxError<a class="headerlink" href="#syntaxerror" title="Permalink to this headline">¶</a></h4>
<p>SyntaxError，是语法错误，可能是新手在学习 Python 时最容易遇到的错误</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">while</span> <span class="bp">True</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span>
                   <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
<p>解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到的第一个错误。
错误是由箭头指示的位置 <em>上面</em> 的 token
引起的（或者至少是在这里被检测出的）：在示例中，在
<code class="docutils literal notranslate"><span class="pre">`print()</span></code> &lt;<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#print">https://docs.python.org/zh-cn/3/library/functions.html#print</a>&gt;`__
这个函数中检测到了错误，因为在它前面少了个冒号 (<code class="docutils literal notranslate"><span class="pre">':'</span></code>)
。文件名和行号也会被输出，以便输入来自脚本文件时你能知道去哪检查。</p>
</div>
<div class="section" id="typeerror">
<h4>2、TypeError<a class="headerlink" href="#typeerror" title="Permalink to this headline">¶</a></h4>
<p>TypeError，是类型错误，也就是说将某个操作或功能应用于不合适类型的对象时引发，比如整型与字符型进行加减法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">-</span><span class="n">b</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for -: &#39;int&#39; and &#39;str&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="indexerror">
<h4>3、IndexError<a class="headerlink" href="#indexerror" title="Permalink to this headline">¶</a></h4>
<p>IndexError，是指索引出现了错误，比如最常见下标索引超出了序列边界</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IndexError</span>: <span class="n">list index out of range</span>
</pre></div>
</div>
</div>
<div class="section" id="keyerror">
<h4>4、KeyError<a class="headerlink" href="#keyerror" title="Permalink to this headline">¶</a></h4>
<p>KeyError是关键字错误，这个异常主要发生在字典中，比如当用户试图访问一个字典中不存在的键时会被引发。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">KeyError</span>: <span class="n">&#39;age&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="valueerror">
<h4>5、ValueError<a class="headerlink" href="#valueerror" title="Permalink to this headline">¶</a></h4>
<p>ValueError为值错误，当用户传入一个调用者不期望的值时会引发，即使这个值的类型是正确的，比如想获取一个列表中某个不存在值的索引。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">invalid literal for int() with base 10: &#39;a&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="attributeerror">
<h4>6、AttributeError<a class="headerlink" href="#attributeerror" title="Permalink to this headline">¶</a></h4>
<p>AttributeError是属性错误，当用户试图访问一个对象不存在的属性时会引发。</p>
<p>比如字典有get方法，而列表却没有，所以对一个列表对象调用该方法就会引发该异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;list&#39; object has no attribute &#39;get&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="nameerror">
<h4>7、NameError<a class="headerlink" href="#nameerror" title="Permalink to this headline">¶</a></h4>
<p>NameError是指变量名称发生错误，比如用户试图调用一个还未被赋值或初始化的变量时会被触发。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NameError</span>: <span class="n">name &#39;name&#39; is not defined</span>
</pre></div>
</div>
</div>
<div class="section" id="ioerror">
<h4>8、IOError<a class="headerlink" href="#ioerror" title="Permalink to this headline">¶</a></h4>
<p>IOError 为打开文件错误，当用户试图以读取方式打开一个不存在的文件时引发。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fb</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;demo.txt&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IOError</span>: <span class="n">[Errno 2] No such file or directory: &#39;demo.txt&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="stopiteration">
<h4>9、StopIteration<a class="headerlink" href="#stopiteration" title="Permalink to this headline">¶</a></h4>
<p>StopIteration为迭代器错误，当访问至迭代器最后一个值时仍然继续访问，就会引发这种异常，提醒用户迭代器中已经没有值可供访问了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">agen</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">agen</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">agen</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">agen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
</div>
<div class="section" id="assertionerror">
<h4>10、AssertionError<a class="headerlink" href="#assertionerror" title="Permalink to this headline">¶</a></h4>
<p>AssertionError
为断言错误，当用户利用断言语句检测异常时，如果断言语句检测的表达式为假，则会引发这种异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AssertionError</span>
</pre></div>
</div>
</div>
<div class="section" id="indentationerror">
<h4>11. IndentationError<a class="headerlink" href="#indentationerror" title="Permalink to this headline">¶</a></h4>
<p>Python
是一门严格缩进的语言，如果缩进有问题，就会导致解释器解析异常，抛出
IndentationError</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
        <span class="o">^</span>
<span class="gr">IndentationError</span>: <span class="n">expected an indented block</span>
</pre></div>
</div>
</div>
<div class="section" id="importerror">
<h4>12. ImportError<a class="headerlink" href="#importerror" title="Permalink to this headline">¶</a></h4>
<p>当你在使用 import
导包的时候，如果因为包名错误或者路径不对、包未安装，都会抛出 ImportError</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oxx</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named oxx</span>
</pre></div>
</div>
<p>上面这些异常应该是平时编程中遇见频率比较高的一部分，还有更多的异常，可以前往官方文档：<a class="reference external" href="https://docs.python.org/3/library/exceptions.html">https://docs.python.org/3/library/exceptions.html</a></p>
</div>
</div>
<span id="document-c06/c06_02"></span><div class="section" id="id1">
<h3>6.2 【基础】如何抛出和捕获异常？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 如何抛出异常？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>异常的产生有两种来源：</p>
<ul class="simple">
<li><p>一种是程序自动抛出，比如 <code class="docutils literal notranslate"><span class="pre">1/0</span></code> 会自动抛出 ZeroDivisionError</p></li>
<li><p>一种是开发者主动抛出，使用 <code class="docutils literal notranslate"><span class="pre">raise</span></code> 关键字抛出。</p></li>
</ul>
<p>在 Python 中是使用 <code class="docutils literal notranslate"><span class="pre">raise</span></code>
关键字来抛出异常的，比如在下面这个函数中，如果不存在目标文件，则会抛出一个
Exception 通用异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">demo_func</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 如何捕获异常？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>出现错误或者异常没有关系，关键在于你要学会预判程序可能会出现的错误或异常，然后在代码中捕获这些异常并处理。</p>
<p>异常的捕获的语法有如下四种：</p>
<div class="section" id="id4">
<h5>第一种语法<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>只捕捉但是不想获取异常信息</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    代码A
except [EXCEPTION]:
    代码B
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>第二种语法<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>不但捕捉了还要获取异常信息，赋值给 e
后，后面你可以把异常信息打印到日志中。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    代码A
except [EXCEPTION] as e:
    代码B
</pre></div>
</div>
<p>有了上面的基础语法，可以扩展出下面三种常用的异常捕获的写法。</p>
</div>
<div class="section" id="id6">
<h5>第三种语法<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>正常使用 <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">except</span> <span class="pre">...</span></code></p>
<p>如果代码A发生了异常，则会走到代码B的逻辑。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    代码A
except [exception] as e :
    代码B
</pre></div>
</div>
<p>举个例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;发生了异常：错误信息如下: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">发生了异常：错误信息如下:</span>
<span class="go">integer division or modulo by zero</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>第四种语法<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>使用 <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">except</span> <span class="pre">...</span> <span class="pre">else</span></code></p>
<p>如果代码A发生了异常，则会走到代码B的逻辑，如果没有发生异常，则会走到代码C</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    代码A
except [exception] as e:
    代码B
else:
    代码C
</pre></div>
</div>
<p>举个例子</p>
<p>不发生异常的情况</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;发生了异常：错误信息如下: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;程序正常运行&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">2</span>
<span class="go">程序正常运行</span>
</pre></div>
</div>
<p>发生异常的情况</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;发生了异常：错误信息如下: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;程序正常运行&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">发生了异常：错误信息如下:</span>
<span class="go">integer division or modulo by zero</span>
</pre></div>
</div>
<ul class="simple">
<li><p>第三种：使用 <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">except</span> <span class="pre">...</span> <span class="pre">finally</span></code></p></li>
</ul>
<p>如果代码A发生了异常，则会走到代码B的逻辑，最后不管有没有发生异常都会走到代码C</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    代码A
except [exception] as e:
    代码B
finally:
    代码C
</pre></div>
</div>
<p>举个例子</p>
<p>发生异常的情况</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;发生了异常：错误信息如下: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">... </span><span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;程序运行结束!!&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">发生了异常：错误信息如下:</span>
<span class="go">integer division or modulo by zero</span>
<span class="go">程序运行结束!!</span>
</pre></div>
</div>
<p>不发生异常的情况</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;发生了异常：错误信息如下: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">... </span><span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;程序运行结束!!&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">2</span>
<span class="go">程序运行结束!!</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h4>3. 捕获多个异常？<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="section" id="except">
<h5>每个except捕获一个异常<a class="headerlink" href="#except" title="Permalink to this headline">¶</a></h5>
<p>一个 try 语句可能有多个 except
子句，以指定不同异常的处理程序，但是最多会执行一个处理程序。</p>
<p>当代码 A 在运行中抛出了异常时，Python
解释器会逐行运行代码，如果抛出的异常是 <code class="docutils literal notranslate"><span class="pre">exception1</span></code>
那么后面直接运行代码B，运行完 B 后，就不会再判断后面两个 except 语句了。</p>
<p>而如果不是 <code class="docutils literal notranslate"><span class="pre">exception1</span></code> ，而是 <code class="docutils literal notranslate"><span class="pre">exception2</span></code>
，那会运行代码C，而不会再运行第三个 except 语句了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    代码A
except [exception1] as e:
    代码B
except [exception2] as e:
    代码C
except [exception3] as e:
    代码D
</pre></div>
</div>
<p>举个例子吧，下面这段代码，由于 <code class="docutils literal notranslate"><span class="pre">1/0</span></code> 会抛出 <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>
错误，所以前面两个异常匹配都不成功，而在最后一个 except
成功匹配上，最终打印出 <code class="docutils literal notranslate"><span class="pre">除数不能为</span> <span class="pre">0</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;IO读写出错&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FloatingPointError</span><span class="p">:</span>
    <span class="c1"># 浮点计算错误</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;计算错误&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
    <span class="c1"># 除数不能为 0</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;计算错误&quot;</span><span class="p">)</span>
<span class="c1"># output: 计算错误</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h5>一个except捕获多个异常<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>上面的例子可以看出来，第二个异常和第三个异常是属于同一类，就是
<code class="docutils literal notranslate"><span class="pre">计算错误</span></code>，异常处理的代码是一样的，那有没有办法将它们合并在一起呢，简化一下代码呢？</p>
<p>答案是，可以的。</p>
<p>在 except
后面其实是可以接多个异常的，多个异常之间使用括号包裹。只要匹配上一个就算捕获到，就会进入相应的代码分支。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;IO读写出错&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">,</span> <span class="ne">FloatingPointError</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;计算出错&quot;</span><span class="p">)</span>
<span class="c1"># output: 计算错误</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-c06/c06_03"></span><div class="section" id="id1">
<h3>6.3 【基础】如何自定义异常？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>大多数情况下，内置的错误和异常已经够用了，但是有时候你还是需要自定义一些异常。</p>
<p>自定义异常，需要你对 <code class="docutils literal notranslate"><span class="pre">类</span></code> 与 <code class="docutils literal notranslate"><span class="pre">继承</span></code>
有一些了解，对于类的知识，我放在了第七章，因此你可以先前往学习下第七章的的下面两节内容：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://python.iswbm.com/en/latest/c07/c07_01.html">7.1
类的理解与使用</a></p></li>
<li><p><a class="reference external" href="https://python.iswbm.com/en/latest/c07/c07_05.html">7.5
类的继承（Inheritance）</a></p></li>
</ul>
<p>等学习完后再回过头来学习本节内容。</p>
<p>自定义异常应该继承 <code class="docutils literal notranslate"><span class="pre">Exception</span></code>
类，直接继承或者间接继承都可以，自定义的异常或错误类，下面使用
<code class="docutils literal notranslate"><span class="pre">InputError</span></code> ，表示接受用户输入时发生问题。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span>
</pre></div>
</div>
<p>异常的名字都以<code class="docutils literal notranslate"><span class="pre">Error</span></code>结尾，我们在为自定义异常命名的时候也需要遵守这一规范，就跟标准的异常命名一样。</p>
<p>定义完后，再看如下代码，我在 try 里调用 get_input
函数，如果发现用户没有输入内容，就使用 <code class="docutils literal notranslate"><span class="pre">raise</span></code> 关键字来抛出
<code class="docutils literal notranslate"><span class="pre">InputError</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_input</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;请输入你的姓名：&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;未输入内容&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">get_input</span><span class="p">()</span>
<span class="k">except</span> <span class="n">InputError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-c06/c06_04"></span><div class="section" id="id1">
<h3>6.4 【进阶】如何关闭异常自动关联上下文？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>当你在处理异常时，由于处理不当或者其他问题，再次抛出另一个异常时，往外抛出的异常也会携带原始的异常信息。</p>
<p>就像这样子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>从输出可以看到两个异常信息</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;demo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">division</span> <span class="n">by</span> <span class="n">zero</span>

<span class="n">During</span> <span class="n">handling</span> <span class="n">of</span> <span class="n">the</span> <span class="n">above</span> <span class="n">exception</span><span class="p">,</span> <span class="n">another</span> <span class="n">exception</span> <span class="n">occurred</span><span class="p">:</span>

<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;demo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Something</span> <span class="n">bad</span> <span class="n">happened</span>
</pre></div>
</div>
<p>如果在异常处理程序或 finally
块中引发异常，默认情况下，异常机制会隐式工作会将先前的异常附加为新异常的
<code class="docutils literal notranslate"><span class="pre">__context__</span></code>属性。这就是 Python 默认开启的自动关联异常上下文。</p>
<p>如果你想自己控制这个上下文，可以加个 from 关键字（<code class="docutils literal notranslate"><span class="pre">from</span></code>
语法会有个限制，就是第二个表达式必须是另一个异常类或实例。），来表明你的新异常是直接由哪个异常引起的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
</pre></div>
</div>
<p>输出如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;demo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">division</span> <span class="n">by</span> <span class="n">zero</span>

<span class="n">The</span> <span class="n">above</span> <span class="n">exception</span> <span class="n">was</span> <span class="n">the</span> <span class="n">direct</span> <span class="n">cause</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">exception</span><span class="p">:</span>

<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;demo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Something</span> <span class="n">bad</span> <span class="n">happened</span>
</pre></div>
</div>
<p>当然，你也可以通过<code class="docutils literal notranslate"><span class="pre">with_traceback()</span></code>方法为异常设置上下文<code class="docutils literal notranslate"><span class="pre">__context__</span></code>属性，这也能在<code class="docutils literal notranslate"><span class="pre">traceback</span></code>更好的显示异常信息。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;bad thing&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，如果我想彻底关闭这个自动关联异常上下文的机制？有什么办法呢？</p>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">raise...from</span> <span class="pre">None</span></code>，从下面的例子上看，已经没有了原始异常</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>$ cat demo.py
try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError(&quot;Something bad happened&quot;) from None
$
$ python demo.py
Traceback (most recent call last):
  File &quot;demo.py&quot;, line 4, in &lt;module&gt;
    raise RuntimeError(&quot;Something bad happened&quot;) from None
RuntimeError: Something bad happened
(PythonCodingTime)
</pre></div>
</div>
</div>
<span id="document-c06/c06_05"></span><div class="section" id="id1">
<h3>6.5 【进阶】异常处理的三个好习惯<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>本文作者：piglei</p>
<p>本文来源：<a class="reference external" href="https://github.com/piglei/one-python-craftsman">https://github.com/piglei/one-python-craftsman</a></p>
<hr class="docutils" />
<p>如果你用 Python
编程，那么你就无法避开异常，因为异常在这门语言里无处不在。打个比方，当你在脚本执行时按
<code class="docutils literal notranslate"><span class="pre">ctrl+c</span></code> 退出，解释器就会产生一个 <code class="docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code> 异常。而
<code class="docutils literal notranslate"><span class="pre">KeyError</span></code>、<code class="docutils literal notranslate"><span class="pre">ValueError</span></code>、<code class="docutils literal notranslate"><span class="pre">TypeError</span></code>
等更是日常编程里随处可见的老朋友。</p>
<p>异常处理工作由“捕获”和“抛出”两部分组成。“捕获”指的是使用
<code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">except</span></code> 包裹特定语句，妥当的完成错误流程处理。而恰当的使用
<code class="docutils literal notranslate"><span class="pre">raise</span></code> 主动“抛出”异常，更是优雅代码里必不可少的组成部分。</p>
<p>在这篇文章里，我会分享与异常处理相关的 3
个好习惯。继续阅读前，我希望你已经了解了下面这些知识点：</p>
<ul class="simple">
<li><p>异常的基本语法与用法<em>（建议阅读官方文档</em><a class="reference external" href="https://docs.python.org/3.6/tutorial/errors.html">“Errors and
Exceptions”</a><em>）</em></p></li>
<li><p>为什么要使用异常代替错误返回<em>（建议阅读*`《让函数返回结果的技巧》 &lt;https://www.zlovezl.cn/articles/function-returning-tips/&gt;`__*）</em></p></li>
<li><p>为什么在写 Python 时鼓励使用异常 <em>（建议阅读</em><a class="reference external" href="https://jeffknupp.com/blog/2013/02/06/write-cleaner-python-use-exceptions/">“Write Cleaner
Python: Use
Exceptions”</a><em>）</em></p></li>
</ul>
<div class="section" id="id2">
<h4>1. 只做最精确的异常捕获<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>假如你不够了解异常机制，就难免会对它有一种天然恐惧感。你可能会觉得：<em>异常是一种不好的东西，好的程序就应该捕获所有的异常，让一切都平平稳稳的运行。</em>而抱着这种想法写出的代码，里面通常会出现大段含糊的异常捕获逻辑。</p>
<p>让我们用一段可执行脚本作为样例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">re</span>


<span class="k">def</span> <span class="nf">save_website_title</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;获取某个地址的网页标题，然后将其写入到文件中</span>

<span class="sd">    :returns: 如果成功保存，返回 True，否则打印错误，返回 False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;title&gt;(.*)&lt;/title&gt;&#39;</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;save failed: title tag not found in page content&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">title</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">grop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;save failed: unable to save title of {url} to {filename}&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">save_website_title</span><span class="p">(</span><span class="s1">&#39;https://www.qq.com&#39;</span><span class="p">,</span> <span class="s1">&#39;qq_title.txt&#39;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>脚本里的 <code class="docutils literal notranslate"><span class="pre">save_website_title</span></code>
函数做了好几件事情。它首先通过网络获取网页内容，然后利用正则匹配出标题，最后将标题写在本地文件里。而这里有两个步骤很容易出错：<strong>网络请求</strong>
与 <strong>本地文件操作</strong>。所以在代码里，我们用一个大大的 <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">except</span></code>
语句块，将这几个步骤都包裹了起来。<strong>安全第一</strong> ⛑。</p>
<p>那么，这段看上去简洁易懂的代码，里面藏着什么问题呢？</p>
<p>如果你旁边刚好有一台安装了 Python
的电脑，那么你可以试着跑一遍上面的脚本。你会发现，上面的代码是不能成功执行的。而且你还会发现，无论你如何修改网址和目标文件的值，程序仍然会报错
<em>“save failed: unable to…”</em>。为什么呢？</p>
<p>问题就藏在这个硕大无比的 <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">except</span></code>
语句块里。假如你把眼睛贴近屏幕，非常仔细的检查这段代码。你会发现在编写函数时，我犯了一个<strong>小错误</strong>，我把获取正则匹配串的方法错打成了
<code class="docutils literal notranslate"><span class="pre">obj.grop(1)</span></code>，少了一个 ‘u’（<code class="docutils literal notranslate"><span class="pre">obj.group(1)</span></code>）。</p>
<p>但正是因为那个过于庞大、含糊的异常捕获，这个由打错方法名导致的原本该被抛出的
<code class="docutils literal notranslate"><span class="pre">AttibuteError</span></code> 却被吞噬了。从而给我们的 debug
过程增加了不必要的麻烦。</p>
<p>异常捕获的目的，不是去捕获尽可能多的异常。假如我们从一开始就坚持：<strong>只做最精准的异常捕获</strong>。那么这样的问题就根本不会发生，精准捕获包括：</p>
<ul class="simple">
<li><p>永远只捕获那些可能会抛出异常的语句块</p></li>
<li><p>尽量只捕获精确的异常类型，而不是模糊的 <code class="docutils literal notranslate"><span class="pre">Exception</span></code></p></li>
</ul>
<p>依照这个原则，我们的样例应该被改成这样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">requests.exceptions</span> <span class="kn">import</span> <span class="n">RequestException</span>


<span class="k">def</span> <span class="nf">save_website_title</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;save failed: unable to get page content: {e}&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c1"># 这段正则操作本身就是不应该抛出异常的，所以我们没必要使用 try 语句块</span>
    <span class="c1"># 假如 group 被误打成了 grop 也没关系，程序马上就会通过 AttributeError 来</span>
    <span class="c1"># 告诉我们。</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;title&gt;(.*)&lt;/title&gt;&#39;</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;save failed: title tag not found in page content&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;save failed: unable to write to file {filename}: {e}&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 别让异常破坏抽象一致性<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>大约四五年前，当时的我正在开发某移动应用的后端 API
项目。如果你也有过开发后端 API
的经验，那么你一定知道，这样的系统都需要制定一套<strong>“API
错误码规范”</strong>，来为客户端处理调用错误时提供方便。</p>
<p>一个错误码返回大概长这个样子：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// HTTP Status Code: 400</span>
<span class="c1">// Content-Type: application/json</span>
<span class="p">{</span>
    <span class="s2">&quot;code&quot;</span><span class="o">:</span> <span class="s2">&quot;UNABLE_TO_UPVOTE_YOUR_OWN_REPLY&quot;</span><span class="p">,</span>
    <span class="s2">&quot;detail&quot;</span><span class="o">:</span> <span class="s2">&quot;你不能推荐自己的回复&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在制定好错误码规范后，接下来的任务就是如何实现它。当时的项目使用了
Django 框架，而 Django
的错误页面正是使用了异常机制实现的。打个比方，如果你想让一个请求返回 404
状态码，那么只要在该请求处理过程中执行 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">Http404</span></code> 即可。</p>
<p>所以，我们很自然的从 Django
获得了灵感。首先，我们在项目内定义了错误码异常类：<code class="docutils literal notranslate"><span class="pre">APIErrorCode</span></code>。然后依据“错误码规范”，写了很多继承该类的错误码。当需要返回错误信息给用户时，只需要做一次
<code class="docutils literal notranslate"><span class="pre">raise</span></code> 就能搞定。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">UNABLE_TO_UPVOTE</span>
<span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">USER_HAS_BEEN_BANNED</span>
<span class="o">...</span> <span class="o">...</span>
</pre></div>
</div>
<p>毫无意外，所有人都很喜欢用这种方式来返回错误码。因为它用起来非常方便，无论调用栈多深，只要你想给用户返回错误码，调用
<code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">error_codes.ANY_THING</span></code> 就好。</p>
<p>随着时间推移，项目也变得越来越庞大，抛出 <code class="docutils literal notranslate"><span class="pre">APIErrorCode</span></code>
的地方也越来越多。有一天，我正准备复用一个底层图片处理函数时，突然碰到了一个问题。</p>
<p>我看到了一段让我非常纠结的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在某个处理图像的模块内部</span>
<span class="c1"># &lt;PROJECT_ROOT&gt;/util/image/processor.py</span>
<span class="k">def</span> <span class="nf">process_image</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># 说明（非项目原注释）：该异常将会被 Django 的中间件捕获，往前端返回</span>
        <span class="c1"># &quot;上传的图片格式有误&quot; 信息</span>
        <span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">INVALID_IMAGE_UPLOADED</span>
    <span class="o">...</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">process_image</span></code>
函数会尝试解析一个文件对象，如果该对象不能被作为图片正常打开，就抛出
<code class="docutils literal notranslate"><span class="pre">error_codes.INVALID_IMAGE_UPLOADED</span> <span class="pre">（APIErrorCode</span> <span class="pre">子类）</span></code>
异常，从而给调用方返回错误代码 JSON。</p>
<p>让我给你从头理理这段代码。最初编写 <code class="docutils literal notranslate"><span class="pre">process_image</span></code>
时，我虽然把它放在了 <code class="docutils literal notranslate"><span class="pre">util.image</span></code> 模块里，但当时调这个函数的地方就只有
<em>“处理用户上传图片的 POST 请求”</em> 而已。为了偷懒，我让函数直接抛出
<code class="docutils literal notranslate"><span class="pre">APIErrorCode</span></code> 异常来完成了错误处理工作。</p>
<p>再来说当时的问题。那时我需要写一个在后台运行的批处理图片脚本，而它刚好可以复用
<code class="docutils literal notranslate"><span class="pre">process_image</span></code>
函数所实现的功能。但这时不对劲的事情出现了，如果我想复用该函数，那么：</p>
<ul class="simple">
<li><p>我必须去捕获一个名为 <code class="docutils literal notranslate"><span class="pre">INVALID_IMAGE_UPLOADED</span></code> 的异常</p>
<ul>
<li><p><strong>哪怕我的图片根本就不是来自于用户上传</strong></p></li>
</ul>
</li>
<li><p>我必须引入 <code class="docutils literal notranslate"><span class="pre">APIErrorCode</span></code> 异常类作为依赖来捕获异常</p>
<ul>
<li><p><strong>哪怕我的脚本和 Django API 根本没有任何关系</strong></p></li>
</ul>
</li>
</ul>
<p><strong>这就是异常类抽象层级不一致导致的结果。</strong>APIErrorCode
异常类的意义，在于表达一种能够直接被终端用户（人）识别并消费的“错误代码”。<strong>它在整个项目里，属于最高层的抽象之一。</strong>但是出于方便，我们却在底层模块里引入并抛出了它。这打破了
<code class="docutils literal notranslate"><span class="pre">image.processor</span></code> 模块的抽象一致性，影响了它的可复用性和可维护性。</p>
<p>这类情况属于“模块抛出了<strong>高于</strong>所属抽象层级的异常”。避免这类错误需要注意以下几点：</p>
<ul class="simple">
<li><p>让模块只抛出与当前抽象层级一致的异常</p>
<ul>
<li><p>比如 <code class="docutils literal notranslate"><span class="pre">image.processer</span></code> 模块应该抛出自己封装的 <code class="docutils literal notranslate"><span class="pre">ImageOpenError</span></code>
异常</p></li>
</ul>
</li>
<li><p>在必要的地方进行异常包装与转换</p>
<ul>
<li><p>比如，应该在贴近高层抽象（视图 View 函数）的地方，将图像处理模块的
<code class="docutils literal notranslate"><span class="pre">ImageOpenError</span></code> 低级异常包装转换为 <code class="docutils literal notranslate"><span class="pre">APIErrorCode</span></code> 高级异常</p></li>
</ul>
</li>
</ul>
<p>修改后的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># &lt;PROJECT_ROOT&gt;/util/image/processor.py</span>
<span class="k">class</span> <span class="nc">ImageOpenError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">process_image</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ImageOpenError</span><span class="p">(</span><span class="n">exc</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
    <span class="o">...</span> <span class="o">...</span>

<span class="c1"># &lt;PROJECT_ROOT&gt;/app/views.py</span>
<span class="k">def</span> <span class="nf">foo_view_function</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">process_image</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">ImageOpenError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">INVALID_IMAGE_UPLOADED</span>
</pre></div>
</div>
<p>除了应该避免抛出<strong>高于</strong>当前抽象级别的异常外，我们同样应该避免泄露<strong>低于</strong>当前抽象级别的异常。</p>
<p>如果你用过 <code class="docutils literal notranslate"><span class="pre">requests</span></code>
模块，你可能已经发现它请求页面出错时所抛出的异常，并不是它在底层所使用的
<code class="docutils literal notranslate"><span class="pre">urllib3</span></code> 模块的原始异常，而是通过 <code class="docutils literal notranslate"><span class="pre">requests.exceptions</span></code>
包装过一次的异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;https://www.invalid-host-foo.com&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;class &#39;requests.exceptions.ConnectionError&#39;&gt;</span>
</pre></div>
</div>
<p>这样做同样是为了保证异常类的抽象一致性。因为 urllib3 模块是 requests
模块依赖的底层实现细节，而这个细节有可能在未来版本发生变动。所以必须对它抛出的异常进行恰当的包装，避免未来的底层变更对
<code class="docutils literal notranslate"><span class="pre">requests</span></code> 用户端错误处理逻辑产生影响。</p>
</div>
<div class="section" id="id4">
<h4>3. 异常处理不应该喧宾夺主<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>在前面我们提到异常捕获要精准、抽象级别要一致。但在现实世界中，如果你严格遵循这些流程，那么很有可能会碰上另外一个问题：<strong>异常处理逻辑太多，以至于扰乱了代码核心逻辑</strong>。具体表现就是，代码里充斥着大量的
<code class="docutils literal notranslate"><span class="pre">try</span></code>、<code class="docutils literal notranslate"><span class="pre">except</span></code>、<code class="docutils literal notranslate"><span class="pre">raise</span></code> 语句，让核心逻辑变得难以辨识。</p>
<p>让我们看一段例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">upload_avatar</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;用户上传新头像&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">avatar_file</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">FILES</span><span class="p">[</span><span class="s1">&#39;avatar&#39;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">AVATAR_FILE_NOT_PROVIDED</span>

    <span class="k">try</span><span class="p">:</span>
       <span class="n">resized_avatar_file</span> <span class="o">=</span> <span class="n">resize_avatar</span><span class="p">(</span><span class="n">avatar_file</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">FileTooLargeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">AVATAR_FILE_TOO_LARGE</span>
    <span class="k">except</span> <span class="n">ResizeAvatarError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">AVATAR_FILE_INVALID</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">avatar</span> <span class="o">=</span> <span class="n">resized_avatar_file</span>
        <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error_codes</span><span class="o">.</span><span class="n">INTERNAL_SERVER_ERROR</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">({})</span>
</pre></div>
</div>
<p>这是一个处理用户上传头像的视图函数。这个函数内做了三件事情，并且针对每件事都做了异常捕获。如果做某件事时发生了异常，就返回对用户友好的错误到前端。</p>
<p>这样的处理流程纵然合理，但是显然代码里的异常处理逻辑有点“喧宾夺主”了。一眼看过去全是代码缩进，很难提炼出代码的核心逻辑。</p>
<p>早在 2.5 版本时，Python
语言就已经提供了对付这类场景的工具：“上下文管理器（context
manager）”。上下文管理器是一种配合 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句使用的特殊 Python
对象，通过它，可以让异常处理工作变得更方便。</p>
<p>那么，如何利用上下文管理器来改善我们的异常处理流程呢？让我们直接看代码吧。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">raise_api_error</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;captures specified exception and raise ApiErrorCode instead</span>

<span class="sd">    :raises: AttributeError if code_name is not valid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">captures</span><span class="p">,</span> <span class="n">code_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">captures</span> <span class="o">=</span> <span class="n">captures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">error_codes</span><span class="p">,</span> <span class="n">code_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 该方法将在进入上下文时调用</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="c1"># 该方法将在退出上下文时调用</span>
        <span class="c1"># exc_type, exc_val, exc_tb 分别表示该上下文内抛出的</span>
        <span class="c1"># 异常类型、异常值、错误栈</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">exc_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">captures</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="kn">from</span> <span class="nn">exc_val</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>在上面的代码里，我们定义了一个名为 <code class="docutils literal notranslate"><span class="pre">raise_api_error</span></code>
的上下文管理器，它在进入上下文时什么也不做。但是在退出上下文时，会判断当前上下文中是否抛出了类型为
<code class="docutils literal notranslate"><span class="pre">self.captures</span></code> 的异常，如果有，就用 <code class="docutils literal notranslate"><span class="pre">APIErrorCode</span></code> 异常类替代它。</p>
<p>使用该上下文管理器后，整个函数可以变得更清晰简洁：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">upload_avatar</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;用户上传新头像&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">raise_api_error</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="s1">&#39;AVATAR_FILE_NOT_PROVIDED&#39;</span><span class="p">):</span>
        <span class="n">avatar_file</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">FILES</span><span class="p">[</span><span class="s1">&#39;avatar&#39;</span><span class="p">]</span>

    <span class="k">with</span> <span class="n">raise_api_error</span><span class="p">(</span><span class="n">ResizeAvatarError</span><span class="p">,</span> <span class="s1">&#39;AVATAR_FILE_INVALID&#39;</span><span class="p">),</span>\
            <span class="n">raise_api_error</span><span class="p">(</span><span class="n">FileTooLargeError</span><span class="p">,</span> <span class="s1">&#39;AVATAR_FILE_TOO_LARGE&#39;</span><span class="p">):</span>
        <span class="n">resized_avatar_file</span> <span class="o">=</span> <span class="n">resize_avatar</span><span class="p">(</span><span class="n">avatar_file</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">raise_api_error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="s1">&#39;INTERNAL_SERVER_ERROR&#39;</span><span class="p">):</span>
        <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">avatar</span> <span class="o">=</span> <span class="n">resized_avatar_file</span>
        <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">({})</span>
</pre></div>
</div>
<blockquote>
<div><p>Hint：建议阅读 <a class="reference external" href="https://www.python.org/dev/peps/pep-0343/">PEP 343 – The “with” Statement |
Python.org</a>，了解与上下文管理器有关的更多知识。</p>
<p>模块
<a class="reference external" href="https://docs.python.org/3/library/contextlib.html">contextlib</a>
也提供了非常多与编写上下文管理器相关的工具函数与样例。</p>
</div></blockquote>
</div>
<div class="section" id="id5">
<h4>总结一下<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>在这篇文章中，我分享了与异常处理相关的三个建议。最后再总结一下要点：</p>
<ul class="simple">
<li><p>只捕获可能会抛出异常的语句，避免含糊的捕获逻辑</p></li>
<li><p>保持模块异常类的抽象一致性，必要时对底层异常类进行包装</p></li>
<li><p>使用“上下文管理器”可以简化重复的异常处理逻辑</p></li>
</ul>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p07"></span><div class="section" id="id1">
<h2>第七章：类与对象<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c07/c07_01"></span><div class="section" id="id1">
<h3>7.1 【基础】类的理解与使用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 通俗理解类<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>类（英文名
class），是具有相同特性（属性）和行为（方法）的对象（实例）的抽象模板。</p>
<p>从定义上来理解类，是一件非常吃力的事情，特别是对那些没有任何基础的初学者。</p>
<p>下面我举例来说明类中一些关键术语都是什么意思：</p>
<ul class="simple">
<li><p>类：动物属于一个类，植物属于一个类</p></li>
<li><p>实例：猫和狗都属于同一类，就是动物类，那么猫和狗是动物类的实例/对象。</p></li>
<li><p>属性：类中所有的变量，都叫做属性。</p></li>
<li><p>方法：类中的所有函数，都叫做方法。</p></li>
</ul>
<p>类与对象的关系就如模具和铸件的关系，类的实例化的结果就是对象，而对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为（方法）的对象。</p>
</div>
<div class="section" id="id3">
<h4>2. 如何定义类？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>定义一个类，使用的是 class 关键字</p>
<p>下边我定义了一个 Animal 的类</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{self.name} 跑起来了&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>其中</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Animal</span></code> 是类名</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> 是构造函数，用于实例的初始化</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.name</span></code> 是实例属性，<code class="docutils literal notranslate"><span class="pre">age</span></code> 是类属性</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run</span></code> 是方法，第一个参数 self 是什么意思呢？这个咱后面再讲。</p></li>
</ul>
<p>除了上面这种写法外</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 第一种写法</span>
<span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>还有另外两种写法，与之是等价的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 第二种写法</span>
<span class="k">class</span> <span class="nc">Animal</span><span class="p">():</span>
  <span class="o">...</span>

<span class="c1"># 第二种写法</span>
<span class="k">class</span> <span class="nc">Animal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>因为在 Python 3 中，无论你是否显示继承自 object，Python
解释器都会默认你继承 object ，这是新式类的写法，与之对应的是 Python 2
的经典类写法（Python 2 已经远去，无需要再了解经典类写法）。</p>
</div>
<div class="section" id="id4">
<h4>3. 如何实例化？<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>定义了类之后，就可以通过下边的写法实例化它，并访问属性，调用方法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{self.name} 跑起来了&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>  <span class="c1"># 实例化出 dog 对象</span>
</pre></div>
</div>
<p>在实例化时传入的参数 <code class="docutils literal notranslate"><span class="pre">name=&quot;小黑&quot;</span></code> 传进入到构造函数 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
中，最终赋值 <code class="docutils literal notranslate"><span class="pre">self.name</span></code> 成为实例的属性。</p>
</div>
<div class="section" id="id5">
<h4>4. 方法的调用<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>实例化成对象后，如果访问实例属性，可以用 <code class="docutils literal notranslate"><span class="pre">对象.属性名</span></code> 进行访问。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># 访问属性</span>
<span class="go">&#39;小黑&#39;</span>
</pre></div>
</div>
<p>如果要调用方法，有两种方法</p>
<ol class="arabic simple">
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">对象.方法名</span></code>：使用这种方法，在定义方法时 self
就代表对象（dog），调用时无需再传入了。</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># 调用方法</span>
<span class="go">小黑 跑起来了</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">类.方法名</span></code>：使用这种方法，self 参数要传入实例对象</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Animal</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">dog</span><span class="p">)</span>
<span class="go">小黑 跑起来了</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c07/c07_02"></span><div class="section" id="id1">
<h3>7.2 【基础】静态方法与类方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 写法上的差异<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>类的方法可以分为：</p>
<ol class="arabic simple">
<li><p>静态方法：有 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> 装饰的函数</p></li>
<li><p>类方法：有 <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> 装饰的函数</p></li>
<li><p>实例方法：没有任何装饰器的普通函数</p></li>
</ol>
<p>举个例子，如下这段代码中，<code class="docutils literal notranslate"><span class="pre">run</span></code> 普通的实例方法，<code class="docutils literal notranslate"><span class="pre">eat</span></code>
是静态方法，<code class="docutils literal notranslate"><span class="pre">jump</span></code> 是类方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{self.name}跑起来啦&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;正在吃饭...&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{name}跳起来啦&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这三种方法，在写法有很大的区别：</p>
<p>1、普通的实例方法，在定义时，他的第一个方法固定是
self，如果是从实例调用，那么 self 参数
不需要传入，如果是通过类调用，那么 self 要传入已经实例化的对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">小黑跑起来啦</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Animal</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">dog</span><span class="p">)</span>
<span class="go">小黑跑起来啦</span>
</pre></div>
</div>
<p>2、静态方法，在定义时，不需要 self 参数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
<span class="go">正在吃饭...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Animal</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
<span class="go">正在吃饭...</span>
</pre></div>
</div>
<p>3、类方法，在定义时，第一个参数固定是 cls，为 class
的简写，代表类本身。不管是通过实例还是类调用类方法，都不需要传入 cls
的参数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">=</span><span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dog</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="go">小黑跳起来啦</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Animal</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="s2">&quot;小黑&quot;</span><span class="p">)</span>
<span class="go">小黑跳起来啦</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 方法与函数区别<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>在前面，我们很经常提到方法和函数，为免有同学将他们混为一谈，我这里总结一下他们的区别。</p>
<p>在 Python 3.x 中，</p>
<ol class="arabic simple">
<li><p>普通函数（未定位在类里）和静态方法，都是函数（<code class="docutils literal notranslate"><span class="pre">function</span></code> ）。</p></li>
<li><p>实例方法（&#64;staticmethod）和类方法，都是方法（<code class="docutils literal notranslate"><span class="pre">method</span></code> ）。</p></li>
</ol>
<p>这些结论其实都可以使用 <code class="docutils literal notranslate"><span class="pre">type</span></code> 函数得到验证。</p>
<p>先准备如下代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{self.name}跑起来啦&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;正在吃饭...&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{name}跳起来啦&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>然后进入 Python Console 模式</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">demo_func</span><span class="p">)</span>  <span class="c1"># 普通函数</span>
<span class="go">&lt;class &#39;function&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">dog</span><span class="o">.</span><span class="n">eat</span><span class="p">)</span>   <span class="c1"># 静态方法</span>
<span class="go">&lt;class &#39;function&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">dog</span><span class="o">.</span><span class="n">run</span><span class="p">)</span>  <span class="c1"># 实例方法</span>
<span class="go">&lt;class &#39;method&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">dog</span><span class="o">.</span><span class="n">jump</span><span class="p">)</span>  <span class="c1"># 类方法</span>
<span class="go">&lt;class &#39;method&#39;&gt;</span>
</pre></div>
</div>
<p>到这里，你应该会有疑问了吧？</p>
<p>类方法和实例方法，名字本身就有方法，也是方法也说得过去。那静态方法呢，为什么不是方法而是函数呢？</p>
<p>对此，我的理解是：方法是一种和对象（实例或者类）绑定后的特殊函数。</p>
<p>方法本质上还是函数，不同之处在于它与对象进行绑定。</p>
</div>
</div>
<span id="document-c07/c07_03"></span><div class="section" id="id1">
<h3>7.3 【基础】私有变量与私有方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 下划线妙用<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在 Python 中，下划线可是非常推荐使用的符号：</p>
<ol class="arabic simple">
<li><p>变量名推荐使用下划线分隔的蛇形命名法</p></li>
<li><p>魔法方法、构造函数都需要使用双下划线</p></li>
<li><p>对于暂时用不到的变量值，可以赋值给单下划线 <code class="docutils literal notranslate"><span class="pre">_</span></code> 进行占位</p></li>
</ol>
<p>根据分类，我把下划线写法分成下面五种：</p>
<ul class="simple">
<li><p>单前导下划线：<code class="docutils literal notranslate"><span class="pre">_var</span></code></p></li>
<li><p>单末尾下划线：<code class="docutils literal notranslate"><span class="pre">var_</span></code></p></li>
<li><p>双前导下划线：<code class="docutils literal notranslate"><span class="pre">__var</span></code></p></li>
<li><p>双前导和末尾下划线：<code class="docutils literal notranslate"><span class="pre">__var__</span></code></p></li>
<li><p>单下划线：<code class="docutils literal notranslate"><span class="pre">_</span></code></p></li>
</ul>
<p>由于篇幅所限，本篇将只介绍跟标题（私有变量与私有方法）有关的用法，也就是访问控制。</p>
<p>上面五种写法中，涉及到访问控制的有：<code class="docutils literal notranslate"><span class="pre">_var</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__var</span></code></p>
</div>
<div class="section" id="var">
<h4>2. 单前导下划线 _var<a class="headerlink" href="#var" title="Permalink to this headline">¶</a></h4>
<p>下划线前缀的含义是告知其他程序员：<strong>以单个下划线开头的变量或方法仅供内部使用</strong>。</p>
<p>请看下面这个例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Demo</span><span class="p">:</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">11</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_bar</span> <span class="o">=</span> <span class="mi">22</span>
</pre></div>
</div>
<p>如果你实例化此类，然后分别访问 <code class="docutils literal notranslate"><span class="pre">self.foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">self._bar</span></code>
会发生什么情况？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span> <span class="o">=</span> <span class="n">Demo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">foo</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">_bar</span>
<span class="go">22</span>
</pre></div>
</div>
<p>结果是：外界都可以直接访问这两个属性。</p>
<p>但实际上，二者是有区别的。PEP 8
有提及，如果一个属性的有单前导下划线，则该属性应该仅供内部访问。</p>
<p>但这并不是强制性的，不然上面我们也不可能通过 <code class="docutils literal notranslate"><span class="pre">self._bar</span></code> 访问到
22，但做为一名 Python 程序员最好遵守这一共识。</p>
</div>
<div class="section" id="id3">
<h4>3. 双前导下划线 __var<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p>
<p>这也叫做<strong>名称修饰(name mangling)</strong> -
解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p>
<p>我知道这听起来很抽象。因此，我组合了一个小小的代码示例来予以说明：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Demo</span><span class="p">:</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">11</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_bar</span> <span class="o">=</span> <span class="mi">22</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">__baz</span> <span class="o">=</span> <span class="mi">33</span>
</pre></div>
</div>
<p>将其进行实例化，然后使用 <code class="docutils literal notranslate"><span class="pre">dir()</span></code> 函数查看这个对象的属性</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span> <span class="o">=</span> <span class="n">Demo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">demo</span><span class="p">)</span>
<span class="go">[&#39;_Demo__baz&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_bar&#39;, &#39;foo&#39;]</span>
</pre></div>
</div>
<p>不难发现，<code class="docutils literal notranslate"><span class="pre">foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">_bar</span></code> 都很正常，可以使用 <code class="docutils literal notranslate"><span class="pre">demo.属性名</span></code>
进行访问。</p>
<p>但 <code class="docutils literal notranslate"><span class="pre">__baz</span></code> 明显和 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 、 <code class="docutils literal notranslate"><span class="pre">_bar</span></code> 不一样，尝试访问后却报了
AttributeError，属性不存在。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">__baz</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;Demo&#39; object has no attribute &#39;__baz&#39;</span>
</pre></div>
</div>
<p>如果你仔细观察，你会看到此对象上有一个名为<code class="docutils literal notranslate"><span class="pre">_Demo__baz</span></code>的属性。这就是Python解释器所做的名称修饰。它这样做是为了防止变量在子类中被重写。</p>
<p>如果想访问，那得按照 dir 提示的写法去访问，在 <code class="docutils literal notranslate"><span class="pre">__baz</span></code> 前面加上
<code class="docutils literal notranslate"><span class="pre">_类名</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">_Demo__baz</span>
<span class="go">23</span>
</pre></div>
</div>
<p>总结可得，使用双下划线开头的属性变量，就是一个私有变量。</p>
<p>这样的规则在属性上生效，在方法上也同样适用。</p>
<p>如果一个实例方法，以双下划线开头，那么这个方法就是一个私有的方法，不能由实例对象或者类直接调用。</p>
<p>必须得通过 <code class="docutils literal notranslate"><span class="pre">实例._类名__方法名</span></code> 来调用。</p>
</div>
<div class="section" id="id4">
<h4>4. 总结一下<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Python并没有真正的私有化支持，但可用下划线得到伪私有。</p>
<p>尽量避免定义以下划线开头的变量。</p>
<ul class="simple">
<li><p>私有变量：以双下划线前导的变量，可以使用 <code class="docutils literal notranslate"><span class="pre">实例._类名__变量名</span></code>
进行访问</p></li>
<li><p>私有方法：以双下划线前导的方法，可以使用 <code class="docutils literal notranslate"><span class="pre">实例._类名__方法名()</span></code>
进行访问</p></li>
</ul>
<p>私有变量和私有方法，虽然有办法访问，但是仍然不建议使用上面给出的方法直接访问，而应该接口统一的接口（函数入口）来对私有变量进行查看、变量，对私有方法进行调用。对于这些内容我放到了下一节的的封装，请继续往后学习。</p>
</div>
</div>
<span id="document-c07/c07_04"></span><div class="section" id="encapsulation">
<h3>7.4 【基础】类的封装（Encapsulation）<a class="headerlink" href="#encapsulation" title="Permalink to this headline">¶</a></h3>
<p>封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过任何形式修改对象内部实现。</p>
<p>要了解封装，离不开“私有化”，就是将类或者是函数中的某些属性限制在某个区域之内，外部无法直接调用。</p>
<p>关于什么是 <code class="docutils literal notranslate"><span class="pre">私有化变量和私有化函数</span></code>，在上一节我已经很详细的讲过啦。</p>
<p>私有变量和私有方法，虽然有办法访问，但是仍然不建议使用上面给出的方法直接访问，而应该接口统一的接口（函数入口）来对私有变量进行查看、变量，对私有方法进行调用。这就是封装。</p>
<p>正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。类通过将函数和变量封装在内部，实现了比函数更高一级的封装。</p>
<p>请看下面这段代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

<span class="n">xh</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小红&quot;</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="k">if</span> <span class="n">xh</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{xh.name}已经是成年人了&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{xh.name}还是未年人&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>我定义了一个 Person 的类，它有 name 和 age 两个属性。</p>
<p>如果想判断小明是不是成年人，需要使用 <code class="docutils literal notranslate"><span class="pre">xh.age</span></code> 来与 18 比较。</p>
<p>对于很多女生还来说，年龄是非常隐私的。如果不想年龄被人随意就获取，可以在
<code class="docutils literal notranslate"><span class="pre">age</span></code>
前加两个下划线，将其变成一个私有变量。外界就无法随随便便就知道某个人年龄啦。</p>
<p>如此一来，想要知道一个人是否是成年人，该怎么办呢？</p>
<p>这时候，就该 <code class="docutils literal notranslate"><span class="pre">封装</span></code> 出场啦。</p>
<p>我可以定义一个用于专门判断一个人是否成年人的函数，对 <code class="docutils literal notranslate"><span class="pre">self.__age</span></code>
这个属性进行封装。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__age</span> <span class="o">=</span> <span class="n">age</span>

    <span class="k">def</span> <span class="nf">is_adult</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__age</span> <span class="o">&gt;=</span> <span class="mi">18</span>

<span class="n">xh</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小红&quot;</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">xh</span><span class="o">.</span><span class="n">is_adult</span><span class="p">()</span>
</pre></div>
</div>
</div>
<span id="document-c07/c07_05"></span><div class="section" id="inheritance">
<h3>7.5 【基础】类的继承（Inheritance）<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h3>
<p>类的继承，跟人类繁衍的关系相似。</p>
<p>被继承的类称为基类（也叫做父类），继承而得的类叫派生类（也叫子类），这种关系就像人类的父子关系。</p>
<p>继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。</p>
<p>继承的语法结构是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>class 子类(父类):
</pre></div>
</div>
<div class="section" id="id1">
<h4>1. 单继承<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>举个例子：下面的代码中。先是定义了一个 People 类，里面有一个 speak
方法。然后再定义一个 Student 类，并继承自 People 类。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 父类定义</span>
<span class="k">class</span> <span class="nc">People</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{self.name} 说: 我{self.age}岁。&quot;</span><span class="p">)</span>

<span class="c1"># 单继承示例</span>
<span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">People</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">grade</span><span class="p">):</span>
        <span class="c1"># 调用父类的实例化方法</span>
        <span class="n">People</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grade</span> <span class="o">=</span> <span class="n">grade</span>
</pre></div>
</div>
<p>由于继承的机制，Student 实例会拥有 People
类所有属性和方法，比如下边我可以直接调用 People 类的 speak 方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xm</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小明&quot;</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">grade</span><span class="o">=</span><span class="s2">&quot;三年级&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xm</span><span class="o">.</span><span class="n">speak</span><span class="p">()</span>
<span class="go">小明 说: 我 10 岁。</span>
</pre></div>
</div>
<p>你如果不想使用父类的方法，你可以重写它以覆盖父类的 <code class="docutils literal notranslate"><span class="pre">speak</span></code> 方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 单继承示例</span>
<span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">People</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">grade</span><span class="p">):</span>
        <span class="c1"># 调用父类的实例化方法</span>
        <span class="n">People</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grade</span> <span class="o">=</span> <span class="n">grade</span>

    <span class="c1"># 重写父类的speak方法</span>
    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{self.name} 说: 我{self.age}岁了，我在读{self.grade}&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>此时，再调用的话，就会调用自己的方法了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xm</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小明&quot;</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">grade</span><span class="o">=</span><span class="s2">&quot;三年级&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xm</span><span class="o">.</span><span class="n">speak</span><span class="p">()</span>
<span class="go">小明 说: 我10岁了，我在读三年级</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 多继承<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Python 还支持多继承，可以继承自多个类。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>class 子类(父类1, 父类2, 父类3...):
</pre></div>
</div>
<p>多继承的话，情况会比单继承复杂得多。</p>
<p>假设多个父类都有一个 foo 方法，并且子类没有重写 foo 方法，那么 子类
的实例在调用 foo 方法时，应该使用哪个父类的 foo 方法呢？</p>
<p>关于这一点，只要简单的做个验证就行啦。</p>
<p>有如下代码，定义了 7 个类</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">:</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">D</span><span class="p">):</span><span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;i am B&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">G</span><span class="p">:</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">F</span><span class="p">(</span><span class="n">G</span><span class="p">):</span><span class="k">pass</span>

<span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;i am E&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span><span class="k">pass</span>
</pre></div>
</div>
<p>它们的继承关系是</p>
<p><img alt="image0" src="http://image.iswbm.com/image-20201213150058921.png" /></p>
<p>运行后的结果如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">i am B</span>
</pre></div>
</div>
<p>在类A中，没有show()这个方法，于是它只能去它的父类里查找，它首先在B类中找，结果找到了，于是直接执行B类的show()方法。可见，在A的定义中，继承参数的书写有先后顺序，写在前面的被优先继承。</p>
</div>
<div class="section" id="id3">
<h4>3. 继承顺序<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>那如果B没有show方法，而是D有呢？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;i am D&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">D</span><span class="p">):</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">C</span><span class="p">):</span><span class="k">pass</span>


<span class="k">class</span> <span class="nc">G</span><span class="p">:</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">F</span><span class="p">(</span><span class="n">G</span><span class="p">):</span><span class="k">pass</span>

<span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;i am E&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span><span class="k">pass</span>
</pre></div>
</div>
<p>执行结果是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">i am D</span>
</pre></div>
</div>
<p>由此可见，多继承的顺序使用的是从左向右再深度优先的原则。</p>
<p><img alt="image1" src="http://image.iswbm.com/image-20201213151434342.png" /></p>
</div>
<div class="section" id="mro">
<h4>4. MRO 算法<a class="headerlink" href="#mro" title="Permalink to this headline">¶</a></h4>
<p>上面的继承案例是只是非常简单的一种场景，在实际应用中，会远比这个来得复杂。</p>
<p>此时如果你单纯的将其理解成</p>
<ul class="simple">
<li><p>从左向右</p></li>
<li><p>深度优先</p></li>
</ul>
<p>就会发现很场景下想要理清的方法解析顺序（MRO）是非常难的。</p>
<p>在这种情况下，你还可以有两种方法：</p>
<ol class="arabic simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">__mro__</span></code> 来查询</p></li>
<li><p>使用 merge算法进行推导</p></li>
</ol>
<div class="section" id="id4">
<h5>使用 mro 查询<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>比如在下面这个菱形继承中</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">):</span><span class="k">pass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span><span class="k">pass</span>
</pre></div>
</div>
<p><img alt="image2" src="http://image.iswbm.com/20201004123106.png" /></p>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">__mro__</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span>
</pre></div>
</div>
<p>或者借助 inspect 模块</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmro</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</pre></div>
</div>
<p>得到的结果都将是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>(&lt;class &#39;__main__.D&#39;&gt;,
 &lt;class &#39;__main__.B&#39;&gt;,
 &lt;class &#39;__main__.C&#39;&gt;,
 &lt;class &#39;__main__.A&#39;&gt;,
 &lt;class &#39;object&#39;&gt;)
</pre></div>
</div>
</div>
<div class="section" id="merge">
<h5>使用 merge 推导<a class="headerlink" href="#merge" title="Permalink to this headline">¶</a></h5>
<p><img alt="image3" src="http://image.iswbm.com/20201004123115.png" /></p>
<ol class="arabic simple">
<li><p>检查第一个列表的头元素（如 L[B1] 的头），记作 H。</p></li>
<li><p>若 H
未出现在其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤1；否则，取出下一个列表的头部记作
H，继续该步骤。</p></li>
<li><p>重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，说明无法构建继承关系，Python
会抛出异常。</p></li>
</ol>
<p>你可以在草稿纸上，参照上面的merge算法，写出如下过程</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">object</span><span class="p">]</span>
<span class="n">L</span><span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span>
<span class="n">L</span><span class="p">[</span><span class="n">E</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">E</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span>
<span class="n">L</span><span class="p">[</span><span class="n">F</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span>
<span class="n">L</span><span class="p">[</span><span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span>
<span class="n">L</span><span class="p">[</span><span class="n">C</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span>
<span class="n">L</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">C</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">([</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">([</span><span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">([</span><span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">([</span><span class="n">E</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">([</span><span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">F</span><span class="p">]</span> <span class="o">+</span> <span class="n">merge</span><span class="p">([</span><span class="nb">object</span><span class="p">],</span> <span class="p">[</span><span class="nb">object</span><span class="p">])</span>
     <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h4>附录：参考文章<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<hr class="docutils" />
<ul class="simple">
<li><p><a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a></p></li>
<li><p><a class="reference external" href="https://www.cnblogs.com/whatisfantasy/p/6046991.html">https://www.cnblogs.com/whatisfantasy/p/6046991.html</a></p></li>
</ul>
</div>
</div>
<span id="document-c07/c07_06"></span><div class="section" id="polymorphism">
<h3>7.6 【基础】类的多态（Polymorphism）<a class="headerlink" href="#polymorphism" title="Permalink to this headline">¶</a></h3>
<p>多态，是指在同一类型下的不同形态。</p>
<p>比如下面这段代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">People</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">American</span><span class="p">(</span><span class="n">People</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Hello, boys&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Chinese</span><span class="p">(</span><span class="n">People</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;你好，老铁&quot;</span><span class="p">)</span>

<span class="n">p1</span> <span class="o">=</span> <span class="n">American</span><span class="p">()</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">Chinese</span><span class="p">()</span>
</pre></div>
</div>
<p>American 和 Chinese 都继承了 People 类，但他们在 <code class="docutils literal notranslate"><span class="pre">speak()</span></code>
函数下，却有不同的形态表现。American 说英文，Chinese 说汉语。</p>
<p>倘若现在有一个 <code class="docutils literal notranslate"><span class="pre">do_speak</span></code> 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_speak</span><span class="p">(</span><span class="n">people</span><span class="p">):</span>
    <span class="n">people</span><span class="o">.</span><span class="n">speak</span><span class="p">()</span>

<span class="n">do_speak</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="n">do_speak</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
</pre></div>
</div>
<p>那么无论传入的 American 实例还是 Chinese 实例，只要他有实现 speak
方法都可以。</p>
<p>这就是 Python
中非常有名鸭子类型：<strong>一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</strong></p>
<p>套入刚刚的代码实例中，就是一个对象，只要有 speak 方法，那么他就是一个
<code class="docutils literal notranslate"><span class="pre">do_speak</span></code> 方法所需要的 people 对象。</p>
<p>可能有人会觉得，这些内容很自然啊，没什么不好理解，不觉得多态有什么特殊，Python就是这样啊！</p>
<p>如果你学过 JAVA
这一类强类型静态语言，就不会这么觉得了，对于JAVA，必须指定函数参数的数据类型，只能传递对应参数类型或其子类型的参数，不能传递其它类型的参数，show_kind()函数只能接收animal、dog、cat和pig类型，而不能接收job类型。就算接收dog、cat和pig类型，也是通过面向对象的多态机制实现的。</p>
</div>
<span id="document-c07/c07_07"></span><div class="section" id="property">
<h3>7.7 【基础】类的 property 属性<a class="headerlink" href="#property" title="Permalink to this headline">¶</a></h3>
<p>在之前的学习中，对象的属性，我们都是通过把变量值赋值给对象本身来实现的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span><span class="k">pass</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;王炳明&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">27</span>
</pre></div>
</div>
<p>直接赋值会存在一个问题，就是无法对属性值进行合法性较验，比如我给 age
赋值的是负数，在业务上这种数据是不合法的。但上面那种写法是无法检查出来的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="o">-</span><span class="mi">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">age</span>
<span class="go">-27</span>
</pre></div>
</div>
<p>为了实现属性的合法性校验，Python 引入的 property 属性。</p>
<p>请看下面这段代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age</span>

    <span class="nd">@age.setter</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">150</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_age</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 150]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>此时再对 age 属性进行赋值就会对 value 的值进行合法性检查，小于 0 或者
大于 150 的都是不合法数据。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="o">-</span><span class="mi">27</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">10</span>, in <span class="n">age</span>
<span class="gr">ValueError</span>: <span class="n">Valid value must be in [0, 150]</span>
</pre></div>
</div>
<p>由此我们知道了 <code class="docutils literal notranslate"><span class="pre">property</span></code> ，其实是 Python
中一个内置的装饰器，它可以在新式类中把一个函数 <code class="docutils literal notranslate"><span class="pre">改造</span></code> 成属性。</p>
<ul class="simple">
<li><p>当你读取属性值时，会进入被 <code class="docutils literal notranslate"><span class="pre">property</span></code> 装饰的函数。</p></li>
<li><p>当你对属性进行赋值时，会进入被 <code class="docutils literal notranslate"><span class="pre">&#64;xx.setter</span></code> 装饰的函数。</p></li>
<li><p>两个装饰器，一定是 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 在前面，而 <code class="docutils literal notranslate"><span class="pre">&#64;xx.setter</span></code> 在后</p></li>
</ul>
</div>
<span id="document-c07/c07_08"></span><div class="section" id="mixin">
<h3>7.8 【进阶】类的 Mixin 设计模式<a class="headerlink" href="#mixin" title="Permalink to this headline">¶</a></h3>
<p>类的单继承，是开发者再熟悉不过的继承方式，写起来也毫不费力。</p>
<p>而多继承呢，见得很多，写得很少。在很多的项目代码里，你还会见到一种很奇怪的类，他们有一个命名上的共同点，就是在类名的结尾，都喜欢用
Mixin。</p>
<div class="section" id="id1">
<h4>1. 认识Mixin模式<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>那我们今天就来讲讲这个
Mixin，对于这个Mixin，如何理解？它其实是一种设计模式，如果开发者之间没有产生这样一种设计模式的共识，那么设计模式将不复存在。</p>
<p>为了让大家，对这个 Mixin 有一个更直观的理解，我摘录了网上一段说明。</p>
<p>继承是一个”is-a”关系。比如轿车类继承交通工具类，因为轿车是一个(“is-a”)交通工具。一个物品不可能是多种不同的东西，因此就不应该存在多重继承。不过有没有这种情况，一个类的确是需要继承多个类呢？</p>
<p>答案是有，我们还是拿交通工具来举例子，民航飞机是一种交通工具，对于土豪们来说直升机也是一种交通工具。对于这两种交通工具，它们都有一个功能是飞行，但是轿车没有。所以，我们不可能将飞行功能写在交通工具这个父类中。但是如果民航飞机和直升机都各自写自己的飞行方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会出现许多重复代码）。</p>
<p>怎么办，那就只好让这两种飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么破？</p>
<p>这时候 Mixin
就闪亮登场了。飞行只是飞机做为交通工具的一种（增强）属性，我们可以为这个飞行的功能单独定义一个（增强）类，称之为
Mixin
类。这个类，是做为增强功能，添加到子类中的。为了让其他开发者，一看就知道这是个
Mixin 类，一般都要求开发者遵循规范，在类名末尾加上 Mixin 。</p>
<p>举个例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vehicle</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">PlaneMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;I am flying&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Airplane</span><span class="p">(</span><span class="n">Vehicle</span><span class="p">,</span> <span class="n">PlaneMixin</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>使用Mixin类实现多重继承要遵循以下几个规范</p>
<ul class="simple">
<li><p>责任明确：必须表示某一种功能，而不是某个物品；</p></li>
<li><p>功能单一：若有多个功能，那就写多个Mixin类；</p></li>
<li><p>绝对独立：不能依赖于子类的实现；子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。</p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>2. 不使用Mixin的弊端<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>你肯定会问，不使用 Mixin 行吗？</p>
<p>当然可以，这个问题就像在问，我不遵循 PEP8
代码规范行吗？完全没问题，只是不推荐那样做。</p>
<p>那么到底有什么理由，让我们要去用到 Mixin 设计模式呢？</p>
<p>不使用的话，大概有如下三点弊端：</p>
<p><strong>1、结构复杂</strong></p>
<p>单继承中一个类的父类是什么，父类的父类是什么非常明确。多继承一个类有多个父类，父类又有多个父类，继承关系复杂。</p>
<p><strong>2、优先顺序模糊</strong></p>
<p>多个父类中有同名方法，在开发过程中，容易造成思维混乱，子类不知道继承哪个父类，会增加开发难度。关于子类的继承顺序，有一个比较复杂的
C3 算法，如果你还不清楚，可以点击我的另一篇文章 ，了解一下。</p>
<p><strong>3、功能冲突</strong></p>
<p>多重继承有多个父类，但是子类只能继承一个，对于同名方法，就会导致另一个父类的方法失效。</p>
</div>
</div>
<span id="document-c07/c07_09"></span><div class="section" id="id1">
<h3>7.9 【进阶】类的魔术方法（超全整理）<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>什么是魔法方法呢？它们在面向对象的Python的处处皆是。</p>
<p>它们是一些可以让你对类添加<code class="docutils literal notranslate"><span class="pre">魔法</span></code>的特殊方法。它们经常是两个下划线包围来命名的（比如
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> ， <code class="docutils literal notranslate"><span class="pre">__lt__</span></code> ）。</p>
<p>本文整理自：<a class="reference external" href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id28">(译)Python魔法方法指南</a>，内容非常多，不适合新手全文阅读，如果你是跟着教程从头看到这的，建议先跳过本文内容。而如果你是一名有经验的
Python 老手，可以考虑全文通读，会加深你对 Python 魔法方法的理解。</p>
<div class="section" id="id2">
<h4>01. 构造方法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>我们最为熟知的基本的魔法方法就是 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
，我们可以用它来指明一个对象初始化的行为。然而，当我们调用 x =
SomeClass() 的时候， <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
并不是第一个被调用的方法。事实上，第一个被调用的是 <code class="docutils literal notranslate"><span class="pre">__new__</span></code> ，这个
方法才真正地创建了实例。当这个对象的生命周期结束的时候， <code class="docutils literal notranslate"><span class="pre">__del__</span></code>
会被调用。让我们近一步理解这三个方法：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__new__(cls,[…)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">__new__</span></code> 是对象实例化时第一个调用的方法，它只取下 cls
参数，并把其他参数传给 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 。<code class="docutils literal notranslate"><span class="pre">__new__</span></code>
很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。我不打算深入讨论
<code class="docutils literal notranslate"><span class="pre">__new__</span></code> ，因为它并不是很有用， Python文档 中 有详细的说明。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__(self,[…])</span></code></p>
<p>类的初始化方法。它获取任何传给构造器的参数（比如我们调用 x =
SomeClass(10, ‘foo’) ， <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 就会接到参数 10 和 ‘foo’
。<code class="docutils literal notranslate"><span class="pre">__init__</span></code> 在Python的类定义中用的最多。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__del__(self)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">__new__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 是对象的构造器， <code class="docutils literal notranslate"><span class="pre">__del__</span></code>
是对象的销毁器。它并非实现了语句 del x (因此该语句不等同于
x.<code class="docutils literal notranslate"><span class="pre">__del__()</span></code>。而是定义了当对象被垃圾回收时的行为。当对象需要在销毁时做一些处理的时候这个方法很有用，比如
socket
对象、文件对象。但是需要注意的是，当Python解释器退出但对象仍然存活的时候，
<code class="docutils literal notranslate"><span class="pre">__del__</span></code> 并不会
执行。所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。</p>
</li>
</ul>
<p>这里有个 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__del__</span></code> 的例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span>

<span class="k">class</span> <span class="nc">FileObject</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;文件对象的装饰类，用来保证文件被删除时能够正确关闭。&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;sample.txt&#39;</span><span class="p">):</span>
        <span class="c1"># 使用读写模式打开filepath中的filename文件</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>02. 操作符<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>使用Python魔法方法的一个巨大优势就是可以构建一个拥有Python内置类型行为的对象。这意味着你可以避免使用非标准的、丑陋的方式来表达简单的操作。在一些语言中，这样做很常见:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other_instance</span><span class="p">):</span>
    <span class="c1"># do something</span>
</pre></div>
</div>
<p>你当然可以在Python也这么做，但是这样做让代码变得冗长而混乱。不同的类库可能对同一种比较操作采用不同的方法名称，这让使用者需要做很多没有必要的工作。运用魔法方法的魔力，我们可以定义方法
<code class="docutils literal notranslate"><span class="pre">__eq__</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">instance</span> <span class="o">==</span> <span class="n">other_instance</span><span class="p">:</span>
    <span class="c1"># do something</span>
</pre></div>
</div>
<p>这是魔法力量的一部分，这样我们就可以创建一个像内建类型那样的对象了！</p>
<div class="section" id="id4">
<h5>2.1 比较操作符<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>Python包含了一系列的魔法方法，用于实现对象之间直接比较，而不需要采用方法调用。同样也可以重载Python默认的比较方法，改变它们的行为。下面是这些方法的列表：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__cmp__(self,</span> <span class="pre">other)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">__cmp__</span></code>
是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;,==,!=,等等），但是它可能不能按照你需要的方式工作（例如，判断一个实例和另一个实例是否相等采用一套标准，而与判断一个实例是否大于另一实例采用另一套）。<code class="docutils literal notranslate"><span class="pre">__cmp__</span></code>
应该在 self &lt; other 时返回一个负整数，在 self == other 时返回0，在
self &gt; other
时返回正整数。最好只定义你所需要的比较形式，而不是一次定义全部。如果你需要实现所有的比较形式，而且它们的判断标准类似，那么
<code class="docutils literal notranslate"><span class="pre">__cmp__</span></code> 是一个很好的方法，可以减少代码重复，让代码更简洁。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__eq__(self,</span> <span class="pre">other)</span></code></p>
<p>定义等于操作符(==)的行为。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ne__(self,</span> <span class="pre">other)</span></code></p>
<p>定义不等于操作符(!=)的行为。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__lt__(self,</span> <span class="pre">other)</span></code></p>
<p>定义小于操作符(&lt;)的行为。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__gt__(self,</span> <span class="pre">other)</span></code></p>
<p>定义大于操作符(&gt;)的行为。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__le__(self,</span> <span class="pre">other)</span></code></p>
<p>定义小于等于操作符(&lt;)的行为。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ge__(self,</span> <span class="pre">other)</span></code></p>
<p>定义大于等于操作符(&gt;)的行为。</p>
</li>
</ul>
<p>举个例子，假如我们想用一个类来存储单词。我们可能想按照字典序（字母顺序）来比较单词，字符串的默认比较行为就是这样。我们可能也想按照其他规则来比较字符串，像是长度，或者音节的数量。在这个例子中，我们使用长度作为比较标准，下面是一种实现:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Word</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;单词类，按照单词长度来定义比较行为&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="c1"># 注意，我们只能使用 `__new__` ，因为str是不可变类型</span>
        <span class="c1"># 所以我们必须提前初始化它（在实例创建时）</span>
        <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;Value contains spaces. Truncating to first space.&quot;</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">word</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)]</span>
            <span class="c1"># Word现在包含第一个空格前的所有字母</span>
        <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="sb">`__new__`</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们可以创建两个 Word 对象（ Word(‘foo’) 和
Word(‘bar’))然后根据长度来比较它们。注意我们没有定义 <code class="docutils literal notranslate"><span class="pre">__eq__</span></code> 和
<code class="docutils literal notranslate"><span class="pre">__ne__</span></code> ，这是因为有时候它们会导致奇怪的结果（很明显， Word(‘foo’) ==
Word(‘bar’)
得到的结果会是true）。根据长度测试是否相等毫无意义，所以我们使用 str
的实现来比较相等。</p>
<p>从上面可以看到，不需要实现所有的比较魔法方法，就可以使用丰富的比较操作。标准库还在
functools 模块中提供了一个类装饰器，只要我们定义 <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>
和另外一个操作符（ <code class="docutils literal notranslate"><span class="pre">__gt__</span></code>, <code class="docutils literal notranslate"><span class="pre">__lt__</span></code>
等），它就可以帮我们实现比较方法。这个特性只在 Python 2.7
中可用。当它可用时，它能帮助我们节省大量的时间和精力。要使用它，只需要它
&#64;total_ordering 放在类的定义之上就可以了</p>
</div>
<div class="section" id="id5">
<h5>2.2 数值操作符<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>就像你可以使用比较操作符来比较类的实例，你也可以定义数值操作符的行为。固定好你的安全带，这样的操作符真的有很多。看在组织的份上，我把它们分成了五类：一元操作符，常见算数操作符，反射算数操作符（后面会涉及更多），增强赋值操作符，和类型转换操作符。</p>
<div class="section" id="id6">
<h6>一元操作符<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h6>
<p>一元操作符只有一个操作符。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__pos__(self)</span></code></p>
<p>实现取正操作，例如 +some_object。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__neg_(self)</span></code></p>
<p>实现取负操作，例如 -some_object。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__abs__(self)</span></code></p>
<p>实现内建绝对值函数 abs() 操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__invert__(self)</span></code></p>
<p>实现取反操作符 ~。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__round__(self，</span> <span class="pre">n)</span></code></p>
<p>实现内建函数 round() ，n 是近似小数点的位数。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__floor__(self)</span></code></p>
<p>实现 math.floor() 函数，即向下取整。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ceil__(self)</span></code></p>
<p>实现 math.ceil() 函数，即向上取整。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__trunc__(self)</span></code></p>
<p>实现 math.trunc() 函数，即距离零最近的整数。</p>
</li>
</ul>
</div>
<div class="section" id="id7">
<h6>常见算数操作符<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h6>
<p>现在，我们来看看常见的二元操作符（和一些函数），像+，-，<a href="#id8"><span class="problematic" id="id9">*</span></a>之类的，它们很容易从字面意思理解。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__add__(self,</span> <span class="pre">other)</span></code></p>
<p>实现加法操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__sub__(self,</span> <span class="pre">other)</span></code></p>
<p>实现减法操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__mul__(self,</span> <span class="pre">other)</span></code></p>
<p>实现乘法操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__floordiv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现使用 // 操作符的整数除法。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__div__(self,</span> <span class="pre">other)</span></code></p>
<p>实现使用 / 操作符的除法。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__truediv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 <em>true</em> 除法，这个函数只有使用
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code> 时才有作用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__mod__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 % 取余操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__divmod__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 divmod 内建函数。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__pow__(self)</span></code></p>
<p>实现 ** 操作符。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__lshift__(self,</span> <span class="pre">other)</span></code></p>
<p>实现左移位运算符 &lt;&lt; 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rshift__(self,</span> <span class="pre">other)</span></code></p>
<p>实现右移位运算符 &gt;&gt; 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__and__(self,</span> <span class="pre">other)</span></code></p>
<p>实现按位与运算符 &amp; 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__or__(self,</span> <span class="pre">other)</span></code></p>
<p>实现按位或运算符 | 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__xor__(self,</span> <span class="pre">other)</span></code></p>
<p>实现按位异或运算符 ^ 。</p>
</li>
</ul>
</div>
<div class="section" id="id10">
<h6>反射算数运算符<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h6>
<p>还记得刚才我说会谈到反射运算符吗？可能你会觉得它是什么高端霸气上档次的概念，其实这东西挺简单的，下面举个例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">some_object</span> <span class="o">+</span> <span class="n">other</span>
</pre></div>
</div>
<p>这是“常见”的加法，反射是一样的意思，只不过是运算符交换了一下位置:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">other</span> <span class="o">+</span> <span class="n">some_object</span>
</pre></div>
</div>
<p>所有反射运算符魔法方法和它们的常见版本做的工作相同，只不过是处理交换连个操作数之后的情况。绝大多数情况下，反射运算和正常顺序产生的结果是相同的，所以很可能你定义
<code class="docutils literal notranslate"><span class="pre">__radd__</span></code> 时只是调用一下
<code class="docutils literal notranslate"><span class="pre">__add__</span></code>。注意一点，操作符左侧的对象（也就是上面的 other
）一定不要定义（或者产生 NotImplemented 异常）
操作符的非反射版本。例如，在上面的例子中，只有当 other 没有定义
<code class="docutils literal notranslate"><span class="pre">__add__</span></code> 时 some_object.<code class="docutils literal notranslate"><span class="pre">__radd__</span></code> 才会被调用。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__radd__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射加法操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rsub__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射减法操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rmul__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射乘法操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rfloordiv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现使用 // 操作符的整数反射除法。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rdiv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现使用 / 操作符的反射除法。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rtruediv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 <em>true</em> 反射除法，这个函数只有使用
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code> 时才有作用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rmod__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 % 反射取余操作符。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rdivmod__(self,</span> <span class="pre">other)</span></code></p>
<p>实现调用 divmod(other, self) 时 divmod 内建函数的操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rpow__(self)</span></code></p>
<p>实现 ** 反射操作符。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rlshift__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射左移位运算符 &lt;&lt; 的作用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rshift__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射右移位运算符 &gt;&gt; 的作用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rand__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射按位与运算符 &amp; 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ror__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射按位或运算符 | 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rxor__(self,</span> <span class="pre">other)</span></code></p>
<p>实现反射按位异或运算符 ^ 。</p>
</li>
</ul>
</div>
<div class="section" id="id11">
<h6>增强赋值运算符<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h6>
<p>Python同样提供了大量的魔法方法，可以用来自定义增强赋值操作的行为。或许你已经了解增强赋值，它融合了“常见”的操作符和赋值操作，如果你还是没听明白，看下面的例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 也就是 x = x + 1</span>
</pre></div>
</div>
<p>这些方法都应该返回左侧操作数应该被赋予的值（例如， a += b <code class="docutils literal notranslate"><span class="pre">__iadd__</span></code>
也许会返回 a + b ，这个结果会被赋给 a ）,下面是方法列表：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__iadd__(self,</span> <span class="pre">other)</span></code></p>
<p>实现加法赋值操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__isub__(self,</span> <span class="pre">other)</span></code></p>
<p>实现减法赋值操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__imul__(self,</span> <span class="pre">other)</span></code></p>
<p>实现乘法赋值操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ifloordiv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现使用 //= 操作符的整数除法赋值操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__idiv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现使用 /= 操作符的除法赋值操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__itruediv__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 <em>true</em>
除法赋值操作，这个函数只有使用<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span>&#160; <span class="pre">import</span> <span class="pre">division</span></code>
时才有作用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__imod__(self,</span> <span class="pre">other)</span></code></p>
<p>实现 %= 取余赋值操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ipow__(self)</span></code></p>
<p>实现 **= 操作。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ilshift__(self,</span> <span class="pre">other)</span></code></p>
<p>实现左移位赋值运算符 &lt;&lt;= 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__irshift__(self,</span> <span class="pre">other)</span></code></p>
<p>实现右移位赋值运算符 &gt;&gt;= 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__iand__(self,</span> <span class="pre">other)</span></code></p>
<p>实现按位与运算符 &amp;= 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ior__(self,</span> <span class="pre">other)</span></code></p>
<p>实现按位或赋值运算符 | 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ixor__(self,</span> <span class="pre">other)</span></code></p>
<p>实现按位异或赋值运算符 ^= 。</p>
</li>
</ul>
</div>
<div class="section" id="id12">
<h6>类型转换操作符<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h6>
<p>Python也有一系列的魔法方法用于实现类似 float()
的内建类型转换函数的操作。它们是这些：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__int__(self)</span></code></p>
<p>实现到int的类型转换。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__long__(self)</span></code></p>
<p>实现到long的类型转换。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__float__(self)</span></code></p>
<p>实现到float的类型转换。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__complex__(self)</span></code></p>
<p>实现到complex的类型转换。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__oct__(self)</span></code></p>
<p>实现到八进制数的类型转换。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__hex__(self)</span></code></p>
<p>实现到十六进制数的类型转换。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__index__(self)</span></code></p>
<p>实现当对象用于切片表达式时到一个整数的类型转换。如果你定义了一个可能会用于切片操作的数值类型，你应该定义
<code class="docutils literal notranslate"><span class="pre">__index__</span></code>。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__trunc__(self)</span></code></p>
<p>当调用 math.trunc(self) 时调用该方法，<code class="docutils literal notranslate"><span class="pre">__trunc__</span></code>应该返回 self
截取到一个整数类型（通常是long类型）的值。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__coerce__(self)</span></code></p>
<p>该方法用于实现混合模式算数运算，如果不能进行类型转换， <code class="docutils literal notranslate"><span class="pre">__coerce__</span></code>
应该返回 None 。反之，它应该返回一个二元组 self 和 other
，这两者均已被转换成相同的类型。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="id13">
<h4>03. 类的表示<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>使用字符串来表示类是一个相当有用的特性。在Python中有一些内建方法可以返回类的表示，相对应的，也有一系列魔法方法可以用来自定义在使用这些内建函数时类的行为。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__str__(self)</span></code></p>
<p>定义对类的实例调用 str() 时的行为。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__repr__(self)</span></code></p>
<p>定义对类的实例调用 repr() 时的行为。str() 和 repr()
最主要的差别在于“目标用户”。repr()
的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的Python代码），而
str() 则产生人类可读的输出。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__unicode__(self)</span></code></p>
<p>定义对类的实例调用 unicode() 时的行为。unicode() 和 str()
很像，只是它返回unicode字符串。注意，如果调用者试图调用 str()
而你的类只实现了 <code class="docutils literal notranslate"><span class="pre">__unicode__</span></code>()
，那么类将不能正常工作。所有你应该总是定义 <code class="docutils literal notranslate"><span class="pre">__str__</span></code>()
，以防有些人没有闲情雅致来使用unicode。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__format__(self)</span></code></p>
<p>定义当类的实例用于新式字符串格式化时的行为，例如， “Hello,
0:abc!”.format(a) 会导致调用 <code class="docutils literal notranslate"><span class="pre">a.__format__(&quot;abc&quot;)</span></code>
。当定义你自己的数值类型或字符串类型时，你可能想提供某些特殊的格式化选项，这种情况下这个魔法方法会非常有用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__hash__(self)</span></code></p>
<p>定义对类的实例调用 hash()
时的行为。它必须返回一个整数，其结果会被用于字典中键的快速比较。同时注意一点，实现这个魔法方法通常也需要实现
<code class="docutils literal notranslate"><span class="pre">__eq__</span></code> ，并且遵守如下的规则：a == b 意味着 hash(a) == hash(b)。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__nonzero__(self)</span></code></p>
<p>定义对类的实例调用 bool()
时的行为，根据你自己对类的设计，针对不同的实例，这个魔法方法应该相应地返回True或False。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__dir__(self)</span></code></p>
<p>定义对类的实例调用 dir()
时的行为，这个方法应该向调用者返回一个属性列表。一般来说，没必要自己实现
<code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 。但是如果你重定义了 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 或者
<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code>
（下个部分会介绍），乃至使用动态生成的属性，以实现类的交互式使用，那么这个魔法方法是必不可少的。</p>
</li>
</ul>
<p>到这里，我们基本上已经结束了魔法方法指南中无聊并且例子匮乏的部分。既然我们已经介绍了较为基础的魔法方法，是时候涉及更高级的内容了。</p>
</div>
<div class="section" id="id14">
<h4>04. 访问控制<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>很多从其他语言转向Python的人都抱怨Python的类缺少真正意义上的封装（即没办法定义私有属性然后使用公有的getter和setter）。然而事实并非如此。实际上Python不是通过显式定义的字段和方法修改器，而是通过魔法方法实现了一系列的封装。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__getattr__(self,</span> <span class="pre">name)</span></code></p></li>
</ul>
<p>当用户试图访问一个根本不存在（或者暂时不存在）的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引，使用废弃属性时给出警告（如果你愿意，仍然可以计算并且返回该属性），以及灵活地处理AttributeError。只有当试图访问不存在的属性时它才会被调用，所以这不能算是一个真正的封装的办法。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code></p></li>
</ul>
<p>和 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 不同， <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code>
可以用于真正意义上的封装。它允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。然后，一定要小心使用
<code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> ，这个列表最后的例子中会有所展示。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__delattr__(self,</span> <span class="pre">name)</span></code></p></li>
</ul>
<p>这个魔法方法和
<code class="docutils literal notranslate"><span class="pre">__setattr__</span></code>几乎相同，只不过它是用于处理删除属性时的行为。和
<code class="docutils literal notranslate"><span class="pre">_setattr__</span></code> 一样，使用它时也需要多加小心，防止产生无限递归（在
<code class="docutils literal notranslate"><span class="pre">__delattr__</span></code> 的实现中调用 del self.name 会导致无限递归）。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__getattribute__(self,</span> <span class="pre">name)</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code>
看起来和上面那些方法很合得来，但是最好不要使用它。<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code>
只能用于新式类。在最新版的Python中所有的类都是新式类，在老版Python中你可以通过继承
object 来创建新式类。<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code>
允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题（通过调用基类的
<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code> 来避免）。<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code> 基本上可以替代
<code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 。只有当它被实现，并且显式地被调用，或者产生
AttributeError
时它才被使用。这个魔法方法可以被使用（毕竟，选择权在你自己），我不推荐你使用它，因为它的使用范围相对有限（通常我们想要在赋值时进行特殊操作，而不是取值时），而且实现这个方法很容易出现Bug。</p>
<p>自定义这些控制属性访问的魔法方法很容易导致问题，考虑下面这个例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># 因为每次属性幅值都要调用 __setattr__()，所以这里的实现会导致递归</span>
    <span class="c1"># 这里的调用实际上是 self.__setattr(&#39;name&#39;, value)。因为这个方法一直</span>
    <span class="c1"># 在调用自己，因此递归将持续进行，直到程序崩溃</span>

<span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># 使用 __dict__ 进行赋值</span>
    <span class="c1"># 定义自定义行为</span>
</pre></div>
</div>
<p>再次重申，Python的魔法方法十分强大，能力越强责任越大，了解如何正确的使用魔法方法更加重要。</p>
<p>到这里，我们对Python中自定义属性存取控制有了什么样的印象？它并不适合轻度的使用。实际上，它有些过分强大，而且违反直觉。然而它之所以存在，是因为一个更大的原则：Python不指望让杜绝坏事发生，而是想办法让做坏事变得困难。自由是至高无上的权利，你真的可以随心所欲。下面的例子展示了实际应用中某些特殊的属性访问方法（注意我们之所以使用
super 是因为不是所有的类都有 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 属性）:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AccessCounter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; 一个包含了一个值并且实现了访问计数器的类</span>
<span class="sd">    每次值的变化都会导致计数器自增&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr_</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 使计数器自增变成不可避免</span>
        <span class="c1"># 如果你想阻止其他属性的赋值行为</span>
        <span class="c1"># 产生 AttributeError(name) 就可以了</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delattr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>05. 自定义序列<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>有许多办法可以让你的Python类表现得像是内建序列类型（字典，元组，列表，字符串等）。这些魔法方式是目前为止我最喜欢的。它们给了你难以置信的控制能力，可以让你的类与一系列的全局函数完美结合。在了解激动人心的内容之前，首先你需要掌握一些预备知识。</p>
<p>既然讲到创建自己的序列类型，就不得不说一说协议了。协议类似某些语言中的接口，里面包含的是一些必须实现的方法。在Python中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p>
<p>为什么我们要讲协议？因为在Python中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义
<code class="docutils literal notranslate"><span class="pre">__len__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>
(后面会具体说明）。可变容器的协议除了上面提到的两个方法之外，还需要定义
<code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__delitem__</span></code>
。最后，如果你想让你的对象可以迭代，你需要定义 <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>
，这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code> （返回它自己）和 next 方法。</p>
<div class="section" id="id16">
<h5>5.1 容器背后的魔法方法<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__len__</span></code>(self)</p>
<p>返回容器的长度，可变和不可变类型都需要实现。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>(self, key)</p>
<p>定义对容器中某一项使用 self[key]
的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生
TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>(self, key)</p>
<p>定义对容器中某一项使用 self[key]
的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生
KeyError 和 TypeError 异常。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__iter__</span></code>(self, key)</p>
<p>它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用
iter() 函数调用，以及在类似 for x in container:
的循环中被调用。迭代器是他们自己的对象，需要定义 <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>
方法并在其中返回自己。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__reversed__</span></code>(self)</p>
<p>定义了对容器使用 reversed()
内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法，</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>(self, item)</p>
<p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code> 定义了使用 in 和 not in
进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果
<code class="docutils literal notranslate"><span class="pre">__contains__</span></code>
没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回 True 。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__missing__</span></code>(self ,key)</p>
<p><code class="docutils literal notranslate"><span class="pre">__missing__</span></code>
在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典
d ， “george” 不是字典中的一个键，当试图访问 d[“george’] 时就会调用
d.<code class="docutils literal notranslate"><span class="pre">__missing__</span></code>(“george”) ）。</p>
</li>
</ul>
</div>
<div class="section" id="id17">
<h5>5.2 一个例子<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<p>让我们来看一个实现了一些函数式结构的列表，可能在其他语言中这种结构更常见（例如Haskell）:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FunctionalList</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;一个列表的封装类，实现了一些额外的函数式</span>
<span class="sd">    方法，例如head, tail, init, last, drop和take。&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># 如果键的类型或值不合法，列表会返回异常</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得第一个元素</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得除第一个元素外的所有元素</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">valuse</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得除最后一个元素外的所有元素</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得最后一个元素</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># 取得除前n个元素外的所有元素</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># 取得前n个元素</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>就是这些，一个（微不足道的）有用的例子，向你展示了如何实现自己的序列。当然啦，自定义序列有更大的用处，而且绝大部分都在标准库中实现了（Python是自带电池的，记得吗？），像
Counter , OrderedDict 和 NamedTuple 。</p>
</div>
</div>
<div class="section" id="id18">
<h4>06. 反射<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>你可以通过定义魔法方法来控制用于反射的内建函数 isinstance 和 issubclass
的行为。下面是对应的魔法方法：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__instancecheck__(self,</span> <span class="pre">instance)</span></code></p>
<p>检查一个实例是否是你定义的类的一个实例（例如 isinstance(instance,
class) ）。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__subclasscheck__(self,</span> <span class="pre">subclass)</span></code></p>
<p>检查一个类是否是你定义的类的子类（例如 issubclass(subclass, class)
）。</p>
</li>
</ul>
<p>这几个魔法方法的适用范围看起来有些窄，事实也正是如此。我不会在反射魔法方法上花费太多时间，因为相比其他魔法方法它们显得不是很重要。但是它们展示了在Python中进行面向对象编程（或者总体上使用Python进行编程）时很重要的一点：不管做什么事情，都会有一个简单方法，不管它常用不常用。这些魔法方法可能看起来没那么有用，但是当你真正需要用到它们的时候，你会感到很幸运，因为它们还在那儿（也因为你阅读了这本指南！）</p>
</div>
<div class="section" id="id19">
<h4>07. 抽象基类<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>请参考 <em>http://docs.python.org/2/library/abc.html</em></p>
</div>
<div class="section" id="id20">
<h4>08. 可调用的对象<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>你可能已经知道了，在Python中，函数是一等的对象。这意味着它们可以像其他任何对象一样被传递到函数和方法中，这是一个十分强大的特性。</p>
<p>Python中一个特殊的魔法方法允许你自己类的对象表现得像是函数，然后你就可以“调用”它们，把它们传递到使用函数做参数的函数中，等等等等。这是另一个强大而且方便的特性，让使用Python编程变得更加幸福。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__call__(self,</span> <span class="pre">[args…])</span></code></p>
<p>允许类的一个实例像函数那样被调用。本质上这代表了 x() 和
x.<code class="docutils literal notranslate"><span class="pre">__call__</span></code>() 是相同的。注意 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
可以有多个参数，这代表你可以像定义其他任何函数一样，定义 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
，喜欢用多少参数就用多少。</p>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">__call__</span></code>
在某些需要经常改变状态的类的实例中显得特别有用。“调用”这个实例来改变它的状态，是一种更加符合直觉，也更加优雅的方法。一个表示平面上实体的类是一个不错的例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Entity</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;表示一个实体的类，调用它的实例</span>
<span class="sd">        可以更新实体的位置&#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="sd">&#39;&#39;&#39;改变实体的位置&#39;&#39;&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>09. 上下文管理器<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>在Python 2.5中引入了一个全新的关键词，随之而来的是一种新的代码复用方法——
with
声明。上下文管理的概念在Python中并不是全新引入的（之前它作为标准库的一部分实现），直到PEP
343被接受，它才成为一种一级的语言结构。可能你已经见过这种写法了:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>
    <span class="c1"># 使用bar进行某些操作</span>
</pre></div>
</div>
<p>当对象使用 with
声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由下面两个魔法方法所定义：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code></p>
<p>定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。注意
<code class="docutils literal notranslate"><span class="pre">__enter__</span></code> 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exception_type,</span> <span class="pre">exception_value,</span> <span class="pre">traceback)</span></code></p>
<p>定义当 with
声明语句块执行完毕（或终止）时上下文管理器的行为。它可以用来处理异常，进行清理，或者做其他应该在语句块结束之后立刻执行的工作。如果语句块顺利执行，
exception_type , exception_value 和 traceback 会是 None
。否则，你可以选择处理这个异常或者让用户来处理。如果你想处理异常，确保
<code class="docutils literal notranslate"><span class="pre">__exit__</span></code> 在完成工作之后返回 True
。如果你不想处理异常，那就让它发生吧。</p>
</li>
</ul>
<p>对一些具有良好定义的且通用的设置和清理行为的类，<code class="docutils literal notranslate"><span class="pre">__enter__</span></code> 和
<code class="docutils literal notranslate"><span class="pre">__exit__</span></code>会显得特别有用。你也可以使用这几个方法来创建通用的上下文管理器，用来包装其他对象。下面是一个例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Closer</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;一个上下文管理器，可以在with语句中</span>
<span class="sd">    使用close()自动关闭对象&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="c1"># 绑定到目标</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># obj不是可关闭的</span>
                <span class="k">print</span> <span class="s1">&#39;Not closable.&#39;</span>
                <span class="k">return</span> <span class="bp">True</span> <span class="c1"># 成功地处理了异常</span>
</pre></div>
</div>
<p>这是一个 Closer
在实际使用中的例子，使用一个FTP连接来演示（一个可关闭的socket):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magicmethods</span> <span class="kn">import</span> <span class="n">Closer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ftplib</span> <span class="kn">import</span> <span class="n">FTP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Closer</span><span class="p">(</span><span class="n">FTP</span><span class="p">(</span><span class="s1">&#39;ftp.somesite.com&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">conn</span><span class="o">.</span><span class="n">dir</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go"># 为了简单，省略了某些输出</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">dir</span><span class="p">()</span>
<span class="go"># 很长的 AttributeError 信息，不能使用一个已关闭的连接</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Closer</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="k">as</span> <span class="n">i</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="go">Not closable.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span>
<span class="go">6</span>
</pre></div>
</div>
<p>看到我们的包装器是如何同时优雅地处理正确和不正确的调用了吗？这就是上下文管理器和魔法方法的力量。Python标准库包含一个
contextlib 模块，里面有一个上下文管理器 contextlib.closing()
基本上和我们的包装器完成的是同样的事情（但是没有包含任何当对象没有close()方法时的处理）。</p>
</div>
<div class="section" id="id22">
<h4>10. 创建描述符对象<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>描述符是一个类，当使用取值，赋值和删除
时它可以改变其他对象。描述符不是用来单独使用的，它们需要被一个拥有者类所包含。描述符可以用来创建面向对象数据库，以及创建某些属性之间互相依赖的类。描述符在表现具有不同单位的属性，或者需要计算的属性时显得特别有用（例如表现一个坐标系中的点的类，其中的距离原点的距离这种属性）。</p>
<p>要想成为一个描述符，一个类必须具有实现 <code class="docutils literal notranslate"><span class="pre">__get__</span></code> , <code class="docutils literal notranslate"><span class="pre">__set__</span></code> 和
<code class="docutils literal notranslate"><span class="pre">__delete__</span></code> 三个方法中至少一个。</p>
<p>让我们一起来看一看这些魔法方法：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__get__(self,</span> <span class="pre">instance,</span> <span class="pre">owner)</span></code></p>
<p>定义当试图取出描述符的值时的行为。instance 是拥有者类的实例， owner
是拥有者类本身。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__set__(self,</span> <span class="pre">instance,</span> <span class="pre">owner)</span></code></p>
<p>定义当描述符的值改变时的行为。instance 是拥有者类的实例， value
是要赋给描述符的值。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__delete__(self,</span> <span class="pre">instance,</span> <span class="pre">owner)</span></code></p>
<p>定义当描述符的值被删除时的行为。instance 是拥有者类的实例</p>
</li>
</ul>
<p>现在，来看一个描述符的有效应用：单位转换:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;米的描述符。&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;英尺的描述符。&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">meter</span> <span class="o">*</span> <span class="mf">3.2808</span>
    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">meter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.2808</span>

<span class="k">class</span> <span class="nc">Distance</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;用于描述距离的类，包含英尺和米两个描述符。&#39;&#39;&#39;</span>
    <span class="n">meter</span> <span class="o">=</span> <span class="n">Meter</span><span class="p">()</span>
    <span class="n">foot</span> <span class="o">=</span> <span class="n">Foot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h4>11. 拷贝<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>有些时候，特别是处理可变对象时，你可能想拷贝一个对象，改变这个对象而不影响原有的对象。这时就需要用到Python的
copy 模块了。然而（幸运的是），Python模块并不具有感知能力，
因此我们不用担心某天基于Linux的机器人崛起。但是我们的确需要告诉Python如何有效率地拷贝对象。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__copy__(self)</span></code></p>
<p>定义对类的实例使用 copy.copy() 时的行为。copy.copy()
返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__deepcopy__(self,</span> <span class="pre">memodict=)</span></code></p>
<p>定义对类的实例使用 copy.deepcopy() 时的行为。copy.deepcopy()
返回一个对象的深拷贝，这个对象和它的数据全都被拷贝了一份。memodict
是一个先前拷贝对象的缓存，它优化了拷贝过程，而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用
copy.deepcopy() ，使用 memodict 作为第一个参数。</p>
</li>
</ul>
<p>这些魔法方法有什么用武之地呢？像往常一样，当你需要比默认行为更加精确的控制时。例如，如果你想拷贝一个对象，其中存储了一个字典作为缓存（可能会很大），拷贝缓存可能是没有意义的。如果这个缓存可以在内存中被不同实例共享，那么它就应该被共享。</p>
</div>
<div class="section" id="pickling">
<h4>12. Pickling<a class="headerlink" href="#pickling" title="Permalink to this headline">¶</a></h4>
<p>如果你和其他的Python爱好者共事过，很可能你已经听说过Pickling了。Pickling是Python数据结构的序列化过程，当你想存储一个对象稍后再取出读取时，Pickling会显得十分有用。然而它同样也是担忧和混淆的主要来源。</p>
<p>Pickling是如此的重要，以至于它不仅仅有自己的模块（ pickle
），还有自己的协议和魔法方法。首先，我们先来简要的介绍一下如何pickle已存在的对象类型（如果你已经知道了，大可跳过这部分内容）。</p>
<div class="section" id="id24">
<h5>12.1 小试牛刀<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h5>
<p>我们一起来pickle吧。假设你有一个字典，你想存储它，稍后再取出来。你可以把它的内容写入一个文件，小心翼翼地确保使用了正确地格式，要把它读取出来，你可以使用
exec()
或处理文件输入。但是这种方法并不可靠：如果你使用纯文本来存储重要数据，数据很容易以多种方式被破坏或者修改，导致你的程序崩溃，更糟糕的情况下，还可能在你的计算机上运行恶意代码。因此，我们要pickle它:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world!&#39;</span><span class="p">),</span>
                <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
<span class="n">jar</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">jar</span><span class="p">)</span> <span class="c1"># 将pickle后的数据写入jar文件</span>
<span class="n">jar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>过了几个小时，我们想把它取出来，我们只需要反pickle它:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">pkl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="c1"># 与pickle后的数据连接</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span> <span class="c1"># 把它加载进一个变量</span>
<span class="k">print</span> <span class="n">data</span>
<span class="n">pkl_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>将会发生什么？正如你期待的，它就是我们之前的 data 。</p>
<p>现在，还需要谨慎地说一句：pickle并不完美。Pickle文件很容易因为事故或被故意的破坏掉。Pickling或许比纯文本文件安全一些，但是依然有可能被用来运行恶意代码。而且它还不支持跨Python版本，所以不要指望分发pickle对象之后所有人都能正确地读取。然而不管怎么样，它依然是一个强有力的工具，可以用于缓存和其他类型的持久化工作。</p>
</div>
<div class="section" id="pickle">
<h5>12.2 Pickle你的对象<a class="headerlink" href="#pickle" title="Permalink to this headline">¶</a></h5>
<p>Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为（这和C语言扩展略有不同，那不在我们的讨论范围之内）。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__getinitargs__(self)</span></code></p>
<p>如果你想让你的类在反pickle时调用 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> ，你可以定义
<code class="docutils literal notranslate"><span class="pre">__getinitargs__</span></code>(self) ，它会返回一个参数元组，这个元组会传递给
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> 。注意，这个方法只能用于旧式类。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__getnewargs__(self)</span></code></p>
<p>对新式类来说，你可以通过这个方法改变类在反pickle时传递给 <code class="docutils literal notranslate"><span class="pre">__new__</span></code>
的参数。这个方法应该返回一个参数元组。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__getstate__(self)</span></code></p>
<p>你可以自定义对象被pickle时被存储的状态，而不使用对象的 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>
属性。这个状态在对象被反pickle时会被 <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code> 使用。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__setstate__(self)</span></code></p>
<p>当一个对象被反pickle时，如果定义了 <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code>
，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>
属性。这个魔法方法和 <code class="docutils literal notranslate"><span class="pre">__getstate__</span></code>
相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__reduce__(self)</span></code></p>
<p>当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。<strong>reduce</strong>
被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给
<code class="docutils literal notranslate"><span class="pre">__setstate__</span></code>
的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__reduce_ex__(self)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">__reduce_ex__</span></code> 的存在是为了兼容性。如果它被定义，在pickle时
<code class="docutils literal notranslate"><span class="pre">__reduce_ex__</span></code> 会代替 <code class="docutils literal notranslate"><span class="pre">__reduce__</span></code> 被调用。<code class="docutils literal notranslate"><span class="pre">__reduce__</span></code>
也可以被定义，用于不支持 <code class="docutils literal notranslate"><span class="pre">__reduce_ex__</span></code> 的旧版pickle的API调用。</p>
</li>
</ul>
</div>
<div class="section" id="id25">
<span id="id26"></span><h5>12.3 一个例子<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h5>
<p>我们的例子是 Slate
，它会记住它的值曾经是什么，以及那些值是什么时候赋给它的。然而
每次被pickle时它都会变成空白，因为当前的值不会被存储:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Slate</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;存储一个字符串和一个变更日志的类</span>
<span class="sd">        每次被pickle都会忘记它当前的值&#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last_change</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
                <span class="c1"># 改变当前值，将上一个值记录到历史</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">last_change</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last_change</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">print_change</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">print</span> <span class="s1">&#39;Changelog for Slate object:&#39;</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># 故意不返回self.value或self.last_change</span>
                <span class="c1"># 我们想在反pickle时得到一个空白的slate</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span>

        <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># 使self.history = slate，last_change</span>
                <span class="c1"># 和value为未定义</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_change</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id27">
<h4>13. 总结在最后<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>这本指南的目标是使所有阅读它的人都能有所收获，无论他们有没有使用Python或者进行面向对象编程的经验。如果你刚刚开始学习Python，你会得到宝贵的基础知识，了解如何写出具有丰富特性的，优雅而且易用的类。如果你是中级的Python程序员，你或许能掌握一些新的概念和技巧，以及一些可以减少代码行数的好办法。如果你是专家级别的Python爱好者，你又重新复习了一遍某些可能已经忘掉的知识，也可能顺便了解了一些新技巧。无论你的水平怎样，我希望这趟遨游Python特殊方法的旅行，真的对你产生了魔法般的效果（实在忍不住不说最后这个双关）。</p>
</div>
</div>
<span id="document-c07/c07_10"></span><div class="section" id="metaclass">
<h3>7.10 【进阶】神奇的元类编程（metaclass）<a class="headerlink" href="#metaclass" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 类是如何产生的<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>类是如何产生？这个问题也许你会觉得很傻。</p>
<p>实则不然，很多初学者只知道使用继承的表面形式来创建一个类，却不知道其内部真正的创建是由
<code class="docutils literal notranslate"><span class="pre">type</span></code> 来创建的。</p>
<p>type？这不是判断对象类型的函数吗？</p>
<p>是的，type通常用法就是用来判断对象的类型。但除此之外，他最大的用途是用来动态创建类。当Python扫描到class的语法的时候，就会调用type函数进行类的创建。</p>
</div>
<div class="section" id="type">
<h4>2. 如何使用type创建类<a class="headerlink" href="#type" title="Permalink to this headline">¶</a></h4>
<p>首先，<code class="docutils literal notranslate"><span class="pre">type()</span></code> 需要接收三个参数</p>
<ol class="arabic simple">
<li><p>类的名称，若不指定，也要传入空字符串：<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code></p></li>
<li><p>父类，注意以tuple的形式传入，若没有父类也要传入空tuple：<code class="docutils literal notranslate"><span class="pre">()</span></code>，默认继承object</p></li>
<li><p>绑定的方法或属性，注意以dict的形式传入</p></li>
</ol>
<p>来看个例子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 准备一个基类（父类）</span>
<span class="k">class</span> <span class="nc">BaseClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">talk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;i am people&quot;</span><span class="p">)</span>

<span class="c1"># 准备一个方法</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

<span class="c1"># 使用type来创建User类</span>
<span class="n">User</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;User&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseClass</span><span class="p">,</span> <span class="p">),</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;say&quot;</span><span class="p">:</span><span class="n">say</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>3. 理解什么是元类<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>什么是类？可能谁都知道，类就是用来创建对象的「模板」。</p>
<p>那什么是元类呢？一句话通俗来说，元类就是创建类的「模板」。</p>
<p>为什么type能用来创建类？因为它本身是一个元类。使用元类创建类，那就合理了。</p>
<p>type是Python在背后用来创建所有类的元类，我们熟知的类的始祖 <code class="docutils literal notranslate"><span class="pre">object</span></code>
也是由type创建的。更有甚者，连type自己也是由type自己创建的，这就过份了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
</pre></div>
</div>
<p>如果要形象的来理解的话，就看下面这三行话。</p>
<ul class="simple">
<li><p>str：用来创建字符串对象的类。</p></li>
<li><p>int：是用来创建整数对象的类。</p></li>
<li><p>type：是用来创建类对象的类。</p></li>
</ul>
<p>反过来看</p>
<ul class="simple">
<li><p>一个实例的类型，是类</p></li>
<li><p>一个类的类型，是元类</p></li>
<li><p>一个元类的类型，是type</p></li>
</ul>
<p>写个简单的小示例来验证下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MetaPerson</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaPerson</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tom</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Tom</span><span class="p">))</span>
<span class="go">&lt;class &#39;__main__.Person&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Tom</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
<span class="go">&lt;class &#39;__main__.MetaPerson&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Tom</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
</pre></div>
</div>
<p>下面再来看一个稍微完整的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 注意要从type继承</span>
<span class="k">class</span> <span class="nc">BaseClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in BaseClass&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">BaseClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in User&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># in BaseClass</span>

<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s2">&quot;wangbm&quot;</span><span class="p">)</span>
<span class="c1"># in User</span>
</pre></div>
</div>
<p>综上，我们知道了类是元类的实例，所以在创建一个普通类时，其实会走元类的
<code class="docutils literal notranslate"><span class="pre">__new__</span></code>。</p>
<p>同时，我们又知道在类里实现了 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
就可以让这个类的实例变成可调用。</p>
<p>所以在我们对普通类进行实例化时，实际是对一个元类的实例（也就是普通类）进行直接调用，所以会走进元类的
<code class="docutils literal notranslate"><span class="pre">__call__</span></code></p>
<p>在这里可以借助 「单例的实现」举一个例子，你就清楚了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MetaSingleton</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;cls:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;====1====&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_instance&quot;</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;====2====&quot;</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaSingleton</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;====3====&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>验证结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s1">&#39;wangbm1&#39;</span><span class="p">)</span>
<span class="go">cls:User</span>
<span class="go">====1====</span>
<span class="go">====2====</span>
<span class="go">====3====</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s1">&#39;wangbm2&#39;</span><span class="p">)</span>
<span class="go">cls:User</span>
<span class="go">====1====</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span><span class="o">.</span><span class="n">age</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="ow">is</span> <span class="n">u2</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>4. 使用元类的意义<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>正常情况下，我们都不会使用到元类。但是这并不意味着，它不重要。假如某一天，我们需要写一个框架，很有可能就需要你对元类要有进一步的研究。</p>
<p>元类有啥用，用我通俗的理解，元类的作用过程：</p>
<ol class="arabic simple">
<li><p>拦截类的创建</p></li>
<li><p>拦截下后，进行修改</p></li>
<li><p>修改完后，返回修改后的类</p></li>
</ol>
<p>所以，很明显，为什么要用它呢？不要它会怎样？</p>
<p>使用元类，是要对类进行定制修改。使用元类来动态生成元类的实例，而99%的开发人员是不需要动态修改类的，因为这应该是框架才需要考虑的事。</p>
<p>但是，这样说，你一定不会服气，到底元类用来干什么？其实元类的作用就是<code class="docutils literal notranslate"><span class="pre">创建API</span></code>，一个最典型的应用是
<code class="docutils literal notranslate"><span class="pre">Django</span> <span class="pre">ORM</span></code>。</p>
</div>
<div class="section" id="orm">
<h4>5. 元类实战：ORM<a class="headerlink" href="#orm" title="Permalink to this headline">¶</a></h4>
<p>使用过Django ORM的人都知道，有了ORM，使得我们操作数据库，变得异常简单。</p>
<p>ORM的一个类(User)，就对应数据库中的一张表。id,name,email,password
就是字段。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">IntField</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">StrField</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">StrField</span><span class="p">(</span><span class="s1">&#39;email&#39;</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">StrField</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">db_table</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>
</pre></div>
</div>
<p>如果我们要插入一条数据，我们只需这样做</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 实例化成一条记录</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">20180424</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;xiaoming&quot;</span><span class="p">,</span>
         <span class="n">email</span><span class="o">=</span><span class="s2">&quot;xiaoming@163.com&quot;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s2">&quot;abc123&quot;</span><span class="p">)</span>

<span class="c1"># 保存这条记录</span>
<span class="n">u</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>通常用户层面，只需要懂应用，就像上面这样操作就可以了。</p>
<p>但是今天我并不是来教大家如何使用ORM，我们是用来探究ORM内部究竟是如何实现的。我们也可以自己写一个简易的ORM。</p>
<p>从上面的<code class="docutils literal notranslate"><span class="pre">User</span></code>类中，我们看到<code class="docutils literal notranslate"><span class="pre">StrField</span></code>和<code class="docutils literal notranslate"><span class="pre">IntField</span></code>，从字段意思上看，我们很容易看出这代表两个字段类型。字段名分别是<code class="docutils literal notranslate"><span class="pre">id</span></code>,<code class="docutils literal notranslate"><span class="pre">username</span></code>,<code class="docutils literal notranslate"><span class="pre">email</span></code>,<code class="docutils literal notranslate"><span class="pre">password</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">StrField</span></code>和<code class="docutils literal notranslate"><span class="pre">IntField</span></code>在这里的用法，叫做<code class="docutils literal notranslate"><span class="pre">属性描述符</span></code>。
简单来说呢，<code class="docutils literal notranslate"><span class="pre">属性描述符</span></code>可以实现对属性值的类型，范围等一切做约束，意思就是说变量id只能是int类型，变量name只能是str类型，否则将会抛出异常。</p>
<p>那如何实现这两个<code class="docutils literal notranslate"><span class="pre">属性描述符</span></code>呢？请看代码。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numbers</span>

<span class="k">class</span> <span class="nc">Field</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">IntField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;int value need&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">StrField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;string value need&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>我们看到<code class="docutils literal notranslate"><span class="pre">User</span></code>类继承自<code class="docutils literal notranslate"><span class="pre">BaseModel</span></code>，这个<code class="docutils literal notranslate"><span class="pre">BaseModel</span></code>里，定义了数据库操作的各种方法，譬如我们使用的<code class="docutils literal notranslate"><span class="pre">save</span></code>函数，也可以放在这里面的。所以我们就可以来写一下这个<code class="docutils literal notranslate"><span class="pre">BaseModel</span></code>类</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BaseModel</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ModelMetaClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># 这里执行赋值操作，会进行数据描述符的__set__逻辑</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">db_columns</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">db_values</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
            <span class="n">db_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">)))</span>
        <span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;insert into {table} ({columns}) values({values})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_table</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_columns</span><span class="p">),</span>
                <span class="n">values</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_values</span><span class="p">))</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>从<code class="docutils literal notranslate"><span class="pre">BaseModel</span></code>类中，save函数里面有几个新变量。</p>
<ol class="arabic simple">
<li><p>fields: 存放所有的字段属性</p></li>
<li><p>db_table：表名</p></li>
</ol>
<p>我们思考一下这个<code class="docutils literal notranslate"><span class="pre">u</span></code>实例的创建过程：</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">ModelMetaClass</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BaseModel</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">User</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">u</span></code></p>
<p>这里会有几个问题。</p>
<ul class="simple">
<li><p>init的参数是User实例时传入的，所以传入的id是int类型，name是str类型。看起来没啥问题，若是这样，我上面的数据描述符就失效了，不能起约束作用。所以我们希望init接收到的id是IntField类型，name是StrField类型。</p></li>
<li><p>同时，我们希望这些字段属性，能够自动归类到fields变量中。因为，做为BaseModel，它可不是专门为User类服务的，它还要兼容各种各样的表。不同的表，表里有不同数量，不同属性的字段，这些都要能自动类别并归类整理到一起。这是一个ORM框架最基本的。</p></li>
<li><p>我们希望对表名有两种选择，一个是User中若指定Meta信息，比如表名，就以此为表名，若未指定就以类名的小写
做为表名。虽然BaseModel可以直接取到User的db_table属性，但是如果在数据库业务逻辑中，加入这段复杂的逻辑，显然是很不优雅的。</p></li>
</ul>
<p>上面这几个问题，其实都可以通过元类的<code class="docutils literal notranslate"><span class="pre">__new__</span></code>函数来完成。</p>
<p>下面就来看看，如何用元类来解决这些问题呢？请看代码。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ModelMetaClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;BaseModel&quot;</span><span class="p">:</span>
            <span class="c1"># 第一次进入__new__是创建BaseModel类，name=&quot;BaseModel&quot;</span>
            <span class="c1"># 第二次进入__new__是创建User类及其实例，name=&quot;User&quot;</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># 根据属性类型，取出字段</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Field</span><span class="p">)}</span>

        <span class="c1"># 如果User中有指定Meta信息，比如表名，就以此为准</span>
        <span class="c1"># 如果没有指定，就默认以 类名的小写 做为表名，比如User类，表名就是user</span>
        <span class="n">_meta</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Meta&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">db_table</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_meta</span><span class="p">,</span> <span class="s2">&quot;db_table&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">db_table</span> <span class="o">=</span> <span class="n">table</span>

        <span class="c1"># 注意原来由User传递过来的各项参数attrs，最好原模原样的返回，</span>
        <span class="c1"># 如果不返回，有可能下面的数据描述符不起作用</span>
        <span class="c1"># 除此之外，我们可以往里面添加我们自定义的参数</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;db_table&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_table</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="new">
<h4>6. __new__ 有什么用？<a class="headerlink" href="#new" title="Permalink to this headline">¶</a></h4>
<p>在没有元类的情况下，每次创建实例，在先进入 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 之前都会先进入
<code class="docutils literal notranslate"><span class="pre">__new__</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in BaseClass&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in User&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>使用如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s1">&#39;wangbm&#39;</span><span class="p">)</span>
<span class="go">in BaseClass</span>
<span class="go">in User</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;wangbm&#39;</span>
</pre></div>
</div>
<p>在有元类的情况下，每次创建类时，会都先进入 元类的 <code class="docutils literal notranslate"><span class="pre">__new__</span></code>
方法，如果你要对类进行定制，可以在这时做一些手脚。</p>
<p>综上，元类的<code class="docutils literal notranslate"><span class="pre">__new__</span></code>和普通类的不一样：</p>
<ul class="simple">
<li><p>元类的<code class="docutils literal notranslate"><span class="pre">__new__</span></code>
在创建类时就会进入，它可以获取到上层类的一切属性和方法，包括类名，魔法方法。</p></li>
<li><p>而普通类的<code class="docutils literal notranslate"><span class="pre">__new__</span></code>
在实例化时就会进入，它仅能获取到实例化时外界传入的属性。</p></li>
</ul>
</div>
<div class="section" id="id4">
<h4>附录：参考文章<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="http://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p09_meta_programming.html">Python Cookbook -
元编程</a></p></li>
<li><p><a class="reference external" href="http://blog.jobbole.com/21351/">深刻理解Python中的元类</a></p></li>
</ul>
</div>
</div>
<span id="document-c07/c07_11"></span><div class="section" id="descriptor">
<h3>7.11 【进阶】深藏不露的描述符（Descriptor）<a class="headerlink" href="#descriptor" title="Permalink to this headline">¶</a></h3>
<p>在前几节里，有介绍过 property 的用法，property
实现将一系列函数改造成对象属性，并实现参数的访问检查。</p>
<p>很少有人会去深究这里面的原理究竟是什么？实际上对于大部分开发者而言，只要学会应用即可，无需深入探讨。</p>
<p>因此本节内容是 Python
的进阶知识点，若你是新手，请跳过此章节，否则会打击你的学习自信心。</p>
<p>打开天窗说亮话，实际上 property 的内部原理是 <code class="docutils literal notranslate"><span class="pre">描述符</span> <span class="pre">（Descriptor）</span></code></p>
<p>本篇都将带你全面的学习描述符，一起来感受 Python 语言的优雅。</p>
<div class="section" id="id1">
<h4>1. 为什么要使用描述符？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>假想你正在给学校写一个成绩管理系统，并没有太多编码经验的你，可能会这样子写。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">chinese</span><span class="p">,</span> <span class="n">english</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="n">math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span> <span class="o">=</span> <span class="n">chinese</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">english</span> <span class="o">=</span> <span class="n">english</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student: {}, math:{}, chinese: {}, english:{}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">english</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>看起来一切都很合理</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">68</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span>
<span class="go">&lt;Student: 小明, math:76, chinese: 87, english:68&gt;</span>
</pre></div>
</div>
<p>但是程序并不像人那么智能，不会自动根据使用场景判断数据的合法性，如果老师在录入成绩的时候，不小心录入了将成绩录成了负数，或者超过100，程序是无法感知的。</p>
<p>聪明的你，马上在代码中加入了判断逻辑。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">chinese</span><span class="p">,</span> <span class="n">english</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">math</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="n">math</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">chinese</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span> <span class="o">=</span> <span class="n">chinese</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">chinese</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">english</span> <span class="o">=</span> <span class="n">english</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student: {}, math:{}, chinese: {}, english:{}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">english</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>这下程序稍微有点人工智能了，能够自己明辨是非了。</p>
<p><img alt="image0" src="http://image.iswbm.com/20190425221322.png" /></p>
<p>程序是智能了，但在<code class="docutils literal notranslate"><span class="pre">__init__</span></code>里有太多的判断逻辑，很影响代码的可读性。巧的是，你刚好学过
Property
特性，可以很好的应用在这里。于是你将代码修改成如下，代码的可读性瞬间提升了不少</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">chinese</span><span class="p">,</span> <span class="n">english</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="n">math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span> <span class="o">=</span> <span class="n">chinese</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">english</span> <span class="o">=</span> <span class="n">english</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_math</span>

    <span class="nd">@math.setter</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_math</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chinese</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chinese</span>

    <span class="nd">@chinese.setter</span>
    <span class="k">def</span> <span class="nf">chinese</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chinese</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">english</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_english</span>

    <span class="nd">@english.setter</span>
    <span class="k">def</span> <span class="nf">english</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_english</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student: {}, math:{}, chinese: {}, english:{}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">english</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>程序还是一样的人工智能，非常好。</p>
<p><img alt="image1" src="http://image.iswbm.com/20190425221322.png" /></p>
<p>你以为你写的代码，已经非常优秀，无懈可击了。</p>
<p>没想到，人外有天，你的主管看了你的代码后，深深地叹了口气：类里的三个属性，math、chinese、english，都使用了
Property
对属性的合法性进行了有效控制。功能上，没有问题，但就是太啰嗦了，三个变量的合法性逻辑都是一样的，只要大于0，小于100
就可以，代码重复率太高了，这里三个成绩还好，但假设还有地理、生物、历史、化学等十几门的成绩呢，这代码简直没法忍。去了解一下
Python 的描述符吧。</p>
<p>经过主管的指点，你知道了「描述符」这个东西。怀着一颗敬畏之心，你去搜索了下关于
描述符的用法。</p>
<p>其实也很简单，一个实现了 <code class="docutils literal notranslate"><span class="pre">描述符协议</span></code> 的类就是一个描述符。</p>
<p>什么描述符协议：在类里实现了
<code class="docutils literal notranslate"><span class="pre">__get__()</span></code>、<code class="docutils literal notranslate"><span class="pre">__set__()</span></code>、<code class="docutils literal notranslate"><span class="pre">__delete__()</span></code>
其中至少一个方法。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__get__</span></code>：
用于访问属性。它返回属性的值，若属性不存在、不合法等都可以抛出对应的异常。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__set__</span></code>：将在属性分配操作中调用。不会返回任何内容。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__delete__</span></code>：控制删除操作。不会返回内容。</p></li>
</ul>
<p>对描述符有了大概的了解后，你开始重写上面的方法。</p>
<p>如前所述，Score 类是一个描述符，当从 Student 的实例访问
math、chinese、english这三个属性的时候，都会经过 Score
类里的三个特殊的方法。这里的 Score 避免了 使用Property
出现大量的代码无法复用的尴尬。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Score</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Score must be integer&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Valid value must be in [0, 100]&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span>

<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="n">math</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">chinese</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">english</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">chinese</span><span class="p">,</span> <span class="n">english</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="n">math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span> <span class="o">=</span> <span class="n">chinese</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">english</span> <span class="o">=</span> <span class="n">english</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student: {}, math:{}, chinese: {}, english:{}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">english</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>实现的效果和前面的一样，可以对数据的合法性进行有效控制（字段类型、数值区间等）</p>
<p><img alt="image2" src="http://image.iswbm.com/20190425221233.png" /></p>
<p>以上，我举了下具体的实例，从最原始的编码风格到 Property
，最后引出描述符。由浅入深，一步一步带你感受到描述符的优雅之处。</p>
<p>到这里，你需要记住的只有一点，就是描述符给我们带来的编码上的便利，它在实现
<code class="docutils literal notranslate"><span class="pre">保护属性不受修改</span></code>、<code class="docutils literal notranslate"><span class="pre">属性类型检查</span></code>
的基本功能，同时有大大提高代码的复用率。</p>
</div>
<div class="section" id="id2">
<h4>2. 描述符的访问规则<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>描述符分两种：</p>
<ul class="simple">
<li><p>数据描述符：实现了<code class="docutils literal notranslate"><span class="pre">__get__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__set__</span></code> 两种方法的描述符</p></li>
<li><p>非数据描述符：只实现了<code class="docutils literal notranslate"><span class="pre">__get__</span></code> 一种方法的描述符</p></li>
</ul>
<p>你一定会问，他们有什么区别呢？网上的讲解，我看过几个，很多都把一个简单的东西讲得复杂了。</p>
<p>其实就一句话，<strong>数据描述器和非数据描述器的区别在于：它们相对于实例的字典的优先级不同</strong>。</p>
<p>如果实例字典中有与描述符同名的属性，如果描述符是数据描述符，优先使用数据描述符，如果是非数据描述符，优先使用字典中的属性。</p>
<p>这边还是以上节的成绩管理的例子来说明，方便你理解。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 数据描述符</span>
<span class="k">class</span> <span class="nc">DataDes</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;访问数据描述符里的 __get__&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span>

<span class="c1"># 非数据描述符</span>
<span class="k">class</span> <span class="nc">NoDataDes</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;访问非数据描述符里的 __get__&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span>


<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="n">math</span> <span class="o">=</span> <span class="n">DataDes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">chinese</span> <span class="o">=</span> <span class="n">NoDataDes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">chinese</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="n">math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span> <span class="o">=</span> <span class="n">chinese</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;调用 __getattribute__&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student: {}, math:{}, chinese: {},&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">)</span>
</pre></div>
</div>
<p>需要注意的是，math 是数据描述符，而 chinese
是非数据描述符。从下面的验证中，可以看出，当实例属性和数据描述符同名时，会优先访问数据描述符（如下面的math），而当实例属性和非数据描述符同名时，会优先访问实例属性（<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code>）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">std</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="s1">&#39;xm&#39;</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std</span><span class="o">.</span><span class="n">math</span>
<span class="go">调用 __getattribute__</span>
<span class="go">访问数据描述符里的 __get__</span>
<span class="go">88</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std</span><span class="o">.</span><span class="n">chinese</span>
<span class="go">调用 __getattribute__</span>
<span class="go">99</span>
</pre></div>
</div>
<p>讲完了数据描述符和非数据描述符，我们还需要了解的对象属性的查找规律。</p>
<p>当我们对一个实例属性进行访问时，Python 会按 <code class="docutils literal notranslate"><span class="pre">obj.__dict__</span></code> →
<code class="docutils literal notranslate"><span class="pre">type(obj).__dict__</span></code> → <code class="docutils literal notranslate"><span class="pre">type(obj)的父类.__dict__</span></code>
顺序进行查找，如果查找到目标属性并发现是一个描述符，Python
会调用描述符协议来改变默认的控制行为。</p>
</div>
<div class="section" id="property">
<h4>3. 基于描述符如何实现property<a class="headerlink" href="#property" title="Permalink to this headline">¶</a></h4>
<p>经过上面的讲解，我们已经知道如何定义描述符，且明白了描述符是如何工作的。</p>
<p>正常人所见过的描述符的用法就是上面提到的那些，我想说的是那只是描述符协议最常见的应用之一，或许你还不知道，其实有很多
Python 的特性的底层实现机制都是基于 <code class="docutils literal notranslate"><span class="pre">描述符协议</span></code>
的，比如我们熟悉的<code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 、<code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code>
、<code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> 和 <code class="docutils literal notranslate"><span class="pre">super</span></code> 等。</p>
<p>先来说说 <code class="docutils literal notranslate"><span class="pre">property</span></code> 吧。</p>
<p>有了前面的基础，我们知道了 property
的基本用法。这里我直接切入主题，从第一篇的例子里精简了一下。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_math</span>

    <span class="nd">@math.setter</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_math</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>不防再简单回顾一下它的用法，通过property装饰的函数，如例子中的 math
会变成 Student 实例的属性。而对 math 属性赋值会进入 使用 <code class="docutils literal notranslate"><span class="pre">math.setter</span></code>
装饰函数的逻辑代码块。</p>
<p>为什么说 property 底层是基于描述符协议的呢？通过 PyCharm 点击进入
property
的源码，很可惜，只是一份类似文档一样的伪源码，并没有其具体的实现逻辑。</p>
<p>不过，从这份伪源码的魔法函数结构组成，可以大体知道其实现逻辑。</p>
<p>这里我自己通过模仿其函数结构，结合「描述符协议」来自己实现类
<code class="docutils literal notranslate"><span class="pre">property</span></code> 特性。</p>
<p>代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestProperty</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="o">=</span> <span class="n">fget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="o">=</span> <span class="n">fset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="o">=</span> <span class="n">fdel</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in __get__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in __set__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in __delete__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in getter&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">fget</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fset</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in setter&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">,</span> <span class="n">fset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdel</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in deleter&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">,</span> <span class="n">fdel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
</pre></div>
</div>
<p>然后 Student 类，我们也相应改成如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1"># 其实只有这里改变</span>
    <span class="nd">@TestProperty</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_math</span>

    <span class="nd">@math.setter</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_math</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid value must be in [0, 100]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>为了尽量让你少产生一点疑惑，我这里做两点说明：</p>
<ol class="arabic simple">
<li><p>使用<code class="docutils literal notranslate"><span class="pre">TestProperty</span></code>装饰后，<code class="docutils literal notranslate"><span class="pre">math</span></code>
不再是一个函数，而是<code class="docutils literal notranslate"><span class="pre">TestProperty</span></code>
类的一个实例。所以第二个math函数可以使用 <code class="docutils literal notranslate"><span class="pre">math.setter</span></code>
来装饰，本质是调用<code class="docutils literal notranslate"><span class="pre">TestProperty.setter</span></code> 来产生一个新的
<code class="docutils literal notranslate"><span class="pre">TestProperty</span></code> 实例赋值给第二个<code class="docutils literal notranslate"><span class="pre">math</span></code>。</p></li>
<li><p>第一个 <code class="docutils literal notranslate"><span class="pre">math</span></code> 和第二个 <code class="docutils literal notranslate"><span class="pre">math</span></code> 是两个不同 <code class="docutils literal notranslate"><span class="pre">TestProperty</span></code>
实例。但他们都属于同一个描述符类（TestProperty），当对 math
对于赋值时，就会进入 <code class="docutils literal notranslate"><span class="pre">TestProperty.__set__</span></code>，当对math
进行取值里，就会进入
<code class="docutils literal notranslate"><span class="pre">TestProperty.__get__</span></code>。仔细一看，其实最终访问的还是Student实例的
<code class="docutils literal notranslate"><span class="pre">_math</span></code> 属性。</p></li>
</ol>
<p>说了这么多，还是运行一下，更加直观一点。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 运行后，会直接打印这一行，这是在实例化 TestProperty 并赋值给第二个math</span>
<span class="ow">in</span> <span class="n">setter</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="mi">90</span>
<span class="ow">in</span> <span class="fm">__set__</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="n">math</span>
<span class="ow">in</span> <span class="fm">__get__</span>
<span class="mi">90</span>
</pre></div>
</div>
<p>对于以上理解 <code class="docutils literal notranslate"><span class="pre">property</span></code>
的运行原理有困难的同学，请务必参照我上面写的两点说明。如有其他疑问，可以加微信与我进行探讨。</p>
</div>
<div class="section" id="staticmethod">
<h4>4. 基于描述符如何实现staticmethod<a class="headerlink" href="#staticmethod" title="Permalink to this headline">¶</a></h4>
<p>说完了 <code class="docutils literal notranslate"><span class="pre">property</span></code> ，这里再来讲讲 <code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code>
的实现原理。</p>
<p>我这里定义了一个类，用了两种方式来实现静态方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Test</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">myfunc</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

<span class="c1"># 上下两种写法等价</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">myfunc</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
    <span class="c1"># 重点：这就是描述符的体现</span>
    <span class="n">myfunc</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
</pre></div>
</div>
<p>这两种写法是等价的，就好像在 <code class="docutils literal notranslate"><span class="pre">property</span></code>
一样，其实以下两种写法也是等价的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@TestProperty</span>
<span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_math</span>

<span class="n">math</span> <span class="o">=</span> <span class="n">TestProperty</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">math</span><span class="p">)</span>
</pre></div>
</div>
<p>话题还是转回到 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> 这边来吧。</p>
<p>由上面的注释，可以看出 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code>
其实就相当于一个描述符类，而<code class="docutils literal notranslate"><span class="pre">myfunc</span></code> 在此刻变成了一个描述符。关于
<code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> 的实现，你可以参照下面这段我自己写的代码，加以理解。</p>
<p><img alt="image3" src="http://image.iswbm.com/20190519001930.png" /></p>
<p>调用这个方法可以知道，每调用一次，它都会经过描述符类的 <code class="docutils literal notranslate"><span class="pre">__get__</span></code> 。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Test</span><span class="o">.</span><span class="n">myfunc</span><span class="p">()</span>
<span class="go">in staticmethod __get__</span>
<span class="go">hello</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Test</span><span class="p">()</span><span class="o">.</span><span class="n">myfunc</span><span class="p">()</span>
<span class="go">in staticmethod __get__</span>
<span class="go">hello</span>
</pre></div>
</div>
</div>
<div class="section" id="classmethod">
<h4>5. 基于描述符如何实现classmethod<a class="headerlink" href="#classmethod" title="Permalink to this headline">¶</a></h4>
<p>同样的 <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> 也是一样。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">classmethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;in classmethod __get__&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newfunc</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

    <span class="c1"># 重点：这就是描述符的体现</span>
    <span class="n">myfunc</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
</pre></div>
</div>
<p>验证结果如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Test</span><span class="o">.</span><span class="n">myfunc</span><span class="p">()</span>
<span class="go">in classmethod __get__</span>
<span class="go">hello</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Test</span><span class="p">()</span><span class="o">.</span><span class="n">myfunc</span><span class="p">()</span>
<span class="go">in classmethod __get__</span>
<span class="go">hello</span>
</pre></div>
</div>
<p>讲完了 <code class="docutils literal notranslate"><span class="pre">property</span></code>、<code class="docutils literal notranslate"><span class="pre">staticmethod</span></code>和<code class="docutils literal notranslate"><span class="pre">classmethod</span></code> 与
描述符的关系。我想你应该对描述符在 Python 中的应用有了更深的理解。对于
super 的实现原理，就交由你来自己完成。</p>
</div>
<div class="section" id="id3">
<h4>6. 所有实例共享描述符<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>通过以上内容的学习，你是不是觉得自己已经对描述符足够了解了呢？</p>
<p>可在这里，我想说以上的描述符代码都有问题。</p>
<p>问题在哪里呢？请看下面这个例子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Score</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>


<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="n">math</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">chinese</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">english</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student math:{}, chinese:{}, english:{}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">english</span><span class="p">)</span>
</pre></div>
</div>
<p>Student
里没有像前面那样写了构造函数，但是关键不在这儿，没写只是因为没必要写。</p>
<p>然后来看一下会出现什么样的问题呢</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span>
<span class="go">&lt;Student math:0, chinese:0, english:0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="mi">85</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span>
<span class="go">&lt;Student math:85, chinese:0, english:0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std2</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std2</span> <span class="c1"># std2 居然共享了std1 的属性值</span>
<span class="go">&lt;Student math:85, chinese:0, english:0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std2</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std1</span> <span class="c1"># std2 也会改变std1 的属性值</span>
<span class="go">&lt;Student math:100, chinese:0, english:0&gt;</span>
</pre></div>
</div>
<p>从结果上来看，std2 居然共享了 std1
的属性值，只要其中一个实例的变量发生改变，另一个实例的变量也会跟着改变。</p>
<p>探其根因，是由于此时 math，chinese，english 三个全部是类变量，导致 std2
和 std1 在访问 math，chinese，english 这三个变量时，其实都是访问类变量。</p>
<p>问题是不是来了？小明和小强的分数怎么可能是绑定的呢？这很明显与实际业务不符。</p>
<p>使用描述符给我们制造了便利，却无形中给我们带来了麻烦，难道这也是描述符的特性吗？</p>
<p>描述符是个很好用的特性，会出现这个问题，是由于我们之前写的描述符代码都是错误的。</p>
<p>描述符的机制，在我看来，只是抢占了访问顺序，而具体的逻辑却要因地制宜，视情况而定。</p>
<p>如果要把 math，chinese，english
这三个变量变成实例之间相互隔离的属性，应该这么写。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Score</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">subject</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>


<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="n">math</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="s2">&quot;math&quot;</span><span class="p">)</span>
    <span class="n">chinese</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="s2">&quot;chinese&quot;</span><span class="p">)</span>
    <span class="n">english</span> <span class="o">=</span> <span class="n">Score</span><span class="p">(</span><span class="s2">&quot;english&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">chinese</span><span class="p">,</span> <span class="n">english</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">math</span> <span class="o">=</span> <span class="n">math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span> <span class="o">=</span> <span class="n">chinese</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">english</span> <span class="o">=</span> <span class="n">english</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Student math:{}, chinese:{}, english:{}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">math</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinese</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">english</span><span class="p">)</span>
</pre></div>
</div>
<p>引导程序逻辑进入描述符之后，不管你是获取属性，还是设置属性，都是直接作用于
instance 的。</p>
<p><img alt="image4" src="http://image.iswbm.com/20200812085823.png" /></p>
<p>这段代码，你可以仔细和前面的对比一下。</p>
<p>不难看出：</p>
<ul class="simple">
<li><p>之前的错误代码，更像是把描述符当做了存储节点。</p></li>
<li><p>之后的正确代码，则是把描述符直接当做代理，本身不存储值。</p></li>
</ul>
<p>以上便是我对描述符的全部分享，希望能对你有所帮助。</p>
<div class="section" id="id4">
<h5>参考文档<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><p><a class="reference external" href="https://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html#python">Python描述器引导(翻译)</a></p></li>
</ul>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p08"></span><div class="section" id="id1">
<h2>第八章：包与模块<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c08/c08_01"></span><div class="section" id="id1">
<h3>8.1 【基础】什么是包、模块和库？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Python 中除了函数库以外，还有非常多且优秀的第三方库、包、模块。</p>
<p>那么问题就来了，库、模块和包各是什么意思？</p>
<p>它们之间有什么区别呢？今天就一起来学习下。</p>
<div class="section" id="id2">
<h4>1. 模块<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>以 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 为后缀的文件，我们称之为 模块，英文名 Module。</p>
<p>模块让你能够有逻辑地组织你的 Python
代码段，把相关的代码分配到一个模块里能让你的代码更好用，更易懂。</p>
<p>假设现在有一个名为 <code class="docutils literal notranslate"><span class="pre">demo.py</span></code> 的文件，文件内容如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Python编程时光&quot;</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;导入成功&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>直接使用 import 语句就可以导入，导入之后，就可以使用 <code class="docutils literal notranslate"><span class="pre">模块名.变量名</span></code>
的方式访问这个变量。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo</span>
<span class="go">导入成功</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Python编程时光&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在导入模块的时候，有一个非常重要的全局变量需要掌握，那就是 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>
这个变量。</p>
<p>现在把 <code class="docutils literal notranslate"><span class="pre">demo.py</span></code> 的内容改成</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>$ cat demo.py
print(&quot;__name__ 的值为: &quot; + __name__)
</pre></div>
</div>
<ul class="simple">
<li><p>当模块被直接执行时， <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">__main__</span></code></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>$ python demo.py
__name__ 的值为: __main__
</pre></div>
</div>
<ul class="simple">
<li><p>当模块被导入时， <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 的值为 模块名</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo</span>
<span class="go">__name__ 的值为: demo</span>
</pre></div>
</div>
<p>当该模块被导入后，会在当前目录下产生一个 叫做 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code>
的缓存文件夹。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree
.
├── __pycache__
│   └── demo.cpython-39.pyc
└── demo.py
</pre></div>
</div>
<p>这个文件夹有什么用呢？</p>
<p>简单来说，当你导入模块的时候，Python解释器会把模块的代码编译成字节码，并放入
<code class="docutils literal notranslate"><span class="pre">__pycache__</span></code>文件夹中。</p>
<p>这样以后再次运行的话，如果被调用的模块未发生改变，那就直接跳过编译这一步，直接去<code class="docutils literal notranslate"><span class="pre">__pycache__</span></code>文件夹中去运行相关的
*.pyc 文件，大大缩短了项目运行前的准备时间。</p>
</div>
<div class="section" id="id3">
<h4>2. 包<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>在早一点的 Python 版本（Python 3.3 之前）中，如果一个文件夹下有一个
<code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件，那我们就称之为包，英文名 Package。</p>
<p>在后来的 Python 版本（Python 3.3
开始）中，就没有这个要求了，只要是文件夹就可以当做包，我们称之为空间命名包，为做区分，我把上面那种包称之为
传统包。</p>
<p>考虑到很多人其实并不需要接触到空间命名包，所以我将空间命名包的内容单独放在一节里，为选读章节。</p>
<p>今天这节里主要讲讲传统包的内容。</p>
<p>传统包里的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
可以为空文件，但一定要有该文件，它是包的标志性文件，在需要情况下可以在里面进行一些包的初始化工作。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree
.
└── demo
    ├── __init__.py
    ├── bar.py
    └── foo.py
</pre></div>
</div>
<p>一个包里可以有多个模块，比如上面的 <code class="docutils literal notranslate"><span class="pre">foo.py</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bar.py</span></code> 都属于 demo
模块。</p>
<p>如果要使用这些模块，就需要这样导入</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.foo</span>
<span class="go">成功导入 foo.py</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.bar</span>
<span class="go">成功导入 bar.py</span>
</pre></div>
</div>
<p>或者这样</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">demo</span> <span class="kn">import</span> <span class="n">foo</span>
<span class="go">成功导入 foo.py</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">demo</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="go">成功导入 bar.py</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. 库<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Python 库是指一定功能的代码集合，通常认为他是一个完整的项目打包。</p>
<p>库-&gt;包-&gt;模块，是从大到小的层级关系！</p>
<ul class="simple">
<li><p>库：一个库可能由多个包和模块组成</p></li>
<li><p>包：一个包可能由多个模块组成</p></li>
<li><p>模块：一堆函数、类、变量的集合</p></li>
</ul>
</div>
</div>
<span id="document-c08/c08_02"></span><div class="section" id="id1">
<h3>8.2 【基础】安装第三方包的八种方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="easy-install">
<h4>1. 使用 easy_install<a class="headerlink" href="#easy-install" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">easy_install</span></code>
这应该是最古老的包安装方式了，目前基本没有人使用了。下面是
<code class="docutils literal notranslate"><span class="pre">easy_install</span></code> 的一些安装示例</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 通过包名，从PyPI寻找最新版本，自动下载、编译、安装</span>
$ easy_install pkg_name

<span class="c1"># 通过包名从指定下载页寻找链接来安装或升级包</span>
$ easy_install -f http://pythonpaste.org/package_index.html

<span class="c1"># 指定线上的包地址安装</span>
$ easy_install http://example.com/path/to/MyPackage-1.2.3.tgz

<span class="c1"># 从本地的 .egg 文件安装</span>
$ easy_install xxx.egg
</pre></div>
</div>
</div>
<div class="section" id="pip-install">
<h4>2. 使用 pip install<a class="headerlink" href="#pip-install" title="Permalink to this headline">¶</a></h4>
<p>pip 是最主流的包管理方案，使用 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">xxx</span></code> 就可以从 PYPI
上搜索并安装 <code class="docutils literal notranslate"><span class="pre">xxx</span></code> （如果该包存在的话）。</p>
<p>下面仅列出一些常用的 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span></code>的安装示例</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install requests

<span class="c1"># 前提你得保证你已经下载 pkg 包到 /local/wheels 目录下</span>
$ pip install --no-index --find-links<span class="o">=</span>/local/wheels pkg

<span class="c1"># 所安装的包的版本为 2.1.2</span>
$ pip install <span class="nv">pkg</span><span class="o">==</span><span class="m">2</span>.1.2

<span class="c1"># 所安装的包必须大于等于 2.1.2</span>
$ pip install pkg&gt;<span class="o">=</span><span class="m">2</span>.1.2

<span class="c1"># 所安装的包必须小于等于 2.1.2</span>
$ pip install pkg&lt;<span class="o">=</span><span class="m">2</span>.1.2
</pre></div>
</div>
<p>更多 pip 的使用方法，可参考本系列教程后面的文章，介绍得非常清楚：<a class="reference external" href="https://python.iswbm.com/en/latest/c08/c08_08.html">8.8
pip
的详细使用指南</a></p>
</div>
<div class="section" id="pipx">
<h4>3. 使用 pipx<a class="headerlink" href="#pipx" title="Permalink to this headline">¶</a></h4>
<p>pipx 是一个专门用于安装和管理 cli 应用程序的工具，使用它安装的 Python
包会单独安装到一个全新的独有虚拟环境。</p>
<p>由于它是一个第三方工具，因此在使用它之前，需要先安装</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pip install --user pipx
$ python3 -m userpath append ~/.local/bin
Success!
</pre></div>
</div>
<p>安装就可以使用 pipx 安装cli 工具了。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建虚拟环境并安装包</span>
$ pipx install pkg
</pre></div>
</div>
<p>更多 pipx
的使用方法，可参考本系列教程后面的文章，介绍得非常清楚：<a class="reference external" href="https://python.iswbm.com/en/latest/c12/c12_04.html">12.4 pipx
安装程序的使用指南</a></p>
</div>
<div class="section" id="setup-py">
<h4>4. 使用 setup.py<a class="headerlink" href="#setup-py" title="Permalink to this headline">¶</a></h4>
<p>如果你有编写 setup.py 文件，可以使用如下命令直接安装</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 使用源码直接安装
$ python setup.py install
</pre></div>
</div>
</div>
<div class="section" id="yum">
<h4>5. 使用 yum<a class="headerlink" href="#yum" title="Permalink to this headline">¶</a></h4>
<p>Python 包在使用 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
构建的时候（具体内容可阅读后面的内容：<a class="reference external" href="https://python.iswbm.com/en/latest/c08/c08_15.html">8.15 超详细讲解 setup.py
的编写</a>），对于包的发布格式有多种选项，其中有一个选项是
<code class="docutils literal notranslate"><span class="pre">bdist_rpm</span></code>，以这个选项发布出来的包是 <code class="docutils literal notranslate"><span class="pre">rpm</span></code> 的包格式。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 发布 rpm 包</span>
$ python setup.py bdist_rpm
</pre></div>
</div>
<p>对于<code class="docutils literal notranslate"><span class="pre">rpm</span></code> 这种格式，你需要使用 <code class="docutils literal notranslate"><span class="pre">yum</span> <span class="pre">install</span> <span class="pre">xxx</span></code> 或者
<code class="docutils literal notranslate"><span class="pre">rpm</span> <span class="pre">install</span> <span class="pre">xxx</span></code> 来安装。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用 yum 安装</span>
$ yum install pkg

<span class="c1"># 使用 rpm 安装</span>
$ rpm -ivh pkg
</pre></div>
</div>
</div>
<div class="section" id="pipenv">
<h4>6. 使用 pipenv<a class="headerlink" href="#pipenv" title="Permalink to this headline">¶</a></h4>
<p>如果你在使用 pipenv
创建的虚拟环境中，可以使用下面这条命令把包安装到虚拟环境中</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipenv install pkg
</pre></div>
</div>
</div>
<div class="section" id="poetry">
<h4>7. 使用 poetry<a class="headerlink" href="#poetry" title="Permalink to this headline">¶</a></h4>
<p>如果你有使用 poetry 管理项目依赖，那么可以使用下面这条命令安装包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 直接安装包</span>
$ poetry add pkg

<span class="c1"># 指定为开发依赖</span>
$ poetry add pytest --dev
</pre></div>
</div>
</div>
<div class="section" id="curl">
<h4>8. 使用 curl + 管道<a class="headerlink" href="#curl" title="Permalink to this headline">¶</a></h4>
<p>有一些第三方工具包提供的安装方法，是直接使用 curl
配置管道来安装，比如上面提到的 poetry 就可以用这种方法安装。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py <span class="p">|</span> python
</pre></div>
</div>
</div>
</div>
<span id="document-c08/c08_03"></span><div class="section" id="id1">
<h3>8.3 【基础】导入单元的构成<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>导入单元有多种，可以是模块、包及变量等。</p>
<p>对于这些基础的概念，对于新手还是有必要介绍一下它们的区别。</p>
<p><strong>模块</strong>：类似 *.py，<em>.pyc， *.pyd ，</em>.so，<a href="#id2"><span class="problematic" id="id3">*</span></a>.dll 这样的文件，是
Python 代码载体的最小单元。</p>
<p><strong>包</strong> 还可以细分为两种:</p>
<ul class="simple">
<li><p>Regular packages：是一个带有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
文件的文件夹，此文件夹下可包含其他子包，或者模块</p></li>
<li><p>Namespace packages</p></li>
</ul>
<p>关于 Namespace
packages，有的人会比较陌生，我这里摘抄官方文档的一段说明来解释一下。</p>
<p>Namespace packages 是由多个 部分 构成的，每个部分为父包增加一个子包。
各个部分可能处于文件系统的不同位置。 部分也可能处于 zip
文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。
命名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。</p>
<p>命名空间包的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性不使用普通的列表。
而是使用定制的可迭代类型，如果其父包的路径 (或者最高层级包的 sys.path)
发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对包部分的搜索。</p>
<p>命名空间包没有 <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> 文件。
实际上，在导入搜索期间可能找到多个 parent
目录，每个都由不同的部分所提供。 因此 parent/one 的物理位置不一定与
parent/two 相邻。 在这种情况下，Python 将为顶级的 parent
包创建一个命名空间包，无论是它本身还是它的某个子包被导入。</p>
</div>
<span id="document-c08/c08_04"></span><div class="section" id="id1">
<h3>8.4 【基础】导入包的标准写法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>当我们 import 导入模块或包时，Python 提供两种导入方式：</p>
<ul class="simple">
<li><p>相对导入（relative import ）：from . import B 或 from ..A import
B，其中.表示当前模块，..表示上层模块</p></li>
<li><p>绝对导入（absolute import）：import foo.bar 或者 from foo import bar</p></li>
</ul>
<p>你可以根据实际需要进行选择，但有必要说明的是，在早期的版本（ Python2.6
之前），Python 默认使用的相对导入。而后来的版本中（ Python2.6
之后），都以绝对导入为默认使用的导入方式。</p>
<p>使用绝对路径和相对路径各有利弊：</p>
<ul class="simple">
<li><p>当你在开发维护自己的项目时，应当使用相对路径导入，这样可以避免硬编码带来的麻烦。</p></li>
<li><p>而使用绝对路径，会让你模块导入结构更加清晰，而且也避免了重名的包冲突而导入错误。</p></li>
</ul>
<p>在 PEP8 中对模块的导入提出了要求，遵守
PEP8规范能让你的代码更具有可读性，我这边也列一下：</p>
<ul class="simple">
<li><p>import 语句应当分行书写</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># bad</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">sys</span>

<span class="c1"># good</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
</pre></div>
</div>
<ul class="simple">
<li><p>import语句应当使用absolute import</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># bad</span>
<span class="kn">from</span> <span class="nn">..bar</span> <span class="kn">import</span>  <span class="n">Bar</span>

<span class="c1"># good</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">test</span>
</pre></div>
</div>
<ul class="simple">
<li><p>import语句应当放在文件头部，置于模块说明及docstring之后，全局变量之前</p></li>
<li><p>import语句应该按照顺序排列，每组之间用一个空格分隔，按照内置模块，第三方模块，自己所写的模块调用顺序，同时每组内部按照字母表顺序排列</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 内置模块</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># 第三方模块</span>
<span class="kn">import</span> <span class="nn">flask</span>

<span class="c1"># 本地模块</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">bar</span>
</pre></div>
</div>
</div>
<span id="document-c08/c08_05"></span><div class="section" id="id1">
<h3>8.5 【进阶】常规包与空间命名包<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 常规包<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在 Python 3.3 之前或者说 Python 2
中，一个包想要被导入使用，那么该包内必须要有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
文件，这个文件是 Python 识别一个文件夹是否是一个 Python 的重要标志。</p>
<p>举个例子，现在有如下的目录树，demo 及子文件夹 foo 和 bar 下都有
<code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree demo/
demo/
├── bar
│   └── __init__.py
├── foo
│   └── __init__.py
└── __init__.py
</pre></div>
</div>
<p>在该目录下进入 Python Console 模式，然后就可以正常导入了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.foo</span>
</pre></div>
</div>
<p>如果此时我把 demo 目录下的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 删除</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>$ tree demo/
demo/
├── bar
│   └── __init__.py
└── foo
    └── __init__.py
</pre></div>
</div>
<p>再导入就会报错。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named demo</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 命名空间包<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>在 Python 3.3 之后（<a class="reference external" href="https://www.python.org/dev/peps/pep-0420/">PEP
420</a>），即使一个文件夹中没有定义
<code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>，也是可以被导入的，只不过它不是以 Python
包的形式导入，而是以命名空间包 (Namespace package)
的形式被导入，而这一特性是在 Python 3.3 被引入的。</p>
<p>比如还是上面的目录结构：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree demo/
demo/
├── bar
│   └── __init__.py
└── foo
    └── __init__.py
</pre></div>
</div>
<p>在 Python 3 下进入 Python Console 模式，发现导入是正常的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 查看一下，发现 demo 不再是一个常规包了，而是一个
namespace package</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span>
<span class="go">&lt;module &#39;demo&#39; (namespace)&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">_NamespacePath([&#39;/root/python/demo&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. 空间命名包的好处<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>利用命名空间包这个技术，可以用来导入目录分散的代码。</p>
<p>比如有如下的目录树</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree
.
├── xc-pkg
│   └── demo
│       └── foo
│           └── __init__.py
└── xm-pkg
    └── demo
        └── bar
            └── __init__.py
</pre></div>
</div>
<p>在这 <code class="docutils literal notranslate"><span class="pre">xc-pkg</span></code> 和 <code class="docutils literal notranslate"><span class="pre">xm-pkg</span></code> 这两个目录里，都有着共同的命名空间
demo。这时候再导入这两个包的时候，发现这两个包被合并到一起了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;xm-pkg&#39;</span><span class="p">,</span> <span class="s1">&#39;xc-pkg&#39;</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">demo.bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span>
<span class="go">&lt;module &#39;demo&#39; (namespace)&gt;</span>
</pre></div>
</div>
<p>在这里工作的机制被称为<code class="docutils literal notranslate"><span class="pre">命名空间包</span></code>的一个特征。从本质上讲，<code class="docutils literal notranslate"><span class="pre">命名空间包</span></code>是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。</p>
<p><code class="docutils literal notranslate"><span class="pre">命名空间包</span></code>的关键是确保顶级目录中没有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
文件来作为共同的命名空间。缺失 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其
<code class="docutils literal notranslate"><span class="pre">__path__</span></code> 变量中。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">_NamespacePath([&#39;xm-pkg/demo&#39;, &#39;xc-pkg/demo&#39;])</span>
</pre></div>
</div>
<p>一个包是否被作为一个包命名空间的主要方法是检查其 <code class="docutils literal notranslate"><span class="pre">__file__</span></code>
属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的 namespace
这个词体现出来。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span>
<span class="go">&lt;module &#39;demo&#39; (namespace)&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="o">.</span><span class="vm">__file__</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">module &#39;demo&#39; has no attribute &#39;__file__&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c08/c08_06"></span><div class="section" id="id1">
<h3>8.6 【进阶】花式导包的八种方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="import">
<h4>1. 直接 import<a class="headerlink" href="#import" title="Permalink to this headline">¶</a></h4>
<p>人尽皆知的方法，直接导入即可</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
<p>与此类似的还有，不再细讲</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="o">...</span>
<span class="kn">import</span> <span class="o">...</span> <span class="k">as</span> <span class="o">...</span>
<span class="kn">from</span> <span class="nn">...</span> <span class="kn">import</span> <span class="o">...</span>
<span class="kn">from</span> <span class="nn">...</span> <span class="kn">import</span> <span class="o">...</span> <span class="k">as</span> <span class="o">...</span>
</pre></div>
</div>
<p>一般情况下，使用 <code class="docutils literal notranslate"><span class="pre">import</span></code> 语句导入模块已经够用的。</p>
<p>但是在一些特殊场景中，可能还需要其他的导入方式。</p>
<p>下面我会一一地给你介绍。</p>
</div>
<div class="section" id="id2">
<h4>2. 使用 __import__<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">__import__</span></code> 函数可用于导入模块，import 语句也会调用函数。其定义为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">__import__</span><span class="p">(</span><span class="n">name</span><span class="p">[,</span> <span class="nb">globals</span><span class="p">[,</span> <span class="nb">locals</span><span class="p">[,</span> <span class="n">fromlist</span><span class="p">[,</span> <span class="n">level</span><span class="p">]]]])</span>
</pre></div>
</div>
<p>参数介绍：</p>
<ul class="simple">
<li><p>name (required): 被加载 module 的名称</p></li>
<li><p>globals (optional): 包含全局变量的字典，该选项很少使用，采用默认值
global()</p></li>
<li><p>locals (optional):
包含局部变量的字典，内部标准实现未用到该变量，采用默认值 - local()</p></li>
<li><p>fromlist (Optional): 被导入的 submodule 名称</p></li>
<li><p>level (Optional): 导入路径选项，Python 2 中默认为 -1，表示同时支持
absolute import 和 relative import。Python 3 中默认为 0，表示仅支持
absolute import。如果大于 0，则表示相对导入的父目录的级数，即 1
类似于 ‘.’，2 类似于 ‘..’。</p></li>
</ul>
<p>使用示例如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
<p>如果要实现 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">xx</span> <span class="pre">as</span> <span class="pre">yy</span></code> 的效果，只要修改左值即可</p>
<p>如下示例，等价于 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">os</span> <span class="pre">as</span> <span class="pre">myos</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
<p>上面说过的 <code class="docutils literal notranslate"><span class="pre">__import__</span></code>
是一个内建函数，既然是内建函数的话，那么这个内建函数必将存在于
<code class="docutils literal notranslate"><span class="pre">__buildins__</span></code> 中，因此我们还可以这样导入 os 的模块：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">__builtins__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;__import__&#39;</span><span class="p">](</span><span class="s1">&#39;os&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="importlib">
<h4>3. 使用 importlib 模块<a class="headerlink" href="#importlib" title="Permalink to this headline">¶</a></h4>
<p>importlib 是 Python 中的一个标准库，importlib 能提供的功能非常全面。</p>
<p>它的简单示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span><span class="o">=</span><span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;os&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
<p>如果要实现 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">xx</span> <span class="pre">as</span> <span class="pre">yy</span></code>效果，可以这样</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;os&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="imp">
<h4>4. 使用 imp 模块<a class="headerlink" href="#imp" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">imp</span></code> 模块提供了一些 import
语句内部实现的接口。例如模块查找（find_module）、模块加载（load_module）等等（模块的导入过程会包含模块查找、加载、缓存等步骤）。可以用该模块来简单实现内建的
<code class="docutils literal notranslate"><span class="pre">__import__</span></code> 函数功能：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="s1">&#39;sep&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span>
<span class="go">&lt;module &#39;sep&#39; from &#39;/usr/lib64/python2.7/os.pyc&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myos</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
<p>从 python 3 开始，内建的 reload 函数被移到了 imp 模块中。而从 Python 3.4
开始，imp 模块被否决，不再建议使用，其包含的功能被移到了 importlib
模块下。即从 Python 3.4 开始，importlib 模块是之前 imp 模块和 importlib
模块的合集。</p>
</div>
<div class="section" id="execfile">
<h4>5. 使用 execfile<a class="headerlink" href="#execfile" title="Permalink to this headline">¶</a></h4>
<p>在 Python 2 中有一个 execfile 函数，利用它可以用来执行一个文件。</p>
<p>语法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">execfile</span><span class="p">(</span><span class="n">filename</span><span class="p">[,</span> <span class="nb">globals</span><span class="p">[,</span> <span class="nb">locals</span><span class="p">]])</span>
</pre></div>
</div>
<p>参数有这么几个：</p>
<ul class="simple">
<li><p>filename：文件名。</p></li>
<li><p>globals：变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p></li>
<li><p>locals：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">execfile</span><span class="p">(</span><span class="s2">&quot;/usr/lib64/python2.7/os.py&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="exec">
<h4>6. 使用 exec 执行<a class="headerlink" href="#exec" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">execfile</span></code> 只能在 Python2 中使用，Python 3.x 里已经删除了这个函数。</p>
<p>但是原理值得借鉴，你可以使用 open … read 读取文件内容，然后再用 exec
去执行模块。</p>
<p>示例如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/usr/lib64/python2.7/os.py&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcwd</span><span class="p">()</span>
<span class="go">&#39;/home/wangbm&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="import-from-github-com">
<h4>7. import_from_github_com<a class="headerlink" href="#import-from-github-com" title="Permalink to this headline">¶</a></h4>
<p>有一个包叫做
<strong>import_from_github_com</strong>，从名字上很容易得知，它是一个可以从 github
下载安装并导入的包。为了使用它，你需要做的就是按照如下命令使用pip
先安装它。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pip install import_from_github_com
</pre></div>
</div>
<p>这个包使用了PEP
302中新的引入钩子，允许你可以从github上引入包。这个包实际做的就是安装这个包并将它添加到本地。你需要
Python 3.2 或者更高的版本，并且 git 和 pip 都已经安装才能使用这个包。</p>
<p>pip 要保证是较新版本，如果不是请执行如下命令进行升级。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pip install --upgrade pip
</pre></div>
</div>
<p>确保环境 ok 后，你就可以在 Python shell 中使用 import_from_github_com</p>
<p>示例如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">github_com.zzzeek</span> <span class="kn">import</span> <span class="n">sqlalchemy</span>
<span class="go">Collecting git+https://github.com/zzzeek/sqlalchemy</span>
<span class="go">Cloning https://github.com/zzzeek/sqlalchemy to /tmp/pip-acfv7t06-build</span>
<span class="go">Installing collected packages: SQLAlchemy</span>
<span class="go">Running setup.py install for SQLAlchemy ... done</span>
<span class="go">Successfully installed SQLAlchemy-1.1.0b1.dev0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">locals</span><span class="p">()</span>
<span class="go">{&#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;__spec__&#39;: None,</span>
<span class="go">&#39;__package__&#39;: None, &#39;__doc__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;,</span>
<span class="go">&#39;sqlalchemy&#39;: &lt;module &#39;sqlalchemy&#39; from &#39;/usr/local/lib/python3.5/site-packages/\</span>
<span class="go">sqlalchemy/__init__.py&#39;&gt;,</span>
<span class="go">&#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>看了
import_from_github_com的源码后，你会注意到它并没有使用importlib。实际上，它的原理就是使用
pip
来安装那些没有安装的包，然后使用Python的<code class="docutils literal notranslate"><span class="pre">__import__()</span></code>函数来引入新安装的模块。</p>
</div>
<div class="section" id="id3">
<h4>8. 远程导入模块<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>在后面有一篇文章里，深入剖析了导入模块的内部原理，并在最后手动实现了从远程服务器上读取模块内容，并在本地成功将模块导入的导入器。</p>
<p>具体内容非常的多，你可以点击这个<a class="reference external" href="http://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&amp;mid=2247484838&amp;idx=1&amp;sn=1e6fbf5d7546902c6965c60383f7b639&amp;chksm=e8866544dff1ec52e01b6c9a982dfa150b8e34ad472acca35201373dc51dadb5a8630870982a&amp;scene=21#wechat_redirect">链接</a>进行深入学习。</p>
<p>示例代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 新建一个 py 文件（my_importer.py），内容如下</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">urllib.request</span> <span class="kn">as</span> <span class="nn">urllib2</span>

<span class="k">class</span> <span class="nc">UrlMetaFinder</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MetaPathFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>


    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 不是原定义的url就直接返回不存在</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="n">path</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">UrlMetaLoader</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">loader</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">UrlMetaLoader</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">SourceLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">+</span> <span class="n">fullname</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>

<span class="k">def</span> <span class="nf">install_meta</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">UrlMetaFinder</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finder</span><span class="p">)</span>
</pre></div>
</div>
<p>并且在远程服务器上开启 http
服务（为了方便，我仅在本地进行演示），并且手动编辑一个名为 my_info 的
python 文件，如果后面导入成功会打印 <code class="docutils literal notranslate"><span class="pre">ok</span></code>。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mkdir httpserver <span class="o">&amp;&amp;</span> <span class="nb">cd</span> httpserver
$ cat&gt;my_info.py&lt;EOF
<span class="nv">name</span><span class="o">=</span><span class="s1">&#39;wangbm&#39;</span>
print<span class="o">(</span><span class="s1">&#39;ok&#39;</span><span class="o">)</span>
EOF
$ cat my_info.py
<span class="nv">name</span><span class="o">=</span><span class="s1">&#39;wangbm&#39;</span>
print<span class="o">(</span><span class="s1">&#39;ok&#39;</span><span class="o">)</span>
$
$ python3 -m http.server <span class="m">12800</span>
Serving HTTP on <span class="m">0</span>.0.0.0 port <span class="m">12800</span> <span class="o">(</span>http://0.0.0.0:12800/<span class="o">)</span> ...
...
</pre></div>
</div>
<p>一切准备好，验证开始。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">my_importer</span> <span class="kn">import</span> <span class="n">install_meta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">install_meta</span><span class="p">(</span><span class="s1">&#39;http://localhost:12800/&#39;</span><span class="p">)</span> <span class="c1"># 往 sys.meta_path 注册 finder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">my_info</span>  <span class="c1"># 打印ok，说明导入成功</span>
<span class="go">ok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_info</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># 验证可以取得到变量</span>
<span class="go">&#39;wangbm&#39;</span>
</pre></div>
</div>
<p>好了，8 种方法都给大家介绍完毕，对于普通开发者来说，其实只要掌握 import
这种方法足够了，而对于那些想要自己开发框架的人来说，深入学习<code class="docutils literal notranslate"><span class="pre">__import__</span></code>以及
importlib 是非常有必要的。</p>
</div>
</div>
<span id="document-c08/c08_07"></span><div class="section" id="id1">
<h3>8.7 【进阶】包导入的三个冷门知识点<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="all">
<h4>1. 使用 __all__ 控制可被导入的变量<a class="headerlink" href="#all" title="Permalink to this headline">¶</a></h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 默认情况下会导入 module
里的所有变量，若你只想从模块中导入其中几个变量，可以在 module 中使用
<code class="docutils literal notranslate"><span class="pre">__all__</span></code> 来控制想要被其他模块导入的变量。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># profile.py</span>
<span class="n">name</span><span class="o">=</span><span class="s1">&#39;小明&#39;</span>
<span class="n">age</span><span class="o">=</span><span class="mi">18</span>

<span class="n">__all__</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>打开 python console 验证一下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">profile</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="go">小明</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NameError</span>: <span class="n">name &#39;age&#39; is not defined</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__all__</span></code> 仅对于使用<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 这种情况适用。</p>
<p>它经常在一个包的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 中出现。</p>
</div>
<div class="section" id="id2">
<h4>2. 命名空间包的神奇之处<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>命名空间包，一个陌生的名字。</p>
<p>与我们熟悉的常规包不同的是，它没有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件。</p>
<p>更为特殊的是，它可以跨空间地将两个不相邻的子包，合并成一个虚拟机的包，我们将其称之为
<code class="docutils literal notranslate"><span class="pre">命名空间包</span></code>。</p>
<p>例如，一个项目的部分代码布局如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">-</span><span class="n">package</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">/</span>
        <span class="n">blah</span><span class="o">.</span><span class="n">py</span>

<span class="n">bar</span><span class="o">-</span><span class="n">package</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">/</span>
        <span class="n">grok</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有__init__.py文件。</p>
<p>让我们看看，如果将foo-package和bar-package都加到python模块路径并尝试导入会发生什么？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;foo-package&#39;</span><span class="p">,</span> <span class="s1">&#39;bar-package&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.blah</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.grok</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当一个包为命名空间包时，他就不再和常规包一样具有 <code class="docutils literal notranslate"><span class="pre">__file_</span></code>
属性，取而代之的是 <code class="docutils literal notranslate"><span class="pre">__path__</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;foo-package&#39;</span><span class="p">,</span> <span class="s1">&#39;bar-package&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.blah</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.grok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">_NamespacePath([&#39;foo-package/spam&#39;, &#39;bar-package/spam&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="vm">__file__</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;module&#39; object has no attribute &#39;__file__&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 模块重载中的一个坑<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>由于有 sys.modules
的存在，当你导入一个已导入的模块时，实际上是没有效果的。</p>
<p>为了达到模块的重载，有的人会将已导入的包从 sys.modules 中移除后再导入</p>
<p>就像下面这样子</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">foo.bar</span>
<span class="go">successful to be imported</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">foo.bar</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">]</span>
<span class="go">&lt;module &#39;foo.bar&#39; from &#39;/Users/MING/Code/Python/foo/bar.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">foo.bar</span>
<span class="go">successful to be imported</span>
</pre></div>
</div>
<p>上面的例子里我使用的是<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo.bar</span></code> ，如果你使用的是
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">bar</span></code> 这种导入形式，会发现重载是同样是无效的。</p>
<p>这应该算是一个小坑，不知道的人，会掉入坑中爬不出来。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">foo.bar</span>
<span class="go">successful to be imported</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">foo.bar</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>因此，在生产环境中可能需要避免重新加载模块。而在调试模式中，它会提供一定的便利，但你要知道这个重载的弊端，以免掉入坑里。</p>
</div>
</div>
<span id="document-c08/c08_08"></span><div class="section" id="pip">
<h3>8.8 【基础】pip 的超全使用指南<a class="headerlink" href="#pip" title="Permalink to this headline">¶</a></h3>
<p>所有的 Python 开发者都清楚，Python
之所以如此受欢迎，能够在众多高级语言中，脱颖而出，除了语法简单，上手容易之外，更多还要归功于
Python 生态的完备，有数以万计的 Python 爱好者愿意以 Python
为基础封装出各种有利于开发的第三方工具包。</p>
<p>这才使用我们能够以最快的速度开发出一个满足基本需要的项目，而不是每次都重复造轮子。</p>
<p>Python
从1991年诞生到现在，已经过去28个年头了，这其间产生了数以万计的第三方包，且每个包都会不断更新，会有越来越多的版本。</p>
<p>当你在一个复杂的项目环境中，如果没有一个有效的依赖包管理方案，项目的维护将会是一个大问题。</p>
<p>pip 是官方推荐的包管理工具，在大多数开发者眼里，pip 几乎是 Python
的标配。</p>
<p>当然也有其他的包管理工具</p>
<ul class="simple">
<li><p><strong>distutils</strong>：仅用于打包和安装，严格来讲不算是包管理工具</p></li>
<li><p><strong>setuptools</strong>：distutils的增强版，扩展了distutils，提供更多的功能，引入包依赖的管理，easy_install就是它的一个命令行工具，引入了
egg 的文件格式。</p></li>
<li><p><strong>Pipenv</strong>：一个集依赖包管理（pip）及虚拟环境管理（virtualenv）的工具</p></li>
<li><p>还有其他的，这里不一一列出。</p></li>
</ul>
<p>今天的主角是 pip
，大家肯定不会陌生。但我相信不少人，只是熟悉几个常用的用法，而对于其他几个低频且实用的用法，却知之甚少，这两天，我查阅官方文档，把这些用法整理了一下，应该是网络上比较全的介绍。</p>
<div class="section" id="id1">
<h4>1. 查询软件包<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>查询当前环境安装的所有软件包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip list
</pre></div>
</div>
<p>查询 pypi 上含有某名字的包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip search pkg
</pre></div>
</div>
<p>查询当前环境中可升级的包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip list --outdated
</pre></div>
</div>
<p>查询一个包的详细内容</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip show pkg
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 下载软件包<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在不安装软件包的情况下下载软件包到本地</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip download --destination-directory /local/wheels -r requirements.txt
</pre></div>
</div>
<p>下载完，总归是要安装的，可以指定这个目录中安装软件包，而不从 pypi
上安装。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install --no-index --find-links<span class="o">=</span>/local/wheels -r requirements.txt
</pre></div>
</div>
<p>当然你也从你下载的包中，自己构建生成 wheel 文件</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install wheel
$ pip wheel --wheel-dir<span class="o">=</span>/local/wheels -r requirements.txt
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 安装软件包<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">&lt;pkg&gt;</span></code> 可以很方便地从 pypi 上搜索下载并安装 python
包。</p>
<p>如下所示</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install requests
</pre></div>
</div>
<p>这是安装包的基本格式，我们也可以为其添加更多参数来实现不同的效果。</p>
<div class="section" id="pypi">
<h5>3.1 只从本地安装，而不从 pypi 安装<a class="headerlink" href="#pypi" title="Permalink to this headline">¶</a></h5>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 前提你得保证你已经下载 pkg 包到 /local/wheels 目录下</span>
$ pip install --no-index --find-links<span class="o">=</span>/local/wheels pkg
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h5>3.2 限定版本进行软件包安装<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>以下三种，对单个 python 包的版本进行了约束</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 所安装的包的版本为 2.1.2</span>
$ pip install <span class="nv">pkg</span><span class="o">==</span><span class="m">2</span>.1.2

<span class="c1"># 所安装的包必须大于等于 2.1.2</span>
$ pip install pkg&gt;<span class="o">=</span><span class="m">2</span>.1.2

<span class="c1"># 所安装的包必须小于等于 2.1.2</span>
$ pip install pkg&lt;<span class="o">=</span><span class="m">2</span>.1.2
</pre></div>
</div>
<p>以下命令用于管理/控制整个 python 环境的包版本</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 导出依赖包列表</span>
pip freeze &gt;requirements.txt

<span class="c1"># 从依赖包列表中安装</span>
pip install -r requirements.txt

<span class="c1"># 确保当前环境软件包的版本(并不确保安装)</span>
pip install -c constraints.txt
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>3.3 限制不使用二进制包安装<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>由于默认情况下，wheel 包的平台是运行 pip download 命令
的平台，所以可能出现平台不适配的情况。</p>
<p>比如在 MacOS 系统下得到的 pymongo-2.8-cp27-none-macosx_10_10_intel.whl
就不能在 linux_x86_64 安装。</p>
<p>使用下面这条命令下载的是 tar.gz 的包，可以直接使用 pip install 安装。</p>
<p>比 wheel 包，这种包在安装时会进行编译，所以花费的时间会长一些。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 下载非二进制的包</span>
$ pip download --no-binary<span class="o">=</span>:all: pkg

<span class="c1">#　安装非二进制的包</span>
$ pip install pkg --no-binary
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>3.4 指定代理服务器安装<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>当你身处在一个内网环境中时，无法直接连接公网。这时候你使用<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span></code>
安装包，就会失败。</p>
<p>面对这种情况，可以有两种方法：</p>
<ol class="arabic simple">
<li><p>下载离线包拷贝到内网机器中安装</p></li>
<li><p>使用代理服务器转发请求</p></li>
</ol>
<p>第一种方法，虽说可行，但有相当多的弊端</p>
<ul class="simple">
<li><p>步骤繁杂，耗时耗力</p></li>
<li><p>无法处理包的依赖问题</p></li>
</ul>
<p>这里重点来介绍，第二种方法：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install --proxy <span class="o">[</span>user:passwd@<span class="o">]</span>http_server_ip:port pkg
</pre></div>
</div>
<p>每次安装包就发输入长长的参数，未免有些麻烦，为此你可以将其写入配置文件中：<code class="docutils literal notranslate"><span class="pre">$HOME/.config/pip/pip.conf</span></code></p>
<p>对于这个路径，说明几点</p>
<ul class="simple">
<li><p>不同的操作系统，路径各不相同</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Linux/Unix:</span>
/etc/pip.conf
~/.pip/pip.conf
~/.config/pip/pip.conf

<span class="c1"># Mac OSX:</span>
~/Library/Application Support/pip/pip.conf
~/.pip/pip.conf
/Library/Application Support/pip/pip.conf

<span class="c1"># Windows:</span>
%APPDATA%<span class="se">\p</span>ip<span class="se">\p</span>ip.ini
%HOME%<span class="se">\p</span>ip<span class="se">\p</span>ip.ini
C:<span class="se">\D</span>ocuments and Settings<span class="se">\A</span>ll Users<span class="se">\A</span>pplication Data<span class="se">\P</span>yPA<span class="se">\p</span>ip<span class="se">\p</span>ip.conf <span class="o">(</span>Windows XP<span class="o">)</span>
C:<span class="se">\P</span>rogramData<span class="se">\P</span>yPA<span class="se">\p</span>ip<span class="se">\p</span>ip.conf <span class="o">(</span>Windows 7及以后<span class="o">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>若在你的机子上没有此文件，则自行创建即可</p></li>
</ul>
<p>如何配置，这边给个样例：</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[global]</span>
<span class="na">index-url</span> <span class="o">=</span> <span class="s">http://mirrors.aliyun.com/pypi/simple/</span>

<span class="c1"># 替换出自己的代理地址，格式为[user:passwd@]proxy.server:port</span>
<span class="na">proxy</span><span class="o">=</span><span class="s">http://xxx.xxx.xxx.xxx:8080</span>

<span class="k">[install]</span>
<span class="c1"># 信任阿里云的镜像源，否则会有警告</span>
<span class="na">trusted-host</span><span class="o">=</span><span class="s">mirrors.aliyun.com</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>3.5 安装用户私有软件包<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>很多人可能还不清楚，python 的安装包是可以用户隔离的。</p>
<p>如果你拥有管理员权限，你可以将包安装在全局环境中。在全局环境中的这个包可被该机器上的所有拥有管理员权限的用户使用。</p>
<p>如果一台机器上的使用者不只一样，自私地将在全局环境中安装或者升级某个包，是不负责任且危险的做法。</p>
<p>面对这种情况，我们就想能否安装单独为我所用的包呢？</p>
<p>庆幸的是，还真有。</p>
<p>我能想到的有两种方法：</p>
<ol class="arabic simple">
<li><p>使用虚拟环境</p></li>
<li><p>将包安装在用户的环境中</p></li>
</ol>
<p>虚拟环境，之前写过几篇文章，这里不再展开讲。</p>
<p>今天的重点是第二种方法，教你如何安装用户私有的包？</p>
<p>命令也很简单，只要加上 <code class="docutils literal notranslate"><span class="pre">--user</span></code> 参数，pip 就会将其安装在当前用户的
<code class="docutils literal notranslate"><span class="pre">~/.local/lib/python3.x/site-packages</span></code> 下，而其他用户的 python
则不会受影响。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>pip install --user pkg
</pre></div>
</div>
<p>来举个例子</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在全局环境中未安装 requests</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># pip list | grep requests</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># su - wangbm</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#</span>

<span class="c1"># 由于用户环境继承自全局环境，这里也未安装</span>
<span class="o">[</span>wangbm@localhost ~<span class="o">]</span><span class="c1"># pip list | grep requests</span>
<span class="o">[</span>wangbm@localhost ~<span class="o">]</span><span class="c1"># pip install --user requests</span>
<span class="o">[</span>wangbm@localhost ~<span class="o">]</span><span class="c1"># pip list | grep requests</span>
requests <span class="o">(</span><span class="m">2</span>.22.0<span class="o">)</span>
<span class="o">[</span>wangbm@localhost ~<span class="o">]</span><span class="c1">#</span>

<span class="c1"># 从 Location 属性可发现 requests 只安装在当前用户环境中</span>
<span class="o">[</span>wangbm@ws_compute01 ~<span class="o">]</span>$ pip show requests
---
Metadata-Version: <span class="m">2</span>.1
Name: requests
Version: <span class="m">2</span>.22.0
Summary: Python HTTP <span class="k">for</span> Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.org
Installer: pip
License: Apache <span class="m">2</span>.0
Location: /home/wangbm/.local/lib/python2.7/site-packages
<span class="o">[</span>wangbm@localhost ~<span class="o">]</span>$ <span class="nb">exit</span>
<span class="nb">logout</span>

<span class="c1"># 退出 wangbm 用户，在 root 用户环境中发现 requests 未安装</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span>$ pip list <span class="p">|</span> grep requests
<span class="o">[</span>root@localhost ~<span class="o">]</span>$
</pre></div>
</div>
<p>当你身处个人用户环境中，python
导包时会先检索当前用户环境中是否已安装这个包，已安装则优先使用，未安装则使用全局环境中的包。</p>
<p>验证如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
<span class="go">[&#39;&#39;,</span>
<span class="go"> &#39;/usr/lib64/python27.zip&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7/plat-linux2&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7/lib-tk&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7/lib-old&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7/lib-dynload&#39;,</span>
<span class="go"> &#39;/home/wangbm/.local/lib/python2.7/site-packages&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7/site-packages&#39;,</span>
<span class="go"> &#39;/usr/lib64/python2.7/site-packages/gtk-2.0&#39;,</span>
<span class="go"> &#39;/usr/lib/python2.7/site-packages&#39;,</span>
<span class="go"> &#39;/usr/lib/python2.7/site-packages/pip-18.1-py2.7.egg&#39;,</span>
<span class="go"> &#39;/usr/lib/python2.7/site-packages/lockfile-0.12.2-py2.7.egg&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h5>3.6 延长超时时间<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>若网络情况不是很好，在安装某些包时经常会因为 ReadTimeout 而失败。</p>
<p>对于这种情况，一般重试几次就好了。</p>
<p>但是这样难免有些麻烦，有没有更好的解决方法呢？</p>
<p>有的，可以通过延长超时时间。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install --default-timeout<span class="o">=</span><span class="m">100</span> &lt;packages&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h4>4. 卸载软件包<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>就一条命令，不再赘述</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip uninstall pkg
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h4>5. 升级软件包<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>想要对现有的 python 进行升级，其本质上也是先从 pypi
上下载最新版本的包，再对其进行安装。所以升级也是使用
<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span></code>，只不过要加一个参数 <code class="docutils literal notranslate"><span class="pre">--upgrade</span></code>。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install --upgrade pkg
</pre></div>
</div>
<p>在升级的时候，其实还有一个不怎么用到的选项
<code class="docutils literal notranslate"><span class="pre">--upgrade-strategy</span></code>，它是用来指定升级策略。</p>
<p>它的可选项只有两个：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eager</span></code> ：升级全部依赖包</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">only-if-need</span></code>：只有当旧版本不能适配新的父依赖包时，才会升级。</p></li>
</ul>
<p>在 pip 10.0 版本之后，这个选项的默认值是
<code class="docutils literal notranslate"><span class="pre">only-if-need</span></code>，因此如下两种写法是一互致的。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install --upgrade pkg1
$ pip install --upgrade pkg1 --upgrade-strategy only-if-need
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4>6. 配置文件<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>由于在使用 pip 安装一些包时，默认会使用 pip
的官方源，所以经常会报网络超时失败。</p>
<p>常用的解决办法是，在安装包时，使用 <code class="docutils literal notranslate"><span class="pre">-i</span></code>
参数指定一个国内的镜像源。但是每次指定就很麻烦呀，还要打超长的一串字母。</p>
<p>这时候，其实可以将这个源写进 pip
的配置文件里。以后安装的时候，就默认从你配置的这个 源里安装了。</p>
<p>那怎么配置呢？文件文件在哪？</p>
<p>使用<code class="docutils literal notranslate"><span class="pre">win+r</span></code> 输入 <code class="docutils literal notranslate"><span class="pre">%APPDATA%</span></code> 进入用户资料文件夹，查看有没有一个
pip 的文件夹，若没有则创建之。</p>
<p>然后进入这个 文件夹，新建一个 <code class="docutils literal notranslate"><span class="pre">pip.ini</span></code> 的文件，内容如下</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[global]</span>
<span class="na">time-out</span><span class="o">=</span><span class="s">60</span>
<span class="na">index-url</span><span class="o">=</span><span class="s">https://pypi.tuna.tsinghua.edu.cn/simple/</span>
<span class="k">[install]</span>
<span class="na">trusted-host</span><span class="o">=</span><span class="s">tsinghua.edu.cn</span>
</pre></div>
</div>
<p>以上几乎包含了 pip 的所有常用使用场景，为了方便，我将其整理成一张表格。</p>
<p><img alt="image0" src="http://image.iswbm.com/20191105200041.png" /></p>
</div>
</div>
<span id="document-c08/c08_09"></span><div class="section" id="id1">
<h3>8.9 【进阶】理解模块的缓存<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>在一个模块内部重复引用另一个相同模块，实际并不会导入两次，原因是在使用关键字
<code class="docutils literal notranslate"><span class="pre">import</span></code> 导入模块时，它会先检索 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>
里是否已经载入这个模块了，如果已经载入，则不会再次导入，如果不存在，才会去检索导入这个模块。</p>
<p>来实验一下，在 <code class="docutils literal notranslate"><span class="pre">my_mod02</span></code> 这个模块里，我 import 两次 <code class="docutils literal notranslate"><span class="pre">my_mod01</span></code>
这个模块，按逻辑每一次 import 会一次 <code class="docutils literal notranslate"><span class="pre">my_mod01</span></code> 里的代码（即打印
<code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">mod01</span></code>），但是验证结果是，只打印了一次。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat my_mod01.py
print<span class="o">(</span><span class="s1">&#39;in mod01&#39;</span><span class="o">)</span>

$ cat my_mod02.py
import my_mod01
import my_mod01

$ python my_mod02.py
in mod01
</pre></div>
</div>
<p>该现象的解释是：因为有 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 的存在。</p>
<p><code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>
是一个字典（key：模块名，value：模块对象），它存放着在当前 namespace
所有已经导入的模块对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># test_module.py</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;json&#39;</span><span class="p">,</span> <span class="s1">&#39;NotFound&#39;</span><span class="p">))</span>

<span class="kn">import</span> <span class="nn">json</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;json&#39;</span><span class="p">,</span> <span class="s1">&#39;NotFound&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>运行结果如下，可见在 导入后 json 模块后，<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 才有了 json
模块的对象。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python test_module.py
NotFound
&lt;module <span class="s1">&#39;json&#39;</span> from <span class="s1">&#39;C:\Python27\lib\json\__init__.pyc&#39;</span>&gt;
</pre></div>
</div>
<p>由于有缓存的存在，使得我们无法重新载入一个模块。</p>
<p>但若你想反其道行之，可以借助 importlib
这个神奇的库来实现。事实也确实有此场景，比如在代码调试中，在发现代码有异常并修改后，我们通常要重启服务再次载入程序。这时候，若有了模块重载，就无比方便了，修改完代码后也无需服务的重启，就能继续调试。</p>
<p>还是以上面的例子来理解，<code class="docutils literal notranslate"><span class="pre">my_mod02.py</span></code> 改写成如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># my_mod02.py</span>

<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">my_mod01</span>
<span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">my_mod01</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 python3 来执行这个模块，与上面不同的是，这边执行了两次
<code class="docutils literal notranslate"><span class="pre">my_mod01.py</span></code></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 my_mod02.py
in mod01
in mod01
</pre></div>
</div>
</div>
<span id="document-c08/c08_10"></span><div class="section" id="id1">
<h3>8.10 【进阶】理解查找器与加载器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>如果指定名称的模块在 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 找不到，则将发起调用 Python
的导入协议以查找和加载该模块。</p>
<p>此协议由两个概念性模块构成，即 <code class="docutils literal notranslate"><span class="pre">查找器</span></code> 和 <code class="docutils literal notranslate"><span class="pre">加载器</span></code>。</p>
<p>一个 Python 的模块的导入，其实可以再细分为两个过程：</p>
<ol class="arabic simple">
<li><p>由查找器实现的模块查找</p></li>
<li><p>由加载器实现的模块加载</p></li>
</ol>
<div class="section" id="id2">
<h4>4.1 查找器是什么？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>查找器（finder），简单点说，查找器定义了一个模块查找机制，让程序知道该如何找到对应的模块。</p>
<p>其实 Python 内置了多个默认查找器，其存在于 sys.meta_path 中。</p>
<p>但这些查找器对应使用者来说，并不是那么重要，因此在 Python 3.3 之前，
Python 解释将其隐藏了，我们称之为隐式查找器。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Python 2.7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span>
<span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于这点不利于开发者深入理解 import 机制，在 Python 3.3
后，所有的模块导入机制都会通过 sys.meta_path
暴露，不会在有任何隐式导入机制。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># Python 3.6
&gt;&gt;&gt; import sys
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(sys.meta_path)
[&lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;,
 &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;,
 &lt;class &#39;_frozen_importlib_external.PathFinder&#39;&gt;]
</pre></div>
</div>
<p>观察一下 Python 默认的这几种查找器 （finder），可以分为三种：</p>
<ul class="simple">
<li><p>一种知道如何导入内置模块</p></li>
<li><p>一种知道如何导入冻结模块</p></li>
<li><p>一种知道如何导入来自 <a class="reference external" href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path">import
path</a>
的模块 (即 <a class="reference external" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder">path based
finder</a>)。</p></li>
</ul>
<p>那我们能不能自已定义一个查找器呢？当然可以，你只要</p>
<ul class="simple">
<li><p>定义一个实现了 find_module 方法的类（py2和py3均可），或者实现
find_loader 类方法（仅 py3 有效），如果找到模块需要返回一个 loader
对象或者 ModuleSpec 对象（后面会讲），没找到需要返回 None</p></li>
<li><p>定义完后，要使用这个查找器，必须注册它，将其插入在 sys.meta_path
的首位，这样就能优先使用。</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">MyFinder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Importing&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="c1"># 将在后面定义</span>
        <span class="k">return</span> <span class="n">MyLoader</span><span class="p">()</span>

<span class="c1"># 由于 finder 是按顺序读取的，所以必须插入在首位</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MyFinder</span><span class="p">)</span>
</pre></div>
</div>
<p>查找器可以分为两种：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>object
 +-- Finder <span class="o">(</span>deprecated<span class="o">)</span>
      +-- MetaPathFinder
      +-- PathEntryFinder
</pre></div>
</div>
<p>这里需要注意的是，在 3.4 版前，查找器会直接返回
加载器（Loader）对象，而在 3.4
版后，查找器则会返回模块规格说明（ModuleSpec），其中 包含加载器。</p>
<p>而关于什么是 加载器 和 模块规格说明， 请继续往后看。</p>
</div>
<div class="section" id="id3">
<h4>4.2 加载器是什么？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>查找器只负责查找定位找模，而真正负责加载模块的，是加载器（loader）。</p>
<p>一般的 loader 必须定义名为 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 的方法。</p>
<p>为什么这里说一般，因为 loader 还分多种：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>object
 +-- Finder <span class="o">(</span>deprecated<span class="o">)</span>
 <span class="p">|</span>    +-- MetaPathFinder
 <span class="p">|</span>    +-- PathEntryFinder
 +-- Loader
      +-- ResourceLoader --------+
      +-- InspectLoader          <span class="p">|</span>
           +-- ExecutionLoader --+
                                 +-- FileLoader
                                 +-- SourceLoader
</pre></div>
</div>
<p>通过查看源码可知，不同的加载器的抽象方法各有不同。</p>
<p>加载器通常由一个 finder 返回。详情参见 PEP 302，对于 abstract base class
可参见 importlib.abc.Loader。</p>
<p>那如何自定义我们自己的加载器呢？</p>
<p>你只要</p>
<ul class="simple">
<li><p>定义一个实现了 load_module 方法的类</p></li>
<li><p>对与导入有关的属性（<a class="reference external" href="https://docs.python.org/zh-cn/3/reference/import.html#import-related-module-attributes">点击查看详情</a>）进行校验</p></li>
<li><p>创建模块对象并绑定所有与导入相关的属性变量到该模块上</p></li>
<li><p>将此模块保存到 sys.modules 中（顺序很重要，避免递归导入）</p></li>
<li><p>然后加载模块（这是核心）</p></li>
<li><p>若加载出错，需要能够处理抛出异常（ ImportError）</p></li>
<li><p>若加载成功，则返回 module 对象</p></li>
</ul>
<p>若你想看具体的例子，可以接着往后看。</p>
</div>
<div class="section" id="id4">
<h4>4.3 模块规格说明<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。
大多数信息都是所有模块通用的。
模块规格说明的目的是基于每个模块来封装这些导入相关信息。</p>
<p>模块的规格说明会作为模块对象的 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 属性对外公开。
有关模块规格的详细内容请参阅
<code class="docutils literal notranslate"><span class="pre">`ModuleSpec</span></code> &lt;<a class="reference external" href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.ModuleSpec">https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.ModuleSpec</a>&gt;`__。</p>
<p>在 Python 3.4 后，查找器不再返回加载器，而是返回 ModuleSpec
对象，它储存着更多的信息</p>
<ul class="simple">
<li><p>模块名</p></li>
<li><p>加载器</p></li>
<li><p>模块绝对路径</p></li>
</ul>
<p>那如何查看一个模块的 ModuleSpec ？</p>
<p>这边举个例子</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat my_mod02.py
import my_mod01
print<span class="o">(</span>my_mod01.__spec__<span class="o">)</span>

$ python3 my_mod02.py
in mod01
ModuleSpec<span class="o">(</span><span class="nv">name</span><span class="o">=</span><span class="s1">&#39;my_mod01&#39;</span>, <span class="nv">loader</span><span class="o">=</span>&lt;_frozen_importlib_external.SourceFileLoader object at 0x000000000392DBE0&gt;, <span class="nv">origin</span><span class="o">=</span><span class="s1">&#39;/home/MING/my_mod01.py&#39;</span><span class="o">)</span>
</pre></div>
</div>
<p>从 ModuleSpec
中可以看到，加载器是包含在内的，那我们如果要重新加载一个模块，是不是又有了另一种思路了？</p>
<p>来一起验证一下。</p>
<p>现在有两个文件：</p>
<p>一个是 my_info.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># my_info.py</span>
<span class="n">name</span><span class="o">=</span><span class="s1">&#39;wangbm&#39;</span>
</pre></div>
</div>
<p>另一个是：main.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># main.py</span>
<span class="kn">import</span> <span class="nn">my_info</span>

<span class="k">print</span><span class="p">(</span><span class="n">my_info</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># 加一个断点</span>
<span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

<span class="c1"># 再加载一次</span>
<span class="n">my_info</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">my_info</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">main.py</span></code> 处，我加了一个断点，目的是当运行到断点处时，我修改
my_info.py 里的 name 为 <code class="docutils literal notranslate"><span class="pre">ming</span></code> ，以便验证重载是否有效？</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 main.py
wangbm
&gt; /home/MING/main.py<span class="o">(</span><span class="m">9</span><span class="o">)</span>&lt;module&gt;<span class="o">()</span>
-&gt; my_info.__spec__.loader.load_module<span class="o">()</span>
<span class="o">(</span>Pdb<span class="o">)</span> c
ming
</pre></div>
</div>
<p>从结果来看，重载是有效的。</p>
</div>
<div class="section" id="id5">
<h4>4.4 导入器是什么？<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>导入器（importer），也许你在其他文章里会见到它，但其实它并不是个新鲜的东西。</p>
<p>它只是同时实现了查找器和加载器两种接口的对象，所以你可以说导入器（importer）是查找器（finder），也可以说它是加载器（loader）。</p>
</div>
</div>
<span id="document-c08/c08_11"></span><div class="section" id="id1">
<h3>8.11 【进阶】实现远程导入模块<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>由于 Python 默认的 查找器和加载器
仅支持本地的模块的导入，并不支持实现远程模块的导入。</p>
<p>为了让你更好的理解 Python Import Hook
机制，我下面会通过实例演示，如何自己实现远程导入模块的导入器。</p>
<div class="section" id="id2">
<h4>1. 动手实现导入器<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>当导入一个包的时候，Python 解释器首先会从 sys.meta_path
中拿到查找器列表。</p>
<p>默认顺序是：内建模块查找器 -&gt; 冻结模块查找器 -&gt; 第三方模块路径（本地的
sys.path）查找器</p>
<p>若经过这三个查找器，仍然无法查找到所需的模块，则会抛出ImportError异常。</p>
<p>因此要实现远程导入模块，有两种思路。</p>
<ul class="simple">
<li><p>一种是实现自己的元路径导入器；</p></li>
<li><p>另一种是编写一个钩子，添加到sys.path_hooks里，识别特定的目录命名模式。</p></li>
</ul>
<p>我这里选择第一种方法来做为示例。</p>
<p>实现导入器，我们需要分别查找器和加载器。</p>
<p><strong>首先是查找器</strong></p>
<p>由源码得知，路径查找器分为两种</p>
<ul class="simple">
<li><p>MetaPathFinder</p></li>
<li><p>PathEntryFinder</p></li>
</ul>
<p>这里使用 MetaPathFinder 来进行查找器的编写。</p>
<p>在 Python 3.4 版本之前，查找器必须实现 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 方法，而 Python
3.4+ 版，则推荐使用 <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 方法，但这并不意味着你不能使用
<code class="docutils literal notranslate"><span class="pre">find_module()</span></code>，但是在没有 <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code>
方法时，导入协议还是会尝试 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 方法。</p>
<p>我先举例下使用 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 该如何写。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">abc</span>

<span class="k">class</span> <span class="nc">UrlMetaFinder</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">MetaPathFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>

    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 不是原定义的url就直接返回不存在</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="n">path</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">UrlMetaLoader</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>
            <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">loader</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</pre></div>
</div>
<p>若使用 <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> ，要注意此方法的调用需要带有两到三个参数。</p>
<p>第一个是被导入模块的完整限定名称，例如 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>。
第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为
<code class="docutils literal notranslate"><span class="pre">None</span></code>，但对于子模块或子包，第二个参数为父包 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性的值。
如果相应的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性无法访问，将引发
<code class="docutils literal notranslate"><span class="pre">`ModuleNotFoundError</span></code> &lt;<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError">https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError</a>&gt;`__。
第三个参数是一个将被作为稍后加载目标的现有模块对象。
导入系统仅会在重加载期间传入一个目标模块。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">abc</span>
<span class="kn">from</span> <span class="nn">importlib.machinery</span> <span class="kn">import</span> <span class="n">ModuleSpec</span>

<span class="k">class</span> <span class="nc">UrlMetaFinder</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">MetaPathFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>
    <span class="k">def</span> <span class="nf">find_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 不是原定义的url就直接返回不存在</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="n">path</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">UrlMetaLoader</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">is_package</span><span class="o">=</span><span class="n">loader</span><span class="o">.</span><span class="n">is_package</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</pre></div>
</div>
<p><strong>接下来是加载器</strong></p>
<p>由源码得知，路径查找器分为三种</p>
<ul class="simple">
<li><p>FileLoader</p></li>
<li><p>SourceLoader</p></li>
</ul>
<p>按理说，两种加载器都可以实现我们想要的功能，我这里选用 SourceLoader
来示范。</p>
<p>在 SourceLoader
这个抽象类里，有几个很重要的方法，在你写实现加载器的时候需要注意</p>
<ul class="simple">
<li><p>get_code：获取源代码，可以根据自己场景实现实现。</p></li>
<li><p>exec_module：执行源代码，并将变量赋值给 <code class="docutils literal notranslate"><span class="pre">module.__dict__</span></code></p></li>
<li><p>get_data：抽象方法，必须实现，返回指定路径的字节码。</p></li>
<li><p>get_filename：抽象方法，必须实现，返回文件名</p></li>
</ul>
<p>在一些老的博客文章中，你会经常看到 加载器 要实现 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>
，而这个方法早已在 Python 3.4
的时候就被废弃了，当然为了兼容考虑，你若使用 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>
也是可以的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">abc</span>

<span class="k">class</span> <span class="nc">UrlMetaLoader</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">SourceLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_code</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="n">mod</span><span class="o">.</span><span class="vm">__file__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">fullname</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">execute_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">+</span> <span class="n">fullname</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>
</pre></div>
</div>
<p>当你使用这种旧模式实现自己的加载时，你需要注意两点，很重要：</p>
<ul class="simple">
<li><p>execute_module 必须重载，而且不应该有任何逻辑，即使它并不是抽象方法。</p></li>
<li><p>load_module，需要你在查找器里手动执行，才能实现模块的加载。。</p></li>
</ul>
<p>做为替换，你应该使用 <code class="docutils literal notranslate"><span class="pre">execute_module()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">create_module()</span></code>
。由于基类里已经实现了 <code class="docutils literal notranslate"><span class="pre">execute_module</span></code> 和
<code class="docutils literal notranslate"><span class="pre">create_module()</span></code>，并且满足我们的使用场景。我这边可以不用重复实现。和旧模式相比，这里也不需要在设查找器里手动执行
<code class="docutils literal notranslate"><span class="pre">execute_module()</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span> <span class="kn">as</span> <span class="nn">urllib2</span>

<span class="k">class</span> <span class="nc">UrlMetaLoader</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">SourceLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">+</span> <span class="n">fullname</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>
</pre></div>
</div>
<p>查找器和加载器都有了，别忘了往sys.meta_path
注册我们自定义的查找器（UrlMetaFinder）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">install_meta</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">UrlMetaFinder</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finder</span><span class="p">)</span>
</pre></div>
</div>
<p>所有的代码都解析完毕后，我们将其整理在一个模块（my_importer.py）中</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># my_importer.py</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">urllib.request</span> <span class="kn">as</span> <span class="nn">urllib2</span>

<span class="k">class</span> <span class="nc">UrlMetaFinder</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MetaPathFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>


    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 不是原定义的url就直接返回不存在</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="n">path</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">UrlMetaLoader</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">loader</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">UrlMetaLoader</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">SourceLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseurl</span> <span class="o">+</span> <span class="n">fullname</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>

<span class="k">def</span> <span class="nf">install_meta</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">UrlMetaFinder</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finder</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 搭建远程服务端<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>最开始我说了，要实现一个远程导入模块的方法。</p>
<p>我还缺一个在远端的服务器，来存放我的模块，为了方便，我使用python自带的
<code class="docutils literal notranslate"><span class="pre">http.server</span></code> 模块用一条命令即可实现。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mkdir httpserver <span class="o">&amp;&amp;</span> <span class="nb">cd</span> httpserver
$ cat&gt;my_info.py&lt;EOF
<span class="nv">name</span><span class="o">=</span><span class="s1">&#39;wangbm&#39;</span>
print<span class="o">(</span><span class="s1">&#39;ok&#39;</span><span class="o">)</span>
EOF
5sM!ebM5sM!ebMt0fNkt0fNk
$ cat my_info.py
<span class="nv">name</span><span class="o">=</span><span class="s1">&#39;wangbm&#39;</span>
print<span class="o">(</span><span class="s1">&#39;ok&#39;</span><span class="o">)</span>
$
$ python3 -m http.server <span class="m">12800</span>
Serving HTTP on <span class="m">0</span>.0.0.0 port <span class="m">12800</span> <span class="o">(</span>http://0.0.0.0:12800/<span class="o">)</span> ...
...
</pre></div>
</div>
<p>一切准备好，我们就可以验证了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">my_importer</span> <span class="kn">import</span> <span class="n">install_meta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">install_meta</span><span class="p">(</span><span class="s1">&#39;http://localhost:12800/&#39;</span><span class="p">)</span> <span class="c1"># 往 sys.meta_path 注册 finder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">my_info</span>  <span class="c1"># 打印ok，说明导入成功</span>
<span class="go">ok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_info</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># 验证可以取得到变量</span>
<span class="go">&#39;wangbm&#39;</span>
</pre></div>
</div>
<p>至此，我实现了一个简易的可以导入远程服务器上的模块的导入器。</p>
</div>
</div>
<span id="document-c08/c08_12"></span><div class="section" id="distutilssetuptools">
<h3>8.12 【基础】分发工具：distutils和setuptools<a class="headerlink" href="#distutilssetuptools" title="Permalink to this headline">¶</a></h3>
<div class="section" id="distutils">
<h4>1. 包分发的始祖：distutils<a class="headerlink" href="#distutils" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">distutils</span></code> 是 Python
的一个标准库，从命名上很容易看出它是一个分发（distribute）工具（utlis），它是
Python
官方开发的一个分发打包工具，所有后续的打包工具，全部都是基于它进行开发的。</p>
<p><code class="docutils literal notranslate"><span class="pre">distutils</span></code> 的精髓在于编写 setup.py，它是模块分发与安装的指导文件。</p>
<p>那么如何编写 setup.py
呢？这里面的内容非常多，我会在后面进行详细的解析，请你耐心往下看。</p>
<p>你有可能没写过 setup.py ，但你绝对使用过 setup.py
来做一些事情，比如下面这条命令，我们经常用它来进行模块的安装。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py install
</pre></div>
</div>
<p>这样的安装方法是通过源码安装，与之对应的是通过二进制软件包的安装，同样我也会在后面进行介绍。</p>
</div>
<div class="section" id="setuptools">
<h4>2. 分发工具升级：setuptools<a class="headerlink" href="#setuptools" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 是 distutils
增强版，不包括在标准库中。其扩展了很多功能，能够帮助开发者更好的创建和分发
Python 包。大部分 Python 用户都会使用更先进的 setuptools 模块。</p>
<p><strong>distribute</strong>，或许你在其他地方也见过它，这里也提一下。</p>
<p>distribute 是 setuptools
有一个分支版本，分支的原因可能是有一部分开发者认为 setuptools
开发太慢了。但现在，distribute 又合并回了 setuptools
中。因此，我们可以认为它们是同一个东西。</p>
<p>还有一个大包分发工具是
<strong>distutils2</strong>，其试图尝试充分利用distutils，detuptools 和 distribute
并成为 Python
标准库中的标准工具。但该计划并没有达到预期的目的，且已经是一个废弃的项目。</p>
<p>因此，setuptools 是一个优秀的，可靠的 Python 包安装与分发工具。</p>
<p>那么如何在一个干净的环境中安装 setuptools 呢？</p>
<p>主要有两种方法：</p>
<ul class="simple">
<li><p>源码安装：在 <a class="reference external" href="https://pypi.org/project/setuptools/#files">https://pypi.org/project/setuptools/#files</a> 中下载 zip 包
解压执行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code> 安装</p></li>
<li><p>通过引导程序安装：下载引导程序，它可以用来下载或者更新最新版本的
setuptools</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ wget http://peak.telecommunity.com/dist/ez_setup.py

<span class="c1"># 安装</span>
$ python ez_setup.py

<span class="c1"># 更新，以下两种任选</span>
$ python ez_setup.py –U setuptools
$ pip install -U setuptools
</pre></div>
</div>
</div>
</div>
<span id="document-c08/c08_13"></span><div class="section" id="id1">
<h3>8.13 【基础】源码包与二进制包有什么区别？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Python 包的分发可以分为两种：</p>
<ol class="arabic simple">
<li><p>以源码包的方式发布</p></li>
</ol>
<p>源码包安装的过程，是先解压，再编译，最后才安装，所以它是跨平台的，由于每次安装都要进行编译，相对二进包安装方式来说安装速度较慢。</p>
<p>源码包的本质是一个压缩包，其常见的格式有：</p>
<p><img alt="image0" src="http://image.iswbm.com/20191218202833.png" /></p>
<ol class="arabic simple" start="2">
<li><p>以二进制包形式发布</p></li>
</ol>
<p>二进制包的安装过程省去了编译的过程，直接进行解压安装，所以安装速度较源码包来说更快。</p>
<p>由于不同平台的编译出来的包无法通用，所以在发布时，需事先编译好多个平台的包。</p>
<p>二进制包的常见格式有：</p>
<p><img alt="image1" src="http://image.iswbm.com/20191218203005.png" /></p>
</div>
<span id="document-c08/c08_14"></span><div class="section" id="eggswheels">
<h3>8.14 【基础】eggs与wheels 有什么区别？<a class="headerlink" href="#eggswheels" title="Permalink to this headline">¶</a></h3>
<p>Egg 格式是由 setuptools 在 2004 年引入，而 Wheel 格式是由 PEP427 在 2012
年定义。Wheel 的出现是为了替代 Egg，它的本质是一个zip包，其现在被认为是
Python 的二进制包的标准格式。</p>
<p>以下是 Wheel 和 Egg 的主要区别：</p>
<ul class="simple">
<li><p>Wheel 有一个官方的 PEP427 来定义，而 Egg 没有 PEP 定义</p></li>
<li><p>Wheel 是一种分发格式，即打包格式。而 Egg
既是一种分发格式，也是一种运行时安装的格式，并且是可以被直接 import</p></li>
<li><p>Wheel 文件不会包含 .pyc 文件</p></li>
<li><p>Wheel 使用和 PEP376 兼容的 .dist-info 目录，而 Egg 使用 .egg-info
目录</p></li>
<li><p>Wheel 有着更丰富的命名规则。</p></li>
<li><p>Wheel 是有版本的。每个 Wheel 文件都包含 wheel 规范的版本和打包的实现</p></li>
<li><p>Wheel 在内部被 sysconfig path type 管理，因此转向其他格式也更容易</p></li>
</ul>
<p>wheel 包可以通过 pip 来安装，只不过需要先安装 wheel 模块，然后再使用 pip
的命令。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install wheel
$ pip wheel --wheel-dir<span class="o">=</span>/local/wheels pkg
</pre></div>
</div>
</div>
<span id="document-c08/c08_15"></span><div class="section" id="setup-py">
<h3>8.15 【进阶】超详细讲解 setup.py 的编写<a class="headerlink" href="#setup-py" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. setup.py 的编写<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>1、构建源码发布包。</p>
<p>用于发布一个 Python 模块或项目，将源码打包成 tar.gz （用于 Linux
环境中）或者 zip 压缩包（用于 Windows 环境中）</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist
</pre></div>
</div>
<p>那这种包如何安装呢？</p>
<p>答案是，使用 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 中提供的 <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> 工具。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ easy_install xxx.tar.gz
</pre></div>
</div>
<p>使用 sdist 将根据当前平台创建默认格式的存档。在类 Unix
平台上，将创建后缀后为 <code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code> 的 gzip
压缩的tar文件分发包，而在Windows上为 ZIP 文件。</p>
<p>当然，你也可以通过指定你要的发布包格式来打破这个默认行为</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist --formats<span class="o">=</span>gztar,zip
</pre></div>
</div>
<p>你可以指定的格式有哪些呢？</p>
<p>创建一个压缩的tarball和一个zip文件。可用格式为：</p>
<p><img alt="image0" src="http://image.iswbm.com/20191218203517.png" /></p>
<p>对以上的格式，有几点需要注意一下：</p>
<ul class="simple">
<li><p>在版本3.5中才添加了对 <code class="docutils literal notranslate"><span class="pre">xztar</span></code> 格式的支持</p></li>
<li><p>zip
格式需要你事先已安装相应的模块：zip程序或zipfile模块（已成为Python的标准库）</p></li>
<li><p>ztar 格式正在弃用，请尽量不要使用</p></li>
</ul>
<p>另外，如果您希望归档文件的所有文件归root拥有，可以这样指定</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist --owner<span class="o">=</span>root --group<span class="o">=</span>root
</pre></div>
</div>
<p>2、构建二进制分发包。</p>
<p>在windows中我们习惯了双击 exe 进行软件的安装，Python
模块的安装也同样支持 打包成 exe 这样的二进制软件包。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py bdist_wininst
</pre></div>
</div>
<p>而在 Linux 中，大家也习惯了使用 rpm 来安装包，对此你可以使用这条命令实现
rpm 包的构建</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py bdist_rpm
</pre></div>
</div>
<p>若你喜欢使用 easy_install 或者 pip 来安装离线包。你可以将其打包成 egg 包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py bdist_egg
</pre></div>
</div>
<p>若你的项目，需要安装多个平台下，既有 Windows 也有
Linux，按照上面的方法，多种格式我们要执行多次命令，为了方便，你可以一步到位，执行如下这条命令，即可生成多个格式的进制包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py bdist
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 使用 setup.py 安装包<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>正常情况下，我们都是通过以上构建的源码包或者二进制包进行模块的安装。</p>
<p>但在编写 setup.py
的过程中，可能不能一步到位，需要多次调试，这时候如何测试自己写的
setup.py 文件是可用的呢？</p>
<p>这时候你可以使用这条命令，它会将你的模块安装至系统全局环境中</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py install
</pre></div>
</div>
<p>如若你的项目还处于开发阶段，频繁的安装模块，也是一个麻烦事。</p>
<p>这时候你可以使用这条命令安装，该方法不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py develop
</pre></div>
</div>
</div>
</div>
<span id="document-c08/c08_16"></span><div class="section" id="pbr">
<h3>8.16 【进阶】打包辅助神器 PBR 是什么？<a class="headerlink" href="#pbr" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pbr</span></code> 是 setuptools 的辅助工具，最初是为 OpenStack
开发(<a class="reference external" href="https://launchpad.net/pbr">https://launchpad.net/pbr</a>)，基于<code class="docutils literal notranslate"><span class="pre">d2to1</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">pbr</span></code> 会读取和过滤setup.cfg中的数据，然后将解析后的数据提供给
<code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 作为参数。包含如下功能：</p>
<ol class="arabic simple">
<li><p>从git中获取Version、AUTHORS and ChangeLog信息</p></li>
<li><p>Sphinx Autodoc。pbr 会扫描project，找到所有模块，生成stub files</p></li>
<li><p>Requirements。pbr会读取requirements.txt，生成setup函数需要的<code class="docutils literal notranslate"><span class="pre">install_requires/tests_require/dependency_links</span></code></p></li>
</ol>
<p>这里需要注意，在 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>
文件的头部可以使用：<code class="docutils literal notranslate"><span class="pre">--index</span> <span class="pre">https://pypi.python.org/simple/</span></code>，这一行把一个抽象的依赖声明如
requests==1.2.0 转变为一个具体的依赖声明 requests 1.2.0 from
pypi.python.org/simple/</p>
<ol class="arabic simple" start="4">
<li><p>long_description。从README.rst, README.txt or README
file中生成<code class="docutils literal notranslate"><span class="pre">long_description</span></code>参数</p></li>
</ol>
<p>使用pbr很简单：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="k">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">setup_requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pbr&#39;</span><span class="p">],</span>
    <span class="n">pbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>使用pbr时，setup.cfg中有一些配置。在[files]中，有三个key：
<code class="docutils literal notranslate"><span class="pre">packages</span></code>:指定需要包含的包，行为类似于setuptools.find_packages
<code class="docutils literal notranslate"><span class="pre">namespace_packages</span></code>:指定namespace packages <code class="docutils literal notranslate"><span class="pre">data_files</span></code>:
指定目的目录和源文件路径，一个示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">files</span><span class="p">]</span>
<span class="n">data_files</span> <span class="o">=</span>
    <span class="n">etc</span><span class="o">/</span><span class="n">pbr</span> <span class="o">=</span> <span class="n">etc</span><span class="o">/</span><span class="n">pbr</span><span class="o">/*</span>
    <span class="n">etc</span><span class="o">/</span><span class="n">neutron</span> <span class="o">=</span>
        <span class="n">etc</span><span class="o">/</span><span class="n">api</span><span class="o">-</span><span class="n">paste</span><span class="o">.</span><span class="n">ini</span>
        <span class="n">etc</span><span class="o">/</span><span class="n">dhcp</span><span class="o">-</span><span class="n">agent</span><span class="o">.</span><span class="n">ini</span>
    <span class="n">etc</span><span class="o">/</span><span class="n">init</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">neutron</span><span class="o">.</span><span class="n">init</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[entry_points]</span></code> 段跟 setuptools 的方式相同。</p>
<p>到此，我讲了三种编写使用 setup.py 的方法</p>
<ul class="simple">
<li><p>使用命令行参数指定，一个一个将参数传递进去（极不推荐）</p></li>
<li><p>在 setup.py 中的setup函数中指定（推荐使用）</p></li>
<li><p>使用 pbr ，在 setup.cfg 中指定（易于管理，更推荐）</p></li>
</ul>
</div>
<span id="document-c08/c08_17"></span><div class="section" id="pypi">
<h3>8.17 【进阶】开源自己的包到 PYPI 上<a class="headerlink" href="#pypi" title="Permalink to this headline">¶</a></h3>
<p>通过前面的学习，你一定已经学会了如何打包自己的项目，若你觉得自己开发的模块非常不错，想要
share 给其他人使用，你可以将其上传到 PyPi （Python Package
Index）上，它是 Python
官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包。</p>
<p>如果要发布自己的包，需要先到 pypi 上注册账号。然后创建 <code class="docutils literal notranslate"><span class="pre">~/.pypirc</span></code>
文件，此文件中配置 PyPI
访问地址和账号。如的.pypirc文件内容请根据自己的账号来修改。</p>
<p>典型的 .pypirc 文件</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[distutils]</span>
<span class="na">index-servers</span> <span class="o">=</span> <span class="s">pypi</span>

<span class="k">[pypi]</span>
<span class="na">username:xxx</span>
<span class="na">password:xxx</span>
</pre></div>
</div>
<p>然后使用这条命令进行信息注册，完成后，你可以在 PyPi 上看到项目信息。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py register
</pre></div>
</div>
<p>注册完了后，你还要上传源码包，别人才使用下载安装</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python setup.py upload
</pre></div>
</div>
<p>或者也可以使用 <code class="docutils literal notranslate"><span class="pre">twine</span></code> 工具注册上传，它是一个专门用于与 pypi
进行交互的工具，详情可以参考官网：<a class="reference external" href="https://www.ctolib.com/twine.html">https://www.ctolib.com/twine.html</a>，这里不详细讲了。</p>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p09"></span><div class="section" id="id1">
<h2>第九章：调试技巧<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c09/c09_01"></span><div class="section" id="id1">
<h3>9.1 【调试技巧】超详细图文教你调试代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 调试的过程<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>调试可以说是每个开发人员都必备一项技能，在日常开发和排查 bug
都非常有用。</p>
<p>调试的过程分为三步：</p>
<ol class="arabic simple">
<li><p>第一步：在你想要调试的地方，打上断点</p></li>
<li><p>第二步：使用调试模式来运行这个 python 程序</p></li>
<li><p>第三步：使用各种手段开始代码调试</p></li>
</ol>
<p>首先第一步和第二步，我用下面这张图表示</p>
<p><img alt="image0" src="http://image.iswbm.com/20200823134911.png" /></p>
<p>点击上图中的小蜘蛛，开启调试模式后，在 PyCharm 下方会弹出一个选项卡。</p>
<p>这个选项卡的按键非常多，包括</p>
<ol class="arabic simple">
<li><p>变量查看窗口</p></li>
<li><p>调试控制窗口</p></li>
<li><p>线程控制窗口</p></li>
<li><p>程序控制窗口</p></li>
</ol>
<p><img alt="image1" src="http://image.iswbm.com/20200823140008.png" /></p>
<p>在变量查看窗口，你可以查看当前程序进行到该断点处，所有的普通变量和特殊变量，你每往下执行一行代码，这些变量都有可能跟着改变。</p>
<p>如果你的程序是多线程的，你可以通过线程控制窗口的下拉框来切换线程。</p>
<p>以上两个窗口，都相对比较简单，我一笔带过，下面主要重点讲下调试控制按钮和程序控制按钮。</p>
<p>在调试控制窗口，共有 8 个按钮，他们的作用分别是什么呢？</p>
<ol class="arabic simple">
<li><p>Show Execution Point：无论你的代码编辑
窗口的光标在何处，只要点下该按钮，都会自动跳转到程序运行的地方。</p></li>
<li><p>Step
Over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step
into效果一样的。简单的说就是，程序代码越过子函数，但子函数会执行，且不进入。</p></li>
<li><p>Step
Into：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。</p></li>
<li><p>Step Into My
Code：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。</p></li>
<li><p>Step
Out：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</p></li>
<li><p>Run To Cursor：运行到光标处，省得每次都要打一个断点。</p></li>
<li><p>Evaluate Expression：计算表达式，在里面可以自己执行一些代码。</p></li>
</ol>
<p>以上七个功能，就是最常用的功能，一般操作步骤就是，设置好断点，debug运行，然后
F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift +
F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。</p>
<p>看这张图就行了（下面第6点有误，应该是运行到光标处，而不是下一断点处）</p>
<p><img alt="image2" src="http://image.iswbm.com/20200823143211.png" /></p>
<p>在程序控制窗口，共有 6
个按钮，他们的作用分别又是什么呢？同时看下面这张图就行了。</p>
<p><img alt="image3" src="http://image.iswbm.com/20200823143535.png" /></p>
</div>
<div class="section" id="id3">
<h4>2. 调试相关的快捷键<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>⇧ + F9：调试当前文件</p></li>
<li><p>⌥ + ⇧ + F9：弹出菜单，让你选择调试哪一个文件</p></li>
<li><p>F8：单步执行，不进入函数</p></li>
<li><p>F7：单步执行，进入函数</p></li>
<li><p>⌥ + ⇧ +F7：单步执行，只进入自己写的函数</p></li>
<li><p>⇧ + F8：跳出函数体</p></li>
<li><p>F9：运行到下一断点</p></li>
<li><p>⌥ + F9：运行到光标处</p></li>
<li><p>⇧ + ⌘ + F8：查看所有设置的断点</p></li>
<li><p>⌘ + F8：切换断点（有断点则取消断点，没有则加上断点）</p></li>
<li><p>⌥ + F5：重新以调试模式运行</p></li>
<li><p>⌥ + F8 计算表达式（可以更改变量值使其生效）</p></li>
</ul>
</div>
</div>
<span id="document-c09/c09_02"></span><div class="section" id="pycharm">
<h3>9.2 【调试技巧】PyCharm 中指定参数调试程序<a class="headerlink" href="#pycharm" title="Permalink to this headline">¶</a></h3>
<p>你在 Pycharm 运行你的项目，通常是怎么执行的？我的做法是，右键，然后点击
<code class="docutils literal notranslate"><span class="pre">Run</span></code>，或者使用快捷键 <code class="docutils literal notranslate"><span class="pre">Shift</span> <span class="pre">+</span> <span class="pre">F10</span></code> 。</p>
<p>有时候，在运行/调试脚本的时候，我们需要指定一些参数，这在命令行中，直接指定即可。</p>
<p>假设在命令行中，运行脚本的命令是这样</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>python main.py init --local
</pre></div>
</div>
<p>对于刚使用 Pycharm 的同学，可能并不知道 Pycharm
也是可以指定参数的。点击下图位置</p>
<p><img alt="image0" src="http://image.iswbm.com/FmfL3r0iWx_srT_xMASBEp1ZaaId" /></p>
<p>进入设置面板，在 <code class="docutils literal notranslate"><span class="pre">Script</span> <span class="pre">parameters</span></code> 中填入参数即可。</p>
<p><img alt="image1" src="http://image.iswbm.com/FujczKwTUPa8l5EEmS0eoh-zL1Nk" /></p>
<p>同时在上图的底部，你可以看到，这里可以很方便的切换
解释器，比你跑到这边来要容易得多吧</p>
<p><img alt="image2" src="http://image.iswbm.com/Fq60WOdcRJopqV6MVoRcIuZclYKx" /></p>
</div>
<span id="document-c09/c09_03"></span><div class="section" id="pycharm">
<h3>9.3 【调试技巧】PyCharm跑完后立即进入调试模式<a class="headerlink" href="#pycharm" title="Permalink to this headline">¶</a></h3>
<p>假如我们在一个爬虫的项目中，会使用到 正则表达式
来匹配我们想要抓取的内容。正则这种东西，有几个人能够一步到位的呢，通常都需要经过很多次的调试才能按预期匹配。在我们改了一次正则后，运行了下，需要重新向网站抓取请求，才能发现没有匹配上，然后又改了一版，再次运行同样需要发起请求，结果还是发现还是没有匹配上，往往复复，正则不好的同学可能要进行几十次的尝试。</p>
<p>（上面这个例子可能不太贴切，毕竟是有很多种方法实现不用重新发请求，只是列举了一种很笨拙且低效的调试过程，你看看就好了）</p>
<p>而我们在这几十次的调试中，向同一网站发起请求都是没有意义的重复工作。如果在
Pycharm 中可以像 IPython Shell 和 Jupyter Notebook
那样，可以记住运行后所有的变量信息，可以在不需要重新运行项目或脚本，就可以通过执行命令表达式，来调整我们的代码，进行我们的正则调试。</p>
<p>答案当然是有。</p>
<p>假如我在调试如下几行简单的代码。在第 3 行处打了个断点。然后点击图示位置
<code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Python</span> <span class="pre">Prompt</span></code> 按钮。</p>
<p><img alt="image0" src="http://image.iswbm.com/Fi3N02x9OeOPatGdaReam_icn9G_" /></p>
<p>就进入了 <code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">Shell</span></code> 的界面，这个Shell
环境和我们当前运行的程序环境是打通的，变量之间可以互相访问，这下你可以轻松地进行调试了。</p>
<p><img alt="image1" src="http://image.iswbm.com/Fj1W53Txj0iFs5eYhFYh_dHlPtIL" /></p>
<p>上面我们打了个断点，是为了方便说明这个效果。并不是说一定要打断点。如果不打断点，在脚本执行完成后，也仍然可以在这个界面查看并操作所有变量。</p>
<p><img alt="image2" src="http://image.iswbm.com/FlMsB7B1x6ET9mLOgydTWuTEXuOe" /></p>
<p>现在我们已经可以满足我们的调试的需求，但是每次运行脚本，都要手动点击
<code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Python</span> <span class="pre">Prompt</span></code>
，有点麻烦。嗯？其实这个有地方可以设置默认打开的。这个开关还比较隐秘，一般人还真发现不了。</p>
<p>你需要点击图示位置 <code class="docutils literal notranslate"><span class="pre">Edit</span> <span class="pre">Configurations</span></code> 处。</p>
<p><img alt="image3" src="http://image.iswbm.com/FmfL3r0iWx_srT_xMASBEp1ZaaId" /></p>
<p>然后在这里打勾选中。</p>
<p><img alt="image4" src="http://image.iswbm.com/FiNCYpVlI93gk1zhOdQn4c0A8FMX" /></p>
<p>设置上之后，之后你每次运行后脚本后，都会默认为你存储所有变量的值，并为你打开
console 命令行调试界面。</p>
<p>除了上面这种方法，其实还有一种方法可以在调试过程中，执行命令表达式，而这种大家可能比较熟悉了，这边也提一下，就当是汇总一下。但是从功能上来说，是没有上面这种方法来得方便易用的。因为这种方法，必须要求你使用
debug 模式运行项目，并打断点。</p>
<p>使用方法就是，在你打了断点后，在图示位置处，点击右键使用
<code class="docutils literal notranslate"><span class="pre">Evaluate</span> <span class="pre">Expression</span></code></p>
<p><img alt="image5" src="http://image.iswbm.com/FrAq1tVRM7Bz948wRqZFzU2PQnI0" /></p>
<p>就弹出了一个 <code class="docutils literal notranslate"><span class="pre">Evaluate</span> <span class="pre">Expression</span></code> 窗口，这里
可以运行命令表达式，直接操作变量。</p>
<p><img alt="image6" src="http://image.iswbm.com/Fo2aEraqbj_2KqDt44EzJTVe8pEf" /></p>
</div>
<span id="document-c09/c09_04"></span><div class="section" id="id1">
<h3>9.4 【调试技巧】脚本报错后立即进入调试模式<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>当你在使用 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">xxx.py</span></code> 这样的方法，执行 Python 脚本时，若因为代码
bug 导致异常未捕获，那整个程序便会终止退出。</p>
<p>这个时候，我们通常会去排查是什么原因导致的程序崩溃。</p>
<p>大家都知道，排查问题的思路，第一步肯定是去查看日志，若这个 bug
隐藏的比较深，只有在特定场景下才会现身，那么还需要开发者，复现这个
bug，方能优化代码。</p>
<p>复现有时候很难，有时候虽然简单，但是要伪造各种数据，相当麻烦。</p>
<p>如果有一种方法能在程序崩溃后，立马进入调试模式该有多好啊？</p>
<p>明哥都这么问了，那肯定是带着解决方案来的。</p>
<p>只要你在执行脚本行，加上 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 参数，即可在脚本执行完毕后进入 Python
Shell 模式，方便你进行调试。</p>
<p>具体演示如下：</p>
<p><img alt="image0" src="http://image.iswbm.com/20200801195950.png" /></p>
<p>需要注意的是：脚本执行完毕，有两种情况：</p>
<ol class="arabic simple">
<li><p>正常退出</p></li>
<li><p>异常退出</p></li>
</ol>
<p>这两种都会进入 Python Shell，如果脚本并无异常，最终也会进入 Python Shell
模式，需要你手动退出</p>
<p><img alt="image1" src="http://image.iswbm.com/20200801201110.png" /></p>
</div>
<span id="document-c09/c09_05"></span><div class="section" id="pdb">
<h3>9.5 【调试技巧】使用 PDB 进行无界面调试<a class="headerlink" href="#pdb" title="Permalink to this headline">¶</a></h3>
<p>Pycharm 的图形化界面虽然好用，但是在某些场景中，是无法使用的。而 Python
本身已经给我们提供了一个调试神器 –
pdb，可能你还不知道它，为了讲解这个神器，我写了这篇文章来帮助你轻松的理解它。</p>
<div class="section" id="id1">
<h4>1. 准备文件<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>在调试之前先将这两个文件准备好（做为演示用），并放在同级目录中。</p>
<p><code class="docutils literal notranslate"><span class="pre">utils.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">item</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pdb_demo.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">utils</span>

<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;----start----&quot;</span><span class="p">)</span>
    <span class="n">myfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;----end-----&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 进入调试模式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>主要有两种方法</p>
<p>做为脚本调用，方法很简单，就像正常执行python脚本一样，只是多加了<code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">pdb</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ptyhon</span> <span class="o">-</span><span class="n">m</span> <span class="n">pdb</span> <span class="n">pdb_demo</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>使用这个方式进入调试模式，会在脚本的第一行开始单步调试。</p>
<p><img alt="image0" src="http://image.iswbm.com/20190118000111.png" /></p>
<p>对于单文件的脚本并没有什么问题，如果是一个大型的项目，项目里有很多的文件，使用这种方式只能大大降低我们的效率。</p>
<p>一般情况下，都会直接在你需要的地方打一个断点，那如何打呢？</p>
<p>只需在你想要打断点的地方加上这两行。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
</pre></div>
</div>
<p>然后执行时，也不需要再指定<code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">pdb</span></code>了，直接<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">pdb_demo.py</span></code>
，就会直接在这个地方暂停。</p>
<p><img alt="image1" src="http://image.iswbm.com/20190118000234.png" /></p>
<p><img alt="image2" src="http://image.iswbm.com/20190118000557.png" /></p>
</div>
<div class="section" id="id3">
<h4>3. 调试指令<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>熟悉 Pycharm 的人都知道，我们执行下一步，执行到下一个断点是</p>
<p>同样的，pdb 也需要你更多记这样的命令。</p>
<p>当你看到pdb模式的标识符 <code class="docutils literal notranslate"><span class="pre">(Pdb)</span></code>时，就可以输入这样的命令。</p>
<p>我在这里将这些指令按使用频度分为三个等级。</p>
<p><strong>最常用</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 26%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>指令</p></th>
<th class="head"><p>英文</p></th>
<th class="head"><p>解释</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>n</p></td>
<td><p>Next</p></td>
<td><p>下一步</p></td>
</tr>
<tr class="row-odd"><td><p>l</p></td>
<td><p>list</p></td>
<td><p>列出当前断点处源码</p></td>
</tr>
<tr class="row-even"><td><p>p</p></td>
<td><p>print</p></td>
<td><p>打印变量</p></td>
</tr>
<tr class="row-odd"><td><p>s</p></td>
<td><p>step into</p></td>
<td><p>执行当前行，可以进入函数</p></td>
</tr>
<tr class="row-even"><td><p>r</p></td>
<td><p>return</p></td>
<td><p>运行完当前函数，返回结果</p></td>
</tr>
<tr class="row-odd"><td><p>c</p></td>
<td><p>continue</p></td>
<td><p>执行到下一断点或者结束</p></td>
</tr>
<tr class="row-even"><td><p>b</p></td>
<td><p>break</p></td>
<td><p>设置断点</p></td>
</tr>
<tr class="row-odd"><td><p>q</p></td>
<td><p>quit</p></td>
<td><p>退出程序</p></td>
</tr>
</tbody>
</table>
<p><strong>有时使用</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 19%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>指令</p></th>
<th class="head"><p>英文</p></th>
<th class="head"><p>解释</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>a</p></td>
<td><p>args</p></td>
<td><p>列出当前函数的参数</p></td>
</tr>
<tr class="row-odd"><td><p>pp</p></td>
<td><p>pprint</p></td>
<td><p>一种可视化更好的打印</p></td>
</tr>
<tr class="row-even"><td><p>j</p></td>
<td><p>jump</p></td>
<td><p>跳到指定行</p></td>
</tr>
<tr class="row-odd"><td><p>cl</p></td>
<td><p>clear</p></td>
<td><p>清除断点</p></td>
</tr>
<tr class="row-even"><td><p>w</p></td>
<td><p>where</p></td>
<td><p>打印当前堆栈</p></td>
</tr>
<tr class="row-odd"><td><p>u</p></td>
<td><p>up</p></td>
<td><p>执行跳转到当前堆栈的上一层</p></td>
</tr>
<tr class="row-even"><td><p>unt</p></td>
<td><p>until</p></td>
<td><p>行数递增执行(忽略循环和函数)</p></td>
</tr>
<tr class="row-odd"><td><p>ll</p></td>
<td><p>longlist</p></td>
<td><p>列出更多的源码</p></td>
</tr>
<tr class="row-even"><td><p>run/restart</p></td>
<td><p>run</p></td>
<td><p>重新启动 debug(-m pdb)</p></td>
</tr>
</tbody>
</table>
<p><strong>几乎不用</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 37%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>指令</p></th>
<th class="head"><p>英文</p></th>
<th class="head"><p>解释</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tbreak</p></td>
<td><p>temporary break</p></td>
<td><p>临时断点</p></td>
</tr>
<tr class="row-odd"><td><p>disable</p></td>
<td></td>
<td><p>停用断点</p></td>
</tr>
<tr class="row-even"><td><p>enable</p></td>
<td></td>
<td><p>启用断点</p></td>
</tr>
<tr class="row-odd"><td><p>alias</p></td>
<td></td>
<td><p>设置别名</p></td>
</tr>
<tr class="row-even"><td><p>unalias</p></td>
<td></td>
<td><p>删除别名</p></td>
</tr>
<tr class="row-odd"><td><p>whatis</p></td>
<td></td>
<td><p>打印对象类型</p></td>
</tr>
<tr class="row-even"><td><p>ignore</p></td>
<td></td>
<td><p>设置忽略的断点</p></td>
</tr>
<tr class="row-odd"><td><p>source</p></td>
<td></td>
<td><p>列出给定对象的源码</p></td>
</tr>
</tbody>
</table>
<p>其上全部是我翻译自官方文档，原文在这里：<a class="reference external" href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a></p>
<p>其实你大可不必死记这些命令，忘记的时候，只要敲入<code class="docutils literal notranslate"><span class="pre">help</span></code>并回车，就可以看所有的指令了。</p>
<p><img alt="image3" src="http://image.iswbm.com/20190118083809.png" /></p>
</div>
<div class="section" id="id4">
<h4>4. 开始调试<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>这里就几个最常用的指定，来演示一遍。</p>
<p><img alt="image4" src="http://image.iswbm.com/20190118005507.png" /></p>
<p>这个调试过程，我加了些注释，你应该能够很轻易地理解这种调试方式。</p>
</div>
</div>
<span id="document-c09/c09_06"></span><div class="section" id="id1">
<h3>9.6 【调试技巧】如何调试已经运行的程序？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>官方原始wiki：<a class="reference external" href="https://wiki.python.org/moin/DebuggingWithGdb">https://wiki.python.org/moin/DebuggingWithGdb</a></p>
<p>在CentOS 下，安装包过程，官方给的不够详细。这里记录一下</p>
<p>先安装 yum-utils，装完后就能使用 debuginfo</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo yum install yum-utils
</pre></div>
</div>
<p>然后使用debuginfo 安装 glibc，不过在安装之前，有可能
你需要先配置debuginfo的仓库，编辑<code class="docutils literal notranslate"><span class="pre">/etc/yum.repos.d/CentOS-Debuginfo.repo</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#Debug Info
[debuginfo]
name=CentOS-$releasever - DebugInfo
# CentOS-4
#baseurl=http://debuginfo.centos.org/$releasever/
# CentOS-5
baseurl=http://debuginfo.centos.org/$releasever/$basearch/
gpgcheck=0
enabled=1
# CentOS-4
#gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-$releasever
# CentOS-5
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5
protect=1
</pre></div>
</div>
<p>然后就可以安装 <code class="docutils literal notranslate"><span class="pre">glibc</span></code> 了。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>yum --nogpgcheck --enablerepo<span class="o">=</span>debuginfo install glibc-debuginfo
sudo debuginfo-install glibc
</pre></div>
</div>
<p>最后安装 <code class="docutils literal notranslate"><span class="pre">python-debuginfo</span></code></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo yum install gdb python-debuginfo
</pre></div>
</div>
</div>
<span id="document-c09/c09_07"></span><div class="section" id="pysnopper">
<h3>9.7 【调试技巧】使用 PySnopper 调试疑难杂症<a class="headerlink" href="#pysnopper" title="Permalink to this headline">¶</a></h3>
<p>对于每个程序开发者来说，调试几乎是必备技能。</p>
<p>代码写到一半卡住了，不知道这个函数执行完的返回结果是怎样的？调试一下看看</p>
<p>代码运行到一半报错了，什么情况？怎么跟预期的不一样？调试一下看看</p>
<p>调试的方法多种多样，不同的调试方法适合不同的场景和人群。</p>
<ul class="simple">
<li><p>如果你是刚接触编程的小萌新，对很多工具的使用还不是很熟练，那么 print
和 log 大法好</p></li>
<li><p>如果你在本地（Win或者Mac）电脑上开发，那么 IDE
的图形化界面调试无疑是最适合的；</p></li>
<li><p>如果你在服务器上排查BUG，那么使用 PDB
进行无图形界面的调试应该是首选；</p></li>
<li><p>如果你要在本地进行开发，但是项目的进行需要依赖复杂的服务器环境，那么可以了解下
PyCharm 的远程调试</p></li>
</ul>
<p>除了以上，今天明哥再给你介绍一款非常好用的调试工具，它能在一些场景下，大幅度提高调试的效率，
那就是 <code class="docutils literal notranslate"><span class="pre">PySnooper</span></code>，它在 Github 上已经收到了 13k 的
star，获得大家的一致好评。</p>
<p><strong>有了这个工具后，就算是小萌新也可以直接无门槛上手，从此与 print
说再见~</strong></p>
<div class="section" id="id1">
<h4>1. 快速安装<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>执行下面这些命令进行安装 PySnooper</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pip install pysnooper

<span class="c1"># 或者</span>
$ conda install -c conda-forge pysnooper

<span class="c1"># 或者</span>
$ yay -S python-pysnooper
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 简单案例<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>下面这段代码，定义了一个 demo_func 的函数，在里面生成一个 profile
的字典变量，然后去更新它，最后返回。</p>
<p>代码本身没有什么实际意义，但是用来演示 PySnooper 已经足够。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pysnooper</span>

<span class="nd">@pysnooper.snoop</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="n">profile</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;写代码的明哥&quot;</span>
    <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">27</span>
    <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;male&quot;</span>

    <span class="k">return</span> <span class="n">profile</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">profile</span> <span class="o">=</span> <span class="n">demo_func</span><span class="p">()</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>现在我使用终端命令行的方式来运行它</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@iswbm ~<span class="o">]</span><span class="c1"># python3 demo.py</span>
Source path:... demo.py
<span class="m">17</span>:52:49.624943 call         <span class="m">4</span> def demo_func<span class="o">()</span>:
<span class="m">17</span>:52:49.625124 line         <span class="m">5</span>     <span class="nv">profile</span> <span class="o">=</span> <span class="o">{}</span>
New var:....... <span class="nv">profile</span> <span class="o">=</span> <span class="o">{}</span>
<span class="m">17</span>:52:49.625156 line         <span class="m">6</span>     profile<span class="o">[</span><span class="s2">&quot;name&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;写代码的明哥&quot;</span>
Modified var:.. <span class="nv">profile</span> <span class="o">=</span> <span class="o">{</span><span class="s1">&#39;name&#39;</span>: <span class="s1">&#39;写代码的明哥&#39;</span><span class="o">}</span>
<span class="m">17</span>:52:49.625207 line         <span class="m">7</span>     profile<span class="o">[</span><span class="s2">&quot;age&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="m">27</span>
Modified var:.. <span class="nv">profile</span> <span class="o">=</span> <span class="o">{</span><span class="s1">&#39;name&#39;</span>: <span class="s1">&#39;写代码的明哥&#39;</span>, <span class="s1">&#39;age&#39;</span>: <span class="m">27</span><span class="o">}</span>
<span class="m">17</span>:52:49.625254 line         <span class="m">8</span>     profile<span class="o">[</span><span class="s2">&quot;gender&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;male&quot;</span>
Modified var:.. <span class="nv">profile</span> <span class="o">=</span> <span class="o">{</span><span class="s1">&#39;name&#39;</span>: <span class="s1">&#39;写代码的明哥&#39;</span>, <span class="s1">&#39;age&#39;</span>: <span class="m">27</span>, <span class="s1">&#39;gender&#39;</span>: <span class="s1">&#39;male&#39;</span><span class="o">}</span>
<span class="m">17</span>:52:49.625306 line        <span class="m">10</span>     <span class="k">return</span> profile
<span class="m">17</span>:52:49.625344 <span class="k">return</span>      <span class="m">10</span>     <span class="k">return</span> profile
Return value:.. <span class="o">{</span><span class="s1">&#39;name&#39;</span>: <span class="s1">&#39;写代码的明哥&#39;</span>, <span class="s1">&#39;age&#39;</span>: <span class="m">27</span>, <span class="s1">&#39;gender&#39;</span>: <span class="s1">&#39;male&#39;</span><span class="o">}</span>
Elapsed time: <span class="m">00</span>:00:00.000486
</pre></div>
</div>
<p>可以看到 PySnooper 把函数运行的过程全部记录了下来，包括：</p>
<ul class="simple">
<li><p>代码的片段、行号等信息，以及每一行代码是何时调用的？</p></li>
<li><p>函数内局部变量的值如何变化的？何时新增了变量，何时修改了变量。</p></li>
<li><p>函数的返回值是什么？</p></li>
<li><p>运行函数消耗了多少时间？</p></li>
</ul>
<p>而作为开发者，要得到这些如此详细的调试信息，你需要做的非常简单，只要给你想要调试的函数上带上一顶帽子（装饰器）
– <code class="docutils literal notranslate"><span class="pre">&#64;pysnooper.snoop()</span></code> 即可。</p>
</div>
<div class="section" id="id3">
<h4>3. 详细使用<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id4">
<h5>2.1 重定向到日志文件<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">&#64;pysnooper.snoop()</span></code>
不加任何参数时，会默认将调试的信息输出到标准输出。</p>
<p>对于单次调试就能解决的 BUG ，这样没有什么问题，但是有一些 BUG
只有在特定的场景下才会出现，需要你把程序放在后面跑个一段时间才能复现。</p>
<p>这种情况下，你可以将调试信息重定向输出到某一日志文件中，方便追溯排查。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;/var/log/debug.log&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>2.2 跟踪非局部变量值<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>PySnooper
是以函数为单位进行调试的，它默认只会跟踪函数体内的局部变量，若想跟踪全局变量，可以给
<code class="docutils literal notranslate"><span class="pre">&#64;pysnooper.snoop()</span></code> 加上 <code class="docutils literal notranslate"><span class="pre">watch</span></code> 参数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">}</span>

<span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">watch</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;out[&quot;foo&quot;]&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如此一来，PySnooper 会在 <code class="docutils literal notranslate"><span class="pre">out[&quot;foo&quot;]</span></code> 值有变化时，也将其打印出来</p>
<p><img alt="image0" src="http://image.iswbm.com/20201114183018.png" /></p>
<p>watch 参数，接收一个可迭代对象（可以是list 或者
tuple），里面的元素为字符串表达式，什么意思呢？看下面例子就知道了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">watch</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;out[&quot;foo&quot;]&#39;</span><span class="p">,</span> <span class="s1">&#39;foo.bar&#39;</span><span class="p">,</span> <span class="s1">&#39;self.foo[&quot;bar&quot;]&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>和 <code class="docutils literal notranslate"><span class="pre">watch</span></code> 相对的，<code class="docutils literal notranslate"><span class="pre">pysnooper.snoop()</span></code> 还可以接收一个函数
<code class="docutils literal notranslate"><span class="pre">watch_explode</span></code>，表示除了这几个参数外的其他所有全局变量都监控。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">watch_explode</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>2.3 设置跟踪函数的深度<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>当你使用 PySnooper 调试某个函数时，若该函数中还调用了其他函数，PySnooper
是不会傻傻的跟踪进去的。</p>
<p>如果你想继续跟踪该函数中调用的其他函数，可以通过指定 <code class="docutils literal notranslate"><span class="pre">depth</span></code>
参数来设置跟踪深度（不指定的话默认为 1）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>2.4 设置调试日志的前缀<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>当你在使用 PySnooper
跟踪多个函数时，调试的日志会显得杂乱无章，不方便查看。</p>
<p>在这种情况下，PySnooper
提供了一个参数，方便你为不同的函数设置不同的标志，方便你在查看日志时进行区分。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;/var/log/debug.log&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;demo_func: &quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>效果如下</p>
<p><img alt="image1" src="http://image.iswbm.com/20201114193131.png" /></p>
</div>
<div class="section" id="id8">
<h5>2.5 设置最大的输出长度<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>默认情况下，PySnooper 输出的变量和异常信息，如果超过 100
个字符，被会截断为 100 个字符。</p>
<p>当然你也可以通过指定参数 进行修改</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>@pysnooper.snoop(max_variable_length=200）
def demo_func():
    ...
</pre></div>
</div>
<p>您也可以使用max_variable_length=None它从不截断它们。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>@pysnooper.snoop(max_variable_length=None）
def demo_func():
    ...
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h5>2.6 支持多线程调试模式<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>PySnooper 同样支持多线程的调试，通过设置参数
<code class="docutils literal notranslate"><span class="pre">thread_info=True</span></code>，它就会在日志中打印出是在哪个线程对变量进行的修改。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">thread_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>效果如下</p>
<p><img alt="image2" src="http://image.iswbm.com/20201114194449.png" /></p>
</div>
<div class="section" id="id10">
<h5>2.7 自定义对象的格式输出<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">pysnooper.snoop()</span></code> 函数有一个参数是
<code class="docutils literal notranslate"><span class="pre">custom_repr</span></code>，它接收一个元组对象。</p>
<p>在这个元组里，你可以指定特定类型的对象以特定格式进行输出。</p>
<p>这边我举个例子。</p>
<p>假如我要跟踪 person 这个 Person 类型的对象，由于它不是常规的 Python
基础类型，PySnooper 是无法正常输出它的信息的。</p>
<p>因此我在 <code class="docutils literal notranslate"><span class="pre">pysnooper.snoop()</span></code> 函数中设置了 <code class="docutils literal notranslate"><span class="pre">custom_repr</span></code>
参数，该参数的第一个元素为 Person，第二个元素为 <code class="docutils literal notranslate"><span class="pre">print_persion_obj</span></code>
函数。</p>
<p>PySnooper 在打印对象的调试信息时，会逐个判断它是否是 Person
类型的对象，若是，就将该对象传入 <code class="docutils literal notranslate"><span class="pre">print_persion_obj</span></code>
函数中，由该函数来决定如何显示这个对象的信息。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span><span class="k">pass</span>

<span class="k">def</span> <span class="nf">print_person_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;Person {obj.name} {obj.age} {obj.gender}&gt;&quot;</span>

<span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">custom_repr</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">print_person_obj</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>完整的代码如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pysnooper</span>

<span class="k">class</span> <span class="nc">Person</span><span class="p">:</span><span class="k">pass</span>


<span class="k">def</span> <span class="nf">print_person_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;Person {obj.name} {obj.age} {obj.gender}&gt;&quot;</span>

<span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">custom_repr</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">print_person_obj</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
    <span class="n">person</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;写代码的明哥&quot;</span>
    <span class="n">person</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">27</span>
    <span class="n">person</span><span class="o">.</span><span class="n">gender</span> <span class="o">=</span> <span class="s2">&quot;male&quot;</span>

    <span class="k">return</span> <span class="n">person</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">profile</span> <span class="o">=</span> <span class="n">demo_func</span><span class="p">()</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>运行一下，观察一下效果。</p>
<p><img alt="image3" src="http://image.iswbm.com/20201114201042.png" /></p>
<p>如果你要自定义格式输出的有很多个类型，那么 <code class="docutils literal notranslate"><span class="pre">custom_repr</span></code>
参数的值可以这么写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">custom_repr</span><span class="o">=</span><span class="p">((</span><span class="n">Person</span><span class="p">,</span> <span class="n">print_person_obj</span><span class="p">),</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">print_ndarray</span><span class="p">)))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>还有一点我提醒一下，元组的第一个元素可以是类型（如类名Person
或者其他基础类型 list等），也可以是一个判断对象类型的函数。</p>
<p>也就是说，下面三种写法是等价的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 【第一种写法】</span>
<span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">custom_repr</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">print_persion_obj</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>


<span class="c1"># 【第二种写法】</span>
<span class="k">def</span> <span class="nf">is_persion_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Person</span><span class="p">)</span>

<span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">custom_repr</span><span class="o">=</span><span class="p">(</span><span class="n">is_persion_obj</span><span class="p">,</span> <span class="n">print_persion_obj</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>


<span class="c1"># 【第三种写法】</span>
<span class="nd">@pysnooper.snoop</span><span class="p">(</span><span class="n">custom_repr</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Person</span><span class="p">),</span> <span class="n">print_persion_obj</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">demo_func</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>以上就是明哥今天给大家介绍的一款调试神器（<code class="docutils literal notranslate"><span class="pre">PySnooper</span></code>）
的详细使用手册，是不是觉得还不错？</p>
</div>
</div>
</div>
<span id="document-c09/c09_08"></span><div class="section" id="pycharm">
<h3>9.8 【调试技巧】使用 PyCharm 进行远程调试<a class="headerlink" href="#pycharm" title="Permalink to this headline">¶</a></h3>
<p>一般情况下，我们开发调试都是在个人PC上完成，遇到问题，开一下 <code class="docutils literal notranslate"><span class="pre">Pycharm</span></code>
的调试器，很快就能找到问题所在。</p>
<p>可有些时候，项目代码的运行会对运行环境有依赖，必须在部署了相关依赖组件的服务器上才可以运行，这就直接导致了我们不能在本地进行调试。</p>
<p>对于这种特殊的场景，就我所知，有如下两种解决方案：</p>
<ul class="simple">
<li><p>pdb</p></li>
<li><p>Remote Debug</p></li>
</ul>
<p>本篇文章会先讲第二种方案，它是 <code class="docutils literal notranslate"><span class="pre">专业版Pycharm</span></code>
才开放的功能，需要你安装专业版的Pycharm，具体升级破解步骤，请自行
Google，这里不涉及。</p>
<p>远程调试的意思，是让我们可以在我们在 PC 上用 Pycharm
的图形化界面来进行调试代码，它和本地调试没有太大的区别，原来怎么调试的现在还是怎么调试。</p>
<p>区别就在于，本地调试不需要事前配置，只要你的代码准备好了，随时可以开始
Debug 。而远程调试需要不少前置步骤，这些设置过程，也是本文的主要内容。</p>
<div class="section" id="id1">
<h4>1. 新建一个项目<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>首先，要在Pycharm中新建一个空的项目，后面我们拉服务器上的项目代码就会放置在这个项目目录下。我这边的名字是
NOVA，你可以自己定义。</p>
<p><img alt="image0" src="http://image.iswbm.com/20190113104817.png" /></p>
</div>
<div class="section" id="id2">
<h4>2. 配置连接服务器<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Tools -&gt; Deployment -&gt; configuration</p>
<p><img alt="image1" src="http://image.iswbm.com/20190113105512.png" /></p>
<p>添加一个<code class="docutils literal notranslate"><span class="pre">Server</span></code></p>
<ul class="simple">
<li><p>Name：填你的服务器的IP</p></li>
<li><p>Type：设定为SFTP</p></li>
</ul>
<p><img alt="image2" src="http://image.iswbm.com/20190113105858.png" /></p>
<p>点击<code class="docutils literal notranslate"><span class="pre">OK</span></code>后，进入如下界面，你可以按我的备注，填写信息：</p>
<ul class="simple">
<li><p>SFTP host：公网ip</p></li>
<li><p>Port：服务器开放的ssh端口</p></li>
<li><p>Root path：你要调试的项目代码目录</p></li>
<li><p>Username：你登陆服务器所用的用户</p></li>
<li><p>Auth type：登陆类型，若用密码登陆的就是Password</p></li>
<li><p>Password：选密码登陆后，这边输入你的登陆密码，可以选择保存密码。</p></li>
</ul>
<p>这里请注意，要确保你的电脑可以ssh连接到你的服务器，不管是密钥登陆还是密码登陆，如果开启了白名单限制要先解除。</p>
<p><img alt="image3" src="http://image.iswbm.com/20190113105931.png" /></p>
<p>填写完成后，切换到<code class="docutils literal notranslate"><span class="pre">Mappings</span></code>选项卡，在箭头位置，填写<code class="docutils literal notranslate"><span class="pre">\</span></code></p>
<p><img alt="image4" src="http://image.iswbm.com/20190113110928.png" /></p>
<p>以上服务器信息配置，全部正确填写完成后，点击<code class="docutils literal notranslate"><span class="pre">OK</span></code></p>
<p>接下来，我们要连接远程服务器了。 Tools -&gt; Deployment -&gt; Browse Remote
Host</p>
<p><img alt="image5" src="http://image.iswbm.com/20190113111042.png" /></p>
</div>
<div class="section" id="id3">
<h4>3. 下载项目代码<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>如果之前填写的服务器登陆信息准确无误的话，现在就可以看到远程的项目代码。</p>
<p><img alt="image6" src="http://image.iswbm.com/20190113111151.png" /></p>
<p>选择下载远程代码要本地。</p>
<p><img alt="image7" src="http://image.iswbm.com/20190113111217.png" /></p>
<p>下载完成提示。</p>
<p><img alt="image8" src="http://image.iswbm.com/20190113111248.png" /></p>
<p>现在的IDE界面应该是这样子的。</p>
<p><img alt="image9" src="http://image.iswbm.com/20190113111307.png" /></p>
</div>
<div class="section" id="id4">
<h4>4. 下载远程解释器<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>为什么需要这步呢？</p>
<p>远程调试是在远端的服务器上运行的，它除了依赖其他组件之外，还会有一些很多Python依赖包我们本地并没有。</p>
<p>进入 File -&gt; Settings 按图示，添加远程解释器。</p>
<p><img alt="image10" src="http://image.iswbm.com/20190113111747.png" /></p>
<p>填写远程服务器信息，跟之前的一样，不再赘述。</p>
<p><img alt="image11" src="http://image.iswbm.com/20190113111828.png" /></p>
<p>点击<code class="docutils literal notranslate"><span class="pre">OK</span></code>后，会自动下载远程解释器。如果你的项目比较大，这个时间可能会比较久，请耐心等待。</p>
</div>
<div class="section" id="id5">
<h4>5. 添加程序入口<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>因为我们要在本地DEBUG，所以你一定要知道你的项目的入口程序。如果这个入口程序已经包含在你的项目代码中，那么请略过这一步。</p>
<p>如果没有，就请自己生成入口程序。</p>
<p>比如，我这边的项目，在服务器上是以一个服务运行的。而我们都知道服务的入口是<code class="docutils literal notranslate"><span class="pre">Service文件</span></code>。
<code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/usr/lib/systemd/system/openstack-nova-compute.service</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">OpenStack</span> <span class="n">Nova</span> <span class="n">Compute</span> <span class="n">Server</span>
<span class="n">After</span><span class="o">=</span><span class="n">syslog</span><span class="o">.</span><span class="n">target</span> <span class="n">network</span><span class="o">.</span><span class="n">target</span> <span class="n">libvirtd</span><span class="o">.</span><span class="n">service</span>

<span class="p">[</span><span class="n">Service</span><span class="p">]</span>
<span class="n">Environment</span><span class="o">=</span><span class="n">LIBGUESTFS_ATTACH_METHOD</span><span class="o">=</span><span class="n">appliance</span>
<span class="n">Type</span><span class="o">=</span><span class="n">notify</span>
<span class="n">NotifyAccess</span><span class="o">=</span><span class="nb">all</span>
<span class="n">TimeoutStartSec</span><span class="o">=</span><span class="mi">0</span>
<span class="n">Restart</span><span class="o">=</span><span class="n">always</span>
<span class="n">User</span><span class="o">=</span><span class="n">nova</span>
<span class="n">ExecStart</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">nova</span><span class="o">-</span><span class="n">compute</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>看到那个<code class="docutils literal notranslate"><span class="pre">ExecStart</span></code>没有？那个就是我们程序的入口。
我们只要将其拷贝至我们的Pycharm中，并向远程同步该文件。</p>
<p><img alt="image12" src="http://image.iswbm.com/20190113112004.png" /></p>
</div>
<div class="section" id="id6">
<h4>6. 调试前设置<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>开启代码自动同步，这样，我们对代码的修改Pycharm都能识别，并且为我们提交到远程服务器。</p>
<p><img alt="image13" src="http://image.iswbm.com/20190113112055.png" /></p>
<p>开启
<code class="docutils literal notranslate"><span class="pre">Gevent</span> <span class="pre">compatible</span></code>，如果不开启，在调试过程中，很可能出现无法调试，或者无法追踪/查看变量等问题。</p>
<p><img alt="image14" src="http://image.iswbm.com/20190113113211.png" /></p>
</div>
<div class="section" id="id7">
<h4>7. 开始调试代码<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>在你的程序入口文件处，点击右键，选择Debug即可。</p>
<p>如果你的程序入口，需要引入参数，这是经常有的事，可以的这里配置。</p>
<p><img alt="image15" src="http://image.iswbm.com/20190113112456.png" /></p>
<p>配置完点击保存即可。</p>
<p><img alt="image16" src="http://image.iswbm.com/20190113112649.png" /></p>
</div>
<div class="section" id="id8">
<h4>8. 友情提醒<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>按照文章的试调试代码，会自动同步代码至远端，千万不要在生产环境使用，一定要在开发环境中使用，否则后果自负。</p>
<p>调试工具给了程序员提供了很大的便利，但还是希望你不要过度依赖。尽量在每次写代码的时候，都追求一次成型，提高自己的编码能力。</p>
</div>
</div>
<span id="document-c09/c09_09"></span><div class="section" id="id1">
<h3>9.9 【调试技巧】如何调试已经运行的程序？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>官方原始wiki：<a class="reference external" href="https://wiki.python.org/moin/DebuggingWithGdb">https://wiki.python.org/moin/DebuggingWithGdb</a></p>
<p>在CentOS 下，安装包过程，官方给的不够详细。这里记录一下</p>
<p>先安装 yum-utils，装完后就能使用 debuginfo</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo yum install yum-utils
</pre></div>
</div>
<p>然后使用debuginfo 安装 glibc，不过在安装之前，有可能
你需要先配置debuginfo的仓库，编辑<code class="docutils literal notranslate"><span class="pre">/etc/yum.repos.d/CentOS-Debuginfo.repo</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#Debug Info
[debuginfo]
name=CentOS-$releasever - DebugInfo
# CentOS-4
#baseurl=http://debuginfo.centos.org/$releasever/
# CentOS-5
baseurl=http://debuginfo.centos.org/$releasever/$basearch/
gpgcheck=0
enabled=1
# CentOS-4
#gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-$releasever
# CentOS-5
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5
protect=1
</pre></div>
</div>
<p>然后就可以安装 <code class="docutils literal notranslate"><span class="pre">glibc</span></code> 了。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ yum --nogpgcheck --enablerepo<span class="o">=</span>debuginfo install glibc-debuginfo
$ sudo debuginfo-install glibc
</pre></div>
</div>
<p>最后安装 <code class="docutils literal notranslate"><span class="pre">python-debuginfo</span></code></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo yum install gdb python-debuginfo
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p10"></span><div class="section" id="id1">
<h2>第十章：并发编程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c10/c10_01"></span><div class="section" id="id1">
<h3>10.1 【并发编程】从性能角度初探并发编程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 基本概念<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在开始讲解理论知识之前，先过一下几个基本概念。虽然咱是进阶教程，但我也希望写得更小白，更通俗易懂。</p>
<p><code class="docutils literal notranslate"><span class="pre">串行</span></code>：一个人在同一时间段只能干一件事，譬如吃完饭才能看电视；
<code class="docutils literal notranslate"><span class="pre">并行</span></code>：一个人在同一时间段可以干多件事，譬如可以边吃饭边看电视；</p>
<p>在Python中，<code class="docutils literal notranslate"><span class="pre">多线程</span></code> 和 <code class="docutils literal notranslate"><span class="pre">协程</span></code>
虽然是严格上来说是串行，但却比一般的串行程序执行效率高得很。
一般的串行程序，在程序阻塞的时候，只能干等着，不能去做其他事。就好像，电视上播完正剧，进入广告时间，我们却不能去趁广告时间是吃个饭。对于程序来说，这样做显然是效率极低的，是不合理的。</p>
<p>当然，学完这个课程后，我们就懂得，利用广告时间去做其他事，灵活安排时间。这也是我们<code class="docutils literal notranslate"><span class="pre">多线程</span></code>和<code class="docutils literal notranslate"><span class="pre">协程</span></code>
要帮我们要完成的事情，内部合理调度任务，使得程序效率最大化。</p>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">多线程</span></code> 和 <code class="docutils literal notranslate"><span class="pre">协程</span></code>
已经相当智能了。但还是不够高效，最高效的应该是一心多用，边看电视边吃饭边聊天。这就是我们的
<code class="docutils literal notranslate"><span class="pre">多进程</span></code> 才能做的事了。</p>
<p>为了更帮助大家更加直观的理解，在网上找到两张图，来生动形象的解释了多线程和多进程的区别。（侵删）</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">多线程</span></code>，交替执行，另一种意义上的串行。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">多进程</span></code>，并行执行，真正意义上的并发。</p></li>
</ul>
<p><img alt="image0" src="http://image.iswbm.com/20201219162110.png" /></p>
</div>
<div class="section" id="vsvs">
<h4>2. 单线程VS多线程VS多进程<a class="headerlink" href="#vsvs" title="Permalink to this headline">¶</a></h4>
<p>文字总是苍白无力的，不如用代码直接来测试一下。</p>
<p>在开始之前呢，我要声明一下，本文作为并发章节的第一篇文章，只为了让你对单线程、多线程、多进程有个直观的了解。因此下面的代码中，会有多线程和多进程的的知识点，这些知识点在后面几节才会讲到，如果你看不明白也没有关系。</p>
<p>我的实验环境配置如下</p>
<p><img alt="image1" src="http://image.iswbm.com/20190112205155.png" /></p>
<p>开始对比之前，首先定义四种类型的场景 - CPU计算密集型 - 磁盘IO密集型 -
网络IO密集型 - 【模拟】IO密集型</p>
<p>为什么是这几种场景，这和<code class="docutils literal notranslate"><span class="pre">多线程</span></code>
<code class="docutils literal notranslate"><span class="pre">多进程</span></code>的适用场景有关。结论里，我再说明。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CPU计算密集型</span>
<span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># 使程序完成150万计算</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">500000</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">y</span>


<span class="c1"># 磁盘读写IO密集型</span>
<span class="k">def</span> <span class="nf">io_disk</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;file.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5000000</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;python-learning</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># 网络IO密集型</span>
<span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;User-Agent&#39;</span><span class="p">:</span> <span class="s1">&#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&#39;</span><span class="p">}</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://www.tieba.com/&quot;</span>

<span class="k">def</span> <span class="nf">io_request</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">webPage</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">webPage</span><span class="o">.</span><span class="n">text</span>
        <span class="k">return</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="n">e</span><span class="p">}</span>


<span class="c1"># 【模拟】IO密集型</span>
<span class="k">def</span> <span class="nf">io_simulation</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>比拼的指标，我们用时间来考量。时间耗费得越少，说明效率越高。</p>
<p>为了方便，使得代码看起来，更加简洁，我这里先定义是一个简单的
<code class="docutils literal notranslate"><span class="pre">时间计时器</span></code> 的装饰器。
如果你对装饰器还不是很了解，也没关系，你只要知道它是用于
计算函数运行时间的东西就可以了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">t1</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">t2</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">cost_time</span> <span class="o">=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{}-{}花费时间：{}秒&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span><span class="n">cost_time</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">deco</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>第一步，先来看看单线程的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@timer</span><span class="p">(</span><span class="s2">&quot;【单线程】&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">single_thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
              <span class="n">func</span><span class="p">()</span>

<span class="c1"># 单线程</span>
<span class="n">single_thread</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;CPU计算密集型&quot;</span><span class="p">)</span>
<span class="n">single_thread</span><span class="p">(</span><span class="n">io_disk</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;磁盘IO密集型&quot;</span><span class="p">)</span>
<span class="n">single_thread</span><span class="p">(</span><span class="n">io_request</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;网络IO密集型&quot;</span><span class="p">)</span>
<span class="n">single_thread</span><span class="p">(</span><span class="n">io_simulation</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;模拟IO密集型&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>看看结果</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>【单线程】-CPU计算密集型花费时间：83.42633867263794秒
【单线程】-磁盘IO密集型花费时间：15.641993284225464秒
【单线程】-网络IO密集型花费时间：1.1397218704223633秒
【单线程】-模拟IO密集型花费时间：20.020972728729248秒
</pre></div>
</div>
<p>第二步，再来看看多线程的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@timer</span><span class="p">(</span><span class="s2">&quot;【多线程】&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">multi_thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">thread_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">t</span><span class="o">=</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
        <span class="n">thread_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thread_list</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">thread_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">th</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
                <span class="n">e</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

<span class="c1"># 多线程</span>
<span class="n">multi_thread</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;CPU计算密集型&quot;</span><span class="p">)</span>
<span class="n">multi_thread</span><span class="p">(</span><span class="n">io_disk</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;磁盘IO密集型&quot;</span><span class="p">)</span>
<span class="n">multi_thread</span><span class="p">(</span><span class="n">io_request</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;网络IO密集型&quot;</span><span class="p">)</span>
<span class="n">multi_thread</span><span class="p">(</span><span class="n">io_simulation</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;模拟IO密集型&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>看看结果</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>【多线程】-CPU计算密集型花费时间：93.82986998558044秒
【多线程】-磁盘IO密集型花费时间：13.270896911621094秒
【多线程】-网络IO密集型花费时间：0.1828296184539795秒
【多线程】-模拟IO密集型花费时间：2.0288875102996826秒
</pre></div>
</div>
<p>第三步，最后来看看多进程</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@timer</span><span class="p">(</span><span class="s2">&quot;【多进程】&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">multi_process</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">process_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
        <span class="n">process_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">process_list</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pr</span> <span class="ow">in</span> <span class="n">process_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pr</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
                <span class="n">e</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

<span class="c1"># 多进程</span>
<span class="n">multi_process</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;CPU计算密集型&quot;</span><span class="p">)</span>
<span class="n">multi_process</span><span class="p">(</span><span class="n">io_disk</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;磁盘IO密集型&quot;</span><span class="p">)</span>
<span class="n">multi_process</span><span class="p">(</span><span class="n">io_request</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;网络IO密集型&quot;</span><span class="p">)</span>
<span class="n">multi_process</span><span class="p">(</span><span class="n">io_simulation</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;模拟IO密集型&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>看看结果</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>【多进程】-CPU计算密集型花费时间：9.082211017608643秒
【多进程】-磁盘IO密集型花费时间：1.287339448928833秒
【多进程】-网络IO密集型花费时间：0.13074755668640137秒
【多进程】-模拟IO密集型花费时间：2.0076842308044434秒
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 性能对比成果总结<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>将结果汇总一下，制成表格。</p>
<p><img alt="image2" src="http://image.iswbm.com/20190112204930.png" /></p>
<p>我们来分析下这个表格。</p>
<p>首先是<code class="docutils literal notranslate"><span class="pre">CPU密集型</span></code>，多线程以对比单线程，不仅没有优势，显然还由于要不断的加锁释放GIL全局锁，切换线程而耗费大量时间，效率低下，而多进程，由于是多个CPU同时进行计算工作，相当于十个人做一个人的作业，显然效率是成倍增长的。</p>
<p>然后是IO密集型，<code class="docutils literal notranslate"><span class="pre">IO密集型</span></code>可以是<code class="docutils literal notranslate"><span class="pre">磁盘IO</span></code>，<code class="docutils literal notranslate"><span class="pre">网络IO</span></code>，<code class="docutils literal notranslate"><span class="pre">数据库IO</span></code>等，都属于同一类，计算量很小，主要是IO等待时间的浪费。通过观察，可以发现，我们磁盘IO，网络IO的数据，多线程对比单线程也没体现出很大的优势来。这是由于我们程序的的IO任务不够繁重，所以优势不够明显。</p>
<p>所以我还加了一个「<code class="docutils literal notranslate"><span class="pre">模拟IO密集型</span></code>」，用<code class="docutils literal notranslate"><span class="pre">sleep</span></code>来模拟IO等待时间，就是为了体现出多线程的优势，也能让大家更加直观的理解多线程的工作过程。单线程需要每个线程都要<code class="docutils literal notranslate"><span class="pre">sleep(2)</span></code>，10个线程就是<code class="docutils literal notranslate"><span class="pre">20s</span></code>，而多线程，在<code class="docutils literal notranslate"><span class="pre">sleep(2)</span></code>的时候，会切换到其他线程，使得10个线程同时<code class="docutils literal notranslate"><span class="pre">sleep(2)</span></code>，最终10个线程也就只有<code class="docutils literal notranslate"><span class="pre">2s</span></code>.</p>
<p>可以得出以下几点结论 - 单线程总是最慢的，多进程总是最快的。 -
多线程适合在IO密集场景下使用，譬如爬虫，网站开发等 -
多进程适合在对CPU计算运算要求较高的场景下使用，譬如大数据分析，机器学习等
-
多进程虽然总是最快的，但是不一定是最优的选择，因为它需要CPU资源支持下才能体现优势</p>
</div>
</div>
<span id="document-c10/c10_02"></span><div class="section" id="id1">
<h3>10.2 【并发编程】创建多线程的几种方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>今天的内容会比较基础，主要是为了让新手也能无障碍地阅读，所以还是要再巩固下基础。学完了基础，你们也就能很顺畅地跟着我的思路理解以后的文章。</p>
<p>经过总结，Python创建多线程主要有如下两种方法：</p>
<ul class="simple">
<li><p>函数</p></li>
<li><p>类</p></li>
</ul>
<p>接下来，我们就来揭开多线程的神秘面纱。</p>
<div class="section" id="id2">
<h4>1. 用函数创建多线程<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在Python3中，Python提供了一个内置模块
<code class="docutils literal notranslate"><span class="pre">threading.Thread</span></code>，可以很方便地让我们创建多线程。</p>
<p><code class="docutils literal notranslate"><span class="pre">threading.Thread()</span></code> 一般接收两个参数：</p>
<ul class="simple">
<li><p>线程函数名：要放置线程让其后台执行的函数，由我们自已定义，注意不要加<code class="docutils literal notranslate"><span class="pre">()</span></code>；</p></li>
<li><p>线程函数的参数：线程函数名所需的参数，以元组的形式传入。若不需要参数，可以不指定。</p></li>
</ul>
<p><strong>举个例子</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="c1"># 自定义线程函数。</span>
<span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 创建线程01，不指定参数</span>
<span class="n">thread_01</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="c1"># 启动线程01</span>
<span class="n">thread_01</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>


<span class="c1"># 创建线程02，指定参数，注意逗号</span>
<span class="n">thread_02</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;MING&quot;</span><span class="p">,))</span>
<span class="c1"># 启动线程02</span>
<span class="n">thread_02</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>可以看到输出</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hello</span> <span class="n">Python</span>
<span class="n">hello</span> <span class="n">MING</span>
<span class="n">hello</span> <span class="n">Python</span>
<span class="n">hello</span> <span class="n">MING</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>2. 用类创建多线程<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>相比较函数而言，使用类创建线程，会比较麻烦一点。</p>
<p>首先，我们要自定义一个类，对于这个类有两点要求，</p>
<ul class="simple">
<li><p>必须继承 <code class="docutils literal notranslate"><span class="pre">threading.Thread</span></code> 这个父类；</p></li>
<li><p>必须复写 <code class="docutils literal notranslate"><span class="pre">run</span></code> 方法。</p></li>
</ul>
<p>这里的 <code class="docutils literal notranslate"><span class="pre">run</span></code>
方法，和我们上面<code class="docutils literal notranslate"><span class="pre">线程函数</span></code>的性质是一样的，可以写我们的业务逻辑程序。在
<code class="docutils literal notranslate"><span class="pre">start()</span></code> 后将会调用。</p>
<p>来看一下例子 为了方便对比，<code class="docutils literal notranslate"><span class="pre">run</span></code>函数我复用上面的<code class="docutils literal notranslate"><span class="pre">main</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">class</span> <span class="nc">MyThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">):</span>
        <span class="c1"># 注意：super().__init__() 必须写</span>
        <span class="c1"># 且最好写在第一行</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="nb">type</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 创建线程01，不指定参数</span>
    <span class="n">thread_01</span> <span class="o">=</span> <span class="n">MyThread</span><span class="p">()</span>
    <span class="c1"># 创建线程02，指定参数</span>
    <span class="n">thread_02</span> <span class="o">=</span> <span class="n">MyThread</span><span class="p">(</span><span class="s2">&quot;MING&quot;</span><span class="p">)</span>

    <span class="n">thread_01</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">thread_02</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>当然结果也是一样的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hello</span> <span class="n">Python</span>
<span class="n">hello</span> <span class="n">MING</span>
<span class="n">hello</span> <span class="n">Python</span>
<span class="n">hello</span> <span class="n">MING</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>3. 线程对象的方法<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>上面介绍了当前 Python 中创建线程两种主要方法。</p>
<p>创建线程是件很容易的事，但要想用好线程，还需要学习线程对象的几个函数。</p>
<p>经过我的总结，大约常用的方法有如下这些：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 如上所述，创建一个线程</span>
<span class="n">t</span><span class="o">=</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>

<span class="c1"># 启动子线程</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># 阻塞子线程，待子线程结束后，再往下执行</span>
<span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="c1"># 判断线程是否在执行状态，在执行返回True，否则返回False</span>
<span class="n">t</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">isAlive</span><span class="p">()</span>

<span class="c1"># 设置线程是否随主线程退出而退出，默认为False</span>
<span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c1"># 设置线程名</span>
<span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;My-Thread&quot;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c10/c10_03"></span><div class="section" id="id1">
<h3>10.3 【并发编程】谈谈线程中的“锁机制”<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 什么是锁？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在开发中，<strong>锁</strong> 可以理解为通行证。</p>
<p>当你对一段逻辑代码加锁时，意味着在同一时间有且仅能有一个线程在执行这段代码。</p>
<p>在 Python 中的锁可以分为两种：</p>
<ol class="arabic simple">
<li><p>互斥锁</p></li>
<li><p>可重入锁</p></li>
</ol>
</div>
<div class="section" id="id3">
<h4>2. 互斥锁的使用<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>来简单看下代码，学习如何加锁，获取钥匙，释放锁。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="c1"># 生成锁对象，全局唯一</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="c1"># 获取锁。未获取到会阻塞程序，直到获取到锁才会往下执行</span>
<span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

<span class="c1"># 释放锁，归还锁，其他人可以拿去用了</span>
<span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>需要注意的是，lock.acquire() 和
lock.release()必须成对出现。否则就有可能造成死锁。</p>
<p>很多时候，我们虽然知道，他们必须成对出现，但是还是难免会有忘记的时候。
为了，规避这个问题。我推荐使用使用上下文管理器来加锁。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># 这里写自己的代码</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">with</span></code> 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p>
</div>
<div class="section" id="id4">
<h4>3. 为何要使用锁？<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>你现在肯定还是一脸懵逼，这么麻烦，我不用锁不行吗？有的时候还真不行。</p>
<p>那么为了说明锁存在的意义。我们分别来看下，不用锁的情形有怎样的问题。</p>
<p>定义两个函数，分别在两个线程中执行。这两个函数 <code class="docutils literal notranslate"><span class="pre">共用</span></code> 一个变量 <code class="docutils literal notranslate"><span class="pre">n</span></code>
。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">job1</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;job1&#39;</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">job2</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">n</span><span class="o">+=</span><span class="mi">10</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;job2&#39;</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="n">n</span><span class="o">=</span><span class="mi">0</span>
<span class="n">t1</span><span class="o">=</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">job1</span><span class="p">)</span>
<span class="n">t2</span><span class="o">=</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">job2</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>看代码貌似没什么问题，执行下看看输出</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">job1</span> <span class="mi">1</span>
<span class="n">job1</span> <span class="mi">2</span>
<span class="n">job1</span> <span class="n">job2</span> <span class="mi">13</span>
<span class="n">job2</span> <span class="mi">23</span>
<span class="n">job2</span> <span class="mi">333</span>
<span class="n">job1</span> <span class="mi">34</span>
<span class="n">job1</span> <span class="mi">35</span>
<span class="n">job2</span>
<span class="n">job1</span> <span class="mi">45</span> <span class="mi">46</span>
<span class="n">job2</span> <span class="mi">56</span>
<span class="n">job1</span> <span class="mi">57</span>
<span class="n">job2</span>
<span class="n">job1</span> <span class="mi">67</span>
<span class="n">job2</span> <span class="mi">68</span> <span class="mi">78</span>
<span class="n">job1</span> <span class="mi">79</span>
<span class="n">job2</span>
<span class="n">job1</span> <span class="mi">89</span>
<span class="n">job2</span> <span class="mi">90</span> <span class="mi">100</span>
<span class="n">job2</span> <span class="mi">110</span>
</pre></div>
</div>
<p>是不是很乱？完全不是我们预想的那样。</p>
<p>解释下这是为什么？因为两个线程共用一个全局变量，又由于两线程是交替执行的，当<code class="docutils literal notranslate"><span class="pre">job1</span></code>
执行三次 <code class="docutils literal notranslate"><span class="pre">+1</span></code> 操作时，<code class="docutils literal notranslate"><span class="pre">job2</span></code>就不管三七二十一
给n做了<code class="docutils literal notranslate"><span class="pre">+10</span></code>操作。两个线程之间，执行完全没有规矩，没有约束。所以会看到输出当然也很乱。</p>
<p>加了锁后，这个问题也就解决，来看看</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">job1</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">n</span><span class="p">,</span> <span class="n">lock</span>
    <span class="c1"># 获取锁</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;job1&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">job2</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">n</span><span class="p">,</span> <span class="n">lock</span>
    <span class="c1"># 获取锁</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">10</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;job2&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># 生成锁对象</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">job1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">job2</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>由于<code class="docutils literal notranslate"><span class="pre">job1</span></code>的线程，率先拿到了锁，所以在for循环中，没有人有权限对n进行操作。当<code class="docutils literal notranslate"><span class="pre">job1</span></code>执行完毕释放锁后，<code class="docutils literal notranslate"><span class="pre">job2</span></code>这才拿到了锁，开始自己的for循环。</p>
<p>看看执行结果，真如我们预想的那样。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">job1</span> <span class="mi">1</span>
<span class="n">job1</span> <span class="mi">2</span>
<span class="n">job1</span> <span class="mi">3</span>
<span class="n">job1</span> <span class="mi">4</span>
<span class="n">job1</span> <span class="mi">5</span>
<span class="n">job1</span> <span class="mi">6</span>
<span class="n">job1</span> <span class="mi">7</span>
<span class="n">job1</span> <span class="mi">8</span>
<span class="n">job1</span> <span class="mi">9</span>
<span class="n">job1</span> <span class="mi">10</span>
<span class="n">job2</span> <span class="mi">20</span>
<span class="n">job2</span> <span class="mi">30</span>
<span class="n">job2</span> <span class="mi">40</span>
<span class="n">job2</span> <span class="mi">50</span>
<span class="n">job2</span> <span class="mi">60</span>
<span class="n">job2</span> <span class="mi">70</span>
<span class="n">job2</span> <span class="mi">80</span>
<span class="n">job2</span> <span class="mi">90</span>
<span class="n">job2</span> <span class="mi">100</span>
<span class="n">job2</span> <span class="mi">110</span>
</pre></div>
</div>
<p>这里，你应该也知道了，加锁是为了对锁内资源（变量）进行锁定，避免其他线程篡改已被锁定的资源，以达到我们预期的效果。</p>
<p>为了避免大家忘记释放锁，后面的例子，我将都使用with上下文管理器来加锁。大家注意一下。</p>
</div>
<div class="section" id="rlock">
<h4>4. 可重入锁（RLock）<a class="headerlink" href="#rlock" title="Permalink to this headline">¶</a></h4>
<p>有时候在同一个线程中，我们可能会多次请求同一资源，俗称锁嵌套。</p>
<p>如果还是按照常规的做法，会造成死锁的。比如，下面这段代码，你可以试着运行一下。会发现并没有输出结果。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">main</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>是因为第二次获取锁(通行证)时，发现锁(通行证)已经被同一线程的人拿走了，拿东西总有个先来后到，别人拿走了，你要想用，你就得干等着，直到有人归还锁（通行证），假如别人一直不归还，那程序就会在这里一直阻塞。</p>
<p>上面的代码中，使用了嵌套锁，在锁还没有释放的时候，又再一次请求锁，这就当然会造成死锁了。</p>
<p>那么如何解决这个问题呢？</p>
<p><code class="docutils literal notranslate"><span class="pre">threading</span></code>模块除了提供<code class="docutils literal notranslate"><span class="pre">Lock</span></code>锁之外，还提供了一种可重入锁<code class="docutils literal notranslate"><span class="pre">RLock</span></code>，专门来处理这个问题。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># 生成可重入锁对象</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">main</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>执行一下，发现已经有输出了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">7</span>
<span class="mi">8</span>
<span class="mi">9</span>
<span class="mi">10</span>
</pre></div>
</div>
<p>需要注意的是，可重入锁（RLock），只在同一线程里放松对锁(通行证)的获取，意思是，只要在同一线程里，程序就当你是同一个人，这个锁就可以复用，其他的话与<code class="docutils literal notranslate"><span class="pre">Lock</span></code>并无区别。</p>
</div>
<div class="section" id="id5">
<h4>5. 防止死锁的加锁机制<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>在编写多线程程序时，可能无意中就会写了一个死锁。可以说，死锁的形式有多种多样，但是本质都是相同的，都是对资源不合理竞争的结果。</p>
<p>以本人的经验总结，死锁通常以下几种 -
同一线程，嵌套获取同把互斥锁，造成死锁。 -
多个线程，不按顺序同时获取多个锁。造成死锁</p>
<p>对于第一种，上面已经说过了，使用可重入锁。</p>
<p>主要是第二种。可能你还没明白，是如何死锁的。</p>
<p>举个例子。</p>
<blockquote>
<div><p>线程1，嵌套获取A,B两个锁，线程2，嵌套获取B,A两个锁。
由于两个线程是交替执行的，是有机会遇到线程1获取到锁A，而未获取到锁B，在同一时刻，线程2获取到锁B，而未获取到锁A。由于锁B已经被线程2获取了，所以线程1就卡在了获取锁B处，由于是嵌套锁，线程1未获取并释放B，是不能释放锁A的，这是导致线程2也获取不到锁A，也卡住了。两个线程，各执一锁，各不让步。造成死锁。</p>
</div></blockquote>
<p>经过数学证明，只要两个（或多个）线程获取嵌套锁时，按照固定顺序就能保证程序不会进入死锁状态。</p>
<p>那么问题就转化成如何保证这些锁是按顺序的？</p>
<p>有两个办法 - 人工自觉，人工识别。 - 写一个辅助函数来对锁进行排序。</p>
<p>第一种，就不说了。</p>
<p>第二种，可以参考如下代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="c1"># Thread-local state to stored information on locks already acquired</span>
<span class="n">_local</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="o">*</span><span class="n">locks</span><span class="p">):</span>
    <span class="c1"># Sort locks by object identifier</span>
    <span class="n">locks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">locks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Make sure lock order of previously acquired locks is not violated</span>
    <span class="n">acquired</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_local</span><span class="p">,</span><span class="s1">&#39;acquired&#39;</span><span class="p">,[])</span>
    <span class="k">if</span> <span class="n">acquired</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="n">acquired</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">id</span><span class="p">(</span><span class="n">locks</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Lock Order Violation&#39;</span><span class="p">)</span>

    <span class="c1"># Acquire all of the locks</span>
    <span class="n">acquired</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locks</span><span class="p">)</span>
    <span class="n">_local</span><span class="o">.</span><span class="n">acquired</span> <span class="o">=</span> <span class="n">acquired</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="n">locks</span><span class="p">:</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Release locks in reverse order of acquisition</span>
        <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">locks</span><span class="p">):</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">acquired</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">locks</span><span class="p">):]</span>
</pre></div>
</div>
<p>如何使用呢？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="n">x_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="n">y_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">thread_1</span><span class="p">():</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">x_lock</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">y_lock</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread-1&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">thread_2</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">y_lock</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">x_lock</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread-2&#39;</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_1</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_2</span><span class="p">)</span>
<span class="n">t2</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>看到没有，表面上<code class="docutils literal notranslate"><span class="pre">thread_1</span></code>的先获取锁x，再获取锁<code class="docutils literal notranslate"><span class="pre">y</span></code>，而<code class="docutils literal notranslate"><span class="pre">thread_2</span></code>是先获取锁<code class="docutils literal notranslate"><span class="pre">y</span></code>，再获取<code class="docutils literal notranslate"><span class="pre">x</span></code>。
但是实际上，<code class="docutils literal notranslate"><span class="pre">acquire</span></code>函数，已经对<code class="docutils literal notranslate"><span class="pre">x</span></code>，<code class="docutils literal notranslate"><span class="pre">y</span></code>两个锁进行了排序。所以<code class="docutils literal notranslate"><span class="pre">thread_1</span></code>，<code class="docutils literal notranslate"><span class="pre">hread_2</span></code>都是以同一顺序来获取锁的，是不是造成死锁的。</p>
</div>
<div class="section" id="gil">
<h4>6. 饱受争议的GIL（全局锁）<a class="headerlink" href="#gil" title="Permalink to this headline">¶</a></h4>
<p>在第一节的时候，我就和大家介绍到，多线程和多进程是不一样的。</p>
<p>多进程是真正的并行，而多线程是伪并行，实际上他只是交替执行。</p>
<p>是什么导致多线程，只能交替执行呢？是一个叫<code class="docutils literal notranslate"><span class="pre">GIL</span></code>（<code class="docutils literal notranslate"><span class="pre">Global</span> <span class="pre">Interpreter</span> <span class="pre">Lock</span></code>，全局解释器锁）的东西。</p>
<p>什么是GIL呢？
&gt;任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>需要注意的是，GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。而Python解释器，并不是只有CPython，除它之外，还有<code class="docutils literal notranslate"><span class="pre">PyPy</span></code>，<code class="docutils literal notranslate"><span class="pre">Psyco</span></code>，<code class="docutils literal notranslate"><span class="pre">JPython</span></code>，<code class="docutils literal notranslate"><span class="pre">IronPython</span></code>等。</p>
<p>在绝大多数情况下，我们通常都认为 Python <code class="docutils literal notranslate"><span class="pre">==</span></code>
CPython，所以也就默许了Python具有GIL锁这个事。</p>
<p>都知道GIL影响性能，那么如何避免受到GIL的影响？ - 使用多进程代替多线程。
- 更换Python解释器，不使用CPython</p>
</div>
</div>
<span id="document-c10/c10_04"></span><div class="section" id="id1">
<h3>10.4 【并发编程】线程消息通信机制<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>前面我已经向大家介绍了，如何使用创建线程，启动线程。相信大家都会有这样一个想法，线程无非就是创建一下，然后再<code class="docutils literal notranslate"><span class="pre">start()</span></code>下，实在是太简单了。</p>
<p>可是要知道，在真实的项目中，实际场景可要我们举的例子要复杂的多得多，不同线程的执行可能是有顺序的，或者说他们的执行是有条件的，是要受控制的。如果仅仅依靠前面学的那点浅薄的知识，是远远不够的。</p>
<p>那今天，我们就来探讨一下如何控制线程的触发执行。</p>
<p>要实现对多个线程进行控制，其实本质上就是消息通信机制在起作用，利用这个机制发送指令，告诉线程，什么时候可以执行，什么时候不可以执行，执行什么内容。</p>
<p>经过我的总结，线程中通信方法大致有如下三种： - threading.Event -
threading.Condition - queue.Queue</p>
<p>接下来我们来一一探讨下。</p>
<hr class="docutils" />
<div class="section" id="event">
<h4>1. Event事件<a class="headerlink" href="#event" title="Permalink to this headline">¶</a></h4>
<p>Python提供了非常简单的通信机制
<code class="docutils literal notranslate"><span class="pre">Threading.Event</span></code>，通用的条件变量。多个线程可以<code class="docutils literal notranslate"><span class="pre">等待某个事件的发生</span></code>，在事件发生后，<code class="docutils literal notranslate"><span class="pre">所有的线程</span></code>都会被<code class="docutils literal notranslate"><span class="pre">激活</span></code>。</p>
<p>关于Event的使用也超级简单，就三个函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

<span class="c1"># 重置event，使得所有该event事件都处于待命状态</span>
<span class="n">event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="c1"># 等待接收event的指令，决定是否阻塞程序执行</span>
<span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="c1"># 发送event指令，使所有设置该event事件的线程执行</span>
<span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>
</div>
<p>举个例子来看下。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>


<span class="k">class</span> <span class="nc">MyThread</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread: {} start at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())))</span>
        <span class="c1"># 等待event.set()后，才能往下执行</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread: {} finish at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())))</span>


<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

<span class="c1"># 定义五个线程</span>
<span class="p">[</span><span class="n">threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MyThread</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">event</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>

<span class="c1"># 重置event，使得event.wait()起到阻塞作用</span>
<span class="n">event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="c1"># 启动所有线程</span>
<span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;等待5s...&#39;</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;唤醒所有线程...&#39;</span><span class="p">)</span>
<span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>
</div>
<p>执行一下，看看结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>Thread: 1 start at Sun May 13 20:38:08 2018
Thread: 2 start at Sun May 13 20:38:08 2018
Thread: 3 start at Sun May 13 20:38:08 2018
Thread: 4 start at Sun May 13 20:38:08 2018

等待5s...

唤醒所有线程...
Thread: 1 finish at Sun May 13 20:38:13 2018
Thread: 4 finish at Sun May 13 20:38:13 2018
Thread: 2 finish at Sun May 13 20:38:13 2018
Thread: 3 finish at Sun May 13 20:38:13 2018
</pre></div>
</div>
<p>可见在所有线程都启动（<code class="docutils literal notranslate"><span class="pre">start()</span></code>）后，并不会执行完，而是都在<code class="docutils literal notranslate"><span class="pre">self.event.wait()</span></code>止住了，需要我们通过<code class="docutils literal notranslate"><span class="pre">event.set()</span></code>来给所有线程发送执行指令才能往下执行。</p>
</div>
<div class="section" id="condition">
<h4>2. Condition<a class="headerlink" href="#condition" title="Permalink to this headline">¶</a></h4>
<p>Condition和Event 是类似的，并没有多大区别。</p>
<p>同样，Condition也只需要掌握几个函数即可。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cond</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>

<span class="c1"># 类似lock.acquire()</span>
<span class="n">cond</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

<span class="c1"># 类似lock.release()</span>
<span class="n">cond</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="c1"># 等待指定触发，同时会释放对锁的获取,直到被notify才重新占有琐。</span>
<span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="c1"># 发送指定，触发执行</span>
<span class="n">cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
</pre></div>
</div>
<p>举个网上一个比较趣的捉迷藏的例子来看看</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Hider</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Hider</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">#确保先运行Seeker中的方法</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: 我已经把眼睛蒙上了&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: 我找到你了哦 ~_~&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: 我赢了&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Seeker</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Seeker</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: 我已经藏好了，你快来找我吧&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: 被你找到了，哎~~~&#39;</span><span class="p">)</span>

<span class="n">cond</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>
<span class="n">seeker</span> <span class="o">=</span> <span class="n">Seeker</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s1">&#39;seeker&#39;</span><span class="p">)</span>
<span class="n">hider</span> <span class="o">=</span> <span class="n">Hider</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s1">&#39;hider&#39;</span><span class="p">)</span>
<span class="n">seeker</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">hider</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>通过cond来通信，阻塞自己，并使对方执行。从而，达到有顺序的执行。
看下结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>hider:   我已经把眼睛蒙上了
seeker:  我已经藏好了，你快来找我吧
hider:   我找到你了 ~_~
hider:   我赢了
seeker:  被你找到了，哎~~~
</pre></div>
</div>
</div>
<div class="section" id="queue">
<h4>3. Queue队列<a class="headerlink" href="#queue" title="Permalink to this headline">¶</a></h4>
<p>最后一个，队列，它是本节的重点，因为它是我们日常开发中最使用频率最高的。</p>
<p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 queue
库中的队列了。创建一个被多个线程共享的 Queue
对象，这些线程通过使用<code class="docutils literal notranslate"><span class="pre">put()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">get()</span></code>
操作来向队列中发送和获取元素。</p>
<p>同样，对于Queue，我们也只需要掌握几个函数即可。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="c1"># maxsize默认为0，不受限</span>
<span class="c1"># 一旦&gt;0，而消息数又达到限制，q.put()也将阻塞</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># 默认阻塞程序，等待队列消息，可设置超时时间</span>
<span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="c1"># 发送消息：默认会阻塞程序至队列中有空闲位置放入数据</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="c1"># 等待所有的消息都被消费完</span>
<span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>


<span class="c1"># 通知队列任务处理已经完成，当所有任务都处理完成时，join() 阻塞将会解除</span>
<span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>
</div>
<p>以下三个方法，知道就好，一般不需要使用</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 查询当前队列的消息个数</span>
<span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span>

<span class="c1"># 队列消息是否都被消费完，返回 True/False</span>
<span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>

<span class="c1"># 检测队列里消息是否已满</span>
<span class="n">q</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
</pre></div>
</div>
<p>函数会比之前的多一些，同时也从另一方面说明了其功能更加丰富。</p>
<p>我来举个老师点名的例子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf-8</span>
<span class="c1"># /usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Author: wangbm</span>
<span class="sd">Email: wongbingming@163.com</span>
<span class="sd">Wechat: mrbensonwon</span>
<span class="sd">Blog: python-online.cn</span>
<span class="sd">公众号：Python编程时光</span>


<span class="sd">date: 2020/9/20 下午7:30</span>
<span class="sd">desc:</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;wangbm&#39;</span>


<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{}：到！&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Teacher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">=</span><span class="n">queue</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">student_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">student_name</span> <span class="o">==</span> <span class="s2">&quot;exit&quot;</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;点名结束，开始上课..&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;老师：{}来了没？&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">student_name</span><span class="p">))</span>
            <span class="c1"># 发送消息，要点谁的名</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">student_name</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CallManager</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">students</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">student</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">students</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">student</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># 阻塞程序，时刻监听老师，接收消息</span>
            <span class="n">student_name</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">student_name</span> <span class="o">==</span> <span class="s2">&quot;exit&quot;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">student_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">students</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">students</span><span class="p">[</span><span class="n">student_name</span><span class="p">]</span><span class="o">.</span><span class="n">speak</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;老师，咱班，没有 {} 这个人&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">student_name</span><span class="p">))</span>

<span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="n">teacher</span> <span class="o">=</span> <span class="n">Teacher</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="n">queue</span><span class="p">)</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小明&quot;</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;小亮&quot;</span><span class="p">)</span>

<span class="n">cm</span> <span class="o">=</span> <span class="n">CallManager</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
<span class="n">cm</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">cm</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="n">cm</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;开始点名~&#39;</span><span class="p">)</span>
<span class="n">teacher</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">teacher</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;小亮&#39;</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">teacher</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;exit&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行结果如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>开始点名~
老师：小明来了没？
小明：到！
老师：小亮来了没？
小亮：到！
点名结束，开始上课..
</pre></div>
</div>
<p>其实 queue 还有一个很重要的方法，Queue.task_done()</p>
<p>如果不明白它的原理，我们在写程序，就很有可能卡死。</p>
<p>当我们使用 Queue.get()
从队列取出数据后，这个数据有没有被正常消费，是很重要的。</p>
<p>如果数据没有被正常消费，那么Queue会认为这个任务还在执行中，此时你使用
Queue.join() 会一直阻塞，即使此时你的队列里已经没有消息了。</p>
<p>那么如何解决这种一直阻塞的问题呢？</p>
<p>就是在我们正常消费完数据后，记得调用一下
Queue.task_done()，说明队列这个任务已经结束了。</p>
<p>当队列内部的任务计数器归于零时，调用 Queue.join() 就不会再阻塞了。</p>
<p>要理解这个过程，请参考 <a class="reference external" href="http://python.iswbm.com/en/latest/c02/c02_06.html">http://python.iswbm.com/en/latest/c02/c02_06.html</a>
里自定义线程池的的例子。</p>
</div>
<div class="section" id="id2">
<h4>4. 消息队列的先进先出<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>消息队列可不是只有<code class="docutils literal notranslate"><span class="pre">queue.Queue</span></code>这一个类，除它之外，还有<code class="docutils literal notranslate"><span class="pre">queue.LifoQueue</span></code>和<code class="docutils literal notranslate"><span class="pre">queue.PriorityQueue</span></code>这两个类。</p>
<p>从名字上，对于他们之间的区别，你大概也能猜到一二吧。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">queue.Queue</span></code>：先进先出队列 <code class="docutils literal notranslate"><span class="pre">queue.LifoQueue</span></code>：后进先出队列
<code class="docutils literal notranslate"><span class="pre">queue.PriorityQueue</span></code>：优先级队列</p>
</div></blockquote>
<p>先来看看，我们的老朋友，<code class="docutils literal notranslate"><span class="pre">queue.Queue</span></code>。
所谓的<code class="docutils literal notranslate"><span class="pre">先进先出</span></code>（FIFO，First in First
Out），就是先进入队列的消息，将优先被消费。
这和我们日常排队买菜是一样的，先排队的人肯定是先买到菜。</p>
<p>用代码来说明一下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">queue</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>看看输出，符合我们先进先出的预期。存入队列的顺序是<code class="docutils literal notranslate"><span class="pre">01234</span></code>，被消费的顺序也是<code class="docutils literal notranslate"><span class="pre">01234</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>再来看看<code class="docutils literal notranslate"><span class="pre">Queue.LifoQueue</span></code>，后进先出，就是后进入消息队列的，将优先被消费。</p>
<p>这和我们羽毛球筒是一样的，最后放进羽毛球筒的球，会被第一个取出使用。</p>
<p>用代码来看下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">queue</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">LifoQueue</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>来看看输出，符合我们后进后出的预期。存入队列的顺序是<code class="docutils literal notranslate"><span class="pre">01234</span></code>，被消费的顺序也是<code class="docutils literal notranslate"><span class="pre">43210</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>最后来看看<code class="docutils literal notranslate"><span class="pre">Queue.PriorityQueue</span></code>，优先级队列。
这和我们日常生活中的会员机制有些类似，办了金卡的人比银卡的服务优先，办了银卡的人比不办卡的人服务优先。</p>
<p>来用代码看一下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>

<span class="c1"># 重新定义一个类，继承自PriorityQueue</span>
<span class="k">class</span> <span class="nc">MyPriorityQueue</span><span class="p">(</span><span class="n">PriorityQueue</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">PriorityQueue</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="n">PriorityQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span>


<span class="n">queue</span> <span class="o">=</span> <span class="n">MyPriorityQueue</span><span class="p">()</span>
<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;item2&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;item5&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;item3&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;item4&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;item1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>来看看输出，符合我们的预期。我们存入入队列的顺序是<code class="docutils literal notranslate"><span class="pre">25341</span></code>，对应的优先级也是<code class="docutils literal notranslate"><span class="pre">25341</span></code>，可是被消费的顺序丝毫不受传入顺序的影响，而是根据指定的优先级来消费。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">item1</span>
<span class="n">item2</span>
<span class="n">item3</span>
<span class="n">item4</span>
<span class="n">item5</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>5. 总结一下<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>学习了以上三种通信方法，我们很容易就能发现<code class="docutils literal notranslate"><span class="pre">Event</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Condition</span></code>
是threading模块原生提供的模块，原理简单，功能单一，它能发送 <code class="docutils literal notranslate"><span class="pre">True</span></code> 和
<code class="docutils literal notranslate"><span class="pre">False</span></code> 的指令，所以只能适用于某些简单的场景中。</p>
<p>而<code class="docutils literal notranslate"><span class="pre">Queue</span></code>则是比较高级的模块，它可能发送任何类型的消息，包括字符串、字典等。其内部实现其实也引用了<code class="docutils literal notranslate"><span class="pre">Condition</span></code>模块（譬如<code class="docutils literal notranslate"><span class="pre">put</span></code>和<code class="docutils literal notranslate"><span class="pre">get</span></code>函数的阻塞），正是其对<code class="docutils literal notranslate"><span class="pre">Condition</span></code>进行了功能扩展，所以功能更加丰富，更能满足实际应用。</p>
</div>
</div>
<span id="document-c10/c10_05"></span><div class="section" id="id1">
<h3>10.5 【并发编程】线程中的信息隔离<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>上一篇我们说，线程与线程之间要通过消息通信来控制程序的执行。</p>
<p>讲完了消息通信，今天就来探讨下线程里的<code class="docutils literal notranslate"><span class="pre">信息隔离</span></code>是如何做到的。 ##
1. 初步认识信息隔离</p>
<p>什么是<code class="docutils literal notranslate"><span class="pre">信息隔离</span></code>？</p>
<p>比如说，咱有两个线程，线程A里的变量，和线程B里的变量值不能共享。这就是<code class="docutils literal notranslate"><span class="pre">信息隔离</span></code>。</p>
<p>你可能要说，那变量名取不一样不就好啦？</p>
<p>是的，如果所有的线程都不是由一个class实例化出来的同一个对象，确实是可以。这个问题我们暂且挂着，后面我再说明。</p>
<p>那么，如何实现<code class="docutils literal notranslate"><span class="pre">信息隔离</span></code>呢？</p>
<p>在Python中，其提供了<code class="docutils literal notranslate"><span class="pre">threading.local</span></code>这个类，可以很方便的控制变量的隔离，即使是同一个变量，在不同的线程中，其值也是不能共享的。</p>
<p>用代码来看下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">local</span><span class="p">,</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">currentThread</span>

<span class="c1"># 定义一个local实例</span>
<span class="n">local_data</span> <span class="o">=</span> <span class="n">local</span><span class="p">()</span>
<span class="c1"># 在主线中，存入name这个变量</span>
<span class="n">local_data</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;local_data&#39;</span>


<span class="k">class</span> <span class="nc">MyThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;赋值前-子线程：&quot;</span><span class="p">,</span> <span class="n">currentThread</span><span class="p">(),</span><span class="n">local_data</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="c1"># 在子线程中存入name这个变量</span>
        <span class="n">local_data</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;赋值后-子线程：&quot;</span><span class="p">,</span><span class="n">currentThread</span><span class="p">(),</span> <span class="n">local_data</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;开始前-主线程：&quot;</span><span class="p">,</span><span class="n">local_data</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">MyThread</span><span class="p">()</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">MyThread</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;结束后-主线程：&quot;</span><span class="p">,</span><span class="n">local_data</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
</pre></div>
</div>
<p>来看看输出结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>开始前-主线程： {&#39;name&#39;: &#39;local_data&#39;}

赋值前-子线程： &lt;MyThread(Thread-1, started 4832)&gt; {}
赋值后-子线程： &lt;MyThread(Thread-1, started 4832)&gt; {&#39;name&#39;: &#39;Thread-1&#39;}

赋值前-子线程： &lt;MyThread(Thread-2, started 5616)&gt; {}
赋值后-子线程： &lt;MyThread(Thread-2, started 5616)&gt; {&#39;name&#39;: &#39;Thread-2&#39;}

结束后-主线程： {&#39;name&#39;: &#39;local_data&#39;}
</pre></div>
</div>
<p>从输出来看，我们可以知道，<code class="docutils literal notranslate"><span class="pre">local</span></code>实际是一个<code class="docutils literal notranslate"><span class="pre">字典型</span></code>的对象，其内部可以以<code class="docutils literal notranslate"><span class="pre">key-value</span></code>的形式存入你要做信息隔离的变量。local实例可以是<code class="docutils literal notranslate"><span class="pre">全局唯一</span></code>的，只有一个。因为你在给local存入或访问变量时，它会根据当前的线程的不同从不同的<code class="docutils literal notranslate"><span class="pre">存储空间</span></code>存入或获取。</p>
<p>基于此，我们可以得出以下三点结论： &gt;1.
主线程中的变量，不会因为其是全局变量，而被子线程获取到； 2.
主线程也不能获取到子线程中的变量； 3.
子线程与子线程之间的变量也不能互相访问。</p>
<p>所以如果想在当前线程保存一个全局值，并且各自线程（包括主线程）互不干扰，使用local类吧。</p>
<div class="section" id="id2">
<h4>2. 信息隔离的意义何在<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>细心的你，一定已经发现了，上面那个例子，即使我们不用<code class="docutils literal notranslate"><span class="pre">threading.local</span></code>来做信息隔离，两个线程<code class="docutils literal notranslate"><span class="pre">self.getName()</span></code>本身就是隔离的，没有任何关系的。因为这两个线程是由一个class实例出的两个不同的实例对象。自然是可以不用做隔离，因为其本身就是隔离的。</p>
<p>但是，现实开发中。不可排除有多个线程，是由一个class实例出的同一个实例对象而实现的。</p>
<p>譬如，现在新手特别喜欢的爬虫项目。通常都是先给爬虫一个主页，然后获取主页下的所有链接，对这个链接再进行遍历，一直往下，直到把所有的链接都爬完，获取到我们所需的内容。</p>
<p>由于单线程的爬取效率实在是太低了，我们考虑使用多线程来工作。先使用<code class="docutils literal notranslate"><span class="pre">socket</span></code>和<code class="docutils literal notranslate"><span class="pre">www.sina.con.cn</span></code>建立一个TCP连接。然后在这个连接的基础上，对主页上的每个链接（我们这里只举<code class="docutils literal notranslate"><span class="pre">news.sina.com.cn</span></code>和<code class="docutils literal notranslate"><span class="pre">blog.sina.com.cn</span></code>这两个子链接做例子）创建一个线程，这样效率就高多了。
&gt;<strong>友情提醒</strong>：
&gt;以下代码，若要理解，可能需要你了解下socket的网络编程相关内容。我在前几天的文章中有发布一篇相关的文章，没有基础的同学可以先去看看那篇文章。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">class</span> <span class="nc">LazyConnection</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">AF_INET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">,</span> <span class="s1">&#39;sock&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already connected&#39;</span><span class="p">)</span>
        <span class="c1"># 把socket连接存入local中</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_ty</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span>

<span class="k">def</span> <span class="nf">spider</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">website</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">conn</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: {}</span><span class="se">\r\n</span><span class="s1">Connection: close</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">website</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got {} bytes&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resp</span><span class="p">)))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 建立一个TCP连接</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">LazyConnection</span><span class="p">((</span><span class="s1">&#39;www.sina.com.cn&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>

    <span class="c1"># 爬取两个页面</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">spider</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="s2">&quot;news.sina.com.cn&quot;</span><span class="p">))</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">spider</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="s2">&quot;blog.sina.com.cn&quot;</span><span class="p">))</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>输出结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Got</span> <span class="mi">765</span> <span class="nb">bytes</span>
<span class="n">Got</span> <span class="mi">513469</span> <span class="nb">bytes</span>
</pre></div>
</div>
<p>如果是在这种场景下，要做到线程之间的状态信息的隔离，就肯定要借助<code class="docutils literal notranslate"><span class="pre">threading.local</span></code>，所以<code class="docutils literal notranslate"><span class="pre">threading.local</span></code>的存在是有存在的意义的。其他还有很多场景是必须借助<code class="docutils literal notranslate"><span class="pre">threading.local</span></code>才能实现的，而这些就要靠你们在真正的业务开发中去发现咯。</p>
</div>
</div>
<span id="document-c10/c10_06"></span><div class="section" id="id1">
<h3>10.6 【并发编程】线程池创建的几种方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>1. 线程池的创建<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id3">
<h5>使用内置模块<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成cpu的大量开销。为解决这个问题，线程池的概念被提出来了。预先创建好一个合理数量的线程池，让过来的任务立刻能够使用，就形成了线程池。</p>
<p>在Python3中，创建线程池是通过<code class="docutils literal notranslate"><span class="pre">concurrent.futures</span></code>函数库中的<code class="docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code>类来实现的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="k">def</span> <span class="nf">target</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;running thread-{}:{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">get_ident</span><span class="p">(),</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 创建一个最大容纳数量为5的线程池</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># 往线程池上塞任务</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
<p>创建线程池还可以使用更优雅的方式，就是使用上下文管理器</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
<p>直接运行代码，从输出可以看出，前面我们设置线程池最大线程数，会保证“同时”仅有五个线程在工作。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145483767808</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145489022976</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145494278144</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145499533312</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145504788480</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145483767808</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145489022976</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145499533312</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145494278144</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145504788480</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145489022976</span><span class="p">:</span><span class="mi">2</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145499533312</span><span class="p">:</span><span class="mi">2</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145483767808</span><span class="p">:</span><span class="mi">2</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145504788480</span><span class="p">:</span><span class="mi">2</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145494278144</span><span class="p">:</span><span class="mi">2</span>
<span class="o">....</span>
</pre></div>
</div>
<p>示例完毕，来说明一下：</p>
<ol class="arabic simple">
<li><p>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入
max_workers 参数来设置线程池中最多能同时运行的线程数目。</p></li>
<li><p>使用 submit
函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意
submit() 不是阻塞的，而是立即返回。</p></li>
<li><p>通过使用 done()
方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1
和 task2 执行完毕，task3 仍在执行中。</p></li>
<li><p>使用 result() 方法可以获取任务的返回值。</p></li>
</ol>
</div>
<div class="section" id="id4">
<h5>自定义线程池<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>除了使用上述第三方模块的方法之外，我们还可以自己结合前面所学的消息队列来自定义线程池。</p>
<p>这里我们就使用queue来实现一个上面同样效果的例子，大家感受一下。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">task</span> <span class="o">==</span> <span class="s2">&quot;stop&quot;</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="k">break</span>

        <span class="n">task</span><span class="p">()</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">do_task</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;running thread-{}:{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">get_ident</span><span class="p">(),</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MyQueue</span><span class="p">(</span><span class="n">Queue</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">custome_pool</span><span class="p">(</span><span class="n">task_func</span><span class="p">,</span> <span class="n">max_workers</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">MyQueue</span><span class="p">(</span><span class="n">max_workers</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_workers</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">task_func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">queue</span>



<span class="n">pool</span> <span class="o">=</span> <span class="n">custome_pool</span><span class="p">(</span><span class="n">task_func</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">do_task</span><span class="p">)</span>

<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>输出是和上面是完全一样的效果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145469886464</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145475141632</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145485651968</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145490907136</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145480396800</span><span class="p">:</span><span class="mi">0</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145469886464</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145480396800</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145475141632</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145490907136</span><span class="p">:</span><span class="mi">1</span>
<span class="n">running</span> <span class="n">thread</span><span class="o">-</span><span class="mi">123145485651968</span><span class="p">:</span><span class="mi">1</span>
<span class="o">...</span>
</pre></div>
</div>
<p>构建线程池的方法，是可以很灵活的，大家有空可以自己多研究。但是建议只要掌握一种自己熟悉的，能快速上手的就好了。</p>
</div>
</div>
</div>
<span id="document-c10/c10_07"></span><div class="section" id="yield">
<h3>10.7 【并发编程】从 yield 开始入门协程<a class="headerlink" href="#yield" title="Permalink to this headline">¶</a></h3>
<p>通过上面的介绍，我们知道生成器为我们引入了暂停函数执行（<code class="docutils literal notranslate"><span class="pre">yield</span></code>）的功能。当有了暂停的功能之后，人们就想能不能在生成器暂停的时候向其发送一点东西（其实上面也有提及：<code class="docutils literal notranslate"><span class="pre">send(None)</span></code>）。这种向暂停的生成器发送信息的功能通过
<code class="docutils literal notranslate"><span class="pre">PEP</span> <span class="pre">342</span></code> 进入 <code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">2.5</span></code> 中，并催生了 <code class="docutils literal notranslate"><span class="pre">Python</span></code>
中<code class="docutils literal notranslate"><span class="pre">协程</span></code>的诞生。根据 <code class="docutils literal notranslate"><span class="pre">wikipedia</span></code> 中的定义
&gt;协程是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序。</p>
<p>注意从本质上而言，协程并不属于语言中的概念，而是编程模型上的概念。</p>
<p>协程和线程，有<code class="docutils literal notranslate"><span class="pre">相似点</span></code>，多个协程之间和线程一样，只会交叉串行执行；也有<code class="docutils literal notranslate"><span class="pre">不同点</span></code>，线程之间要频繁进行切换，加锁，解锁，从复杂度和效率来看，和协程相比，这确是一个痛点。协程通过使用
<code class="docutils literal notranslate"><span class="pre">yield</span></code>
暂停生成器，可以将程序的执行流程交给其他的子程序，从而实现不同子程序的之间的交替执行。</p>
<p>下面通过一个简明的演示来看看，如何向生成器中发送消息。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jumping_range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="c1"># 通过send()发送的信息将赋值给jump</span>
        <span class="n">jump</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">index</span>
        <span class="k">if</span> <span class="n">jump</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">jump</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">itr</span> <span class="o">=</span> <span class="n">jumping_range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">itr</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">itr</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>输出。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>这里解释下为什么这么输出。 重点是<code class="docutils literal notranslate"><span class="pre">jump</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">index</span></code>这个语句。</p>
<p>分成两部分： - <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">index</span></code> 是将index <code class="docutils literal notranslate"><span class="pre">return</span></code>给外部调用程序。 -
<code class="docutils literal notranslate"><span class="pre">jump</span> <span class="pre">=</span> <span class="pre">yield</span></code>
可以接收外部程序通过send()发送的信息，并赋值给<code class="docutils literal notranslate"><span class="pre">jump</span></code></p>
<p>以上这些，都是讲协程并发的<strong>基础必备知识</strong>，<strong>请一定要亲自去实践并理解它</strong>，不然后面的内容，将会变得枯燥无味，晦涩难懂。</p>
<p>下一章，我将讲一个Python3.5新引入的语法：<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>。篇幅也比较多，所以就单独拿出来讲。</p>
</div>
<span id="document-c10/c10_08"></span><div class="section" id="yield-from">
<h3>10.8 【并发编程】深入理解yield from语法<a class="headerlink" href="#yield-from" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 为什么要使用协程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>在上一篇中，我们从生成器的基本认识与使用，成功过渡到了协程。</p>
<p>但一定有许多人，只知道协程是个什么东西，但并不知道为什么要用协程？换句话来说，并不知道在什么情况下用协程？
它相比多线程来说，有哪些过人之处呢？</p>
<p>在开始讲<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>
之前，我想先解决一下这个给很多人带来困惑的问题。</p>
<p>举个例子。
假如我们做一个爬虫。我们要爬取多个网页，这里简单举例两个网页(两个spider函数)，获取HTML（耗IO耗时），然后再对HTML对行解析取得我们感兴趣的数据。</p>
<p>我们的代码结构精简如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">spider_01</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">parse_html</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">spider_02</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">parse_html</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
</pre></div>
</div>
<p>我们都知道，<code class="docutils literal notranslate"><span class="pre">get_html()</span></code>等待返回网页是非常耗IO的，一个网页还好，如果我们爬取的网页数据极其庞大，这个等待时间就非常惊人，是极大的浪费。</p>
<p>聪明的程序员，当然会想如果能在<code class="docutils literal notranslate"><span class="pre">get_html()</span></code>这里暂停一下，不用傻乎乎地去等待网页返回，而是去做别的事。等过段时间再回过头来到刚刚暂停的地方，接收返回的html内容，然后还可以接下去解析<code class="docutils literal notranslate"><span class="pre">parse_html(html)</span></code>。</p>
<p>利用常规的方法，几乎是没办法实现如上我们想要的效果的。所以Python想得很周到，从语言本身给我们实现了这样的功能，这就是<code class="docutils literal notranslate"><span class="pre">yield</span></code>语法。可以实现在某一函数中暂停的效果。</p>
<p>试着思考一下，假如没有协程，我们要写一个并发程序。可能有以下问题 1.
使用最常规的同步编程要实现异步并发效果并不理想，或者难度极高。 2.
由于GIL锁的存在，多线程的运行需要频繁的加锁解锁，切换线程，这极大地降低了并发性能；</p>
<p>而协程的出现，刚好可以解决以上的问题。它的特点有 1.
协程是在单线程里实现任务的切换的 2. 利用同步的方式去实现异步 3.
不再需要锁，提高了并发性能</p>
</div>
<div class="section" id="id2">
<h4>2. yield from的用法详解<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>
是在Python3.3才出现的语法。所以这个特性在Python2中是没有的。</p>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>
后面需要加的是可迭代对象，它可以是普通的可迭代对象，也可以是迭代器，甚至是生成器。</p>
<div class="section" id="id3">
<h5>2.1 简单应用：拼接可迭代对象<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>我们可以用一个使用<code class="docutils literal notranslate"><span class="pre">yield</span></code>和一个使用<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>的例子来对比看下。</p>
<p>使用<code class="docutils literal notranslate"><span class="pre">yield</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 字符串</span>
<span class="n">astr</span><span class="o">=</span><span class="s1">&#39;ABC&#39;</span>
<span class="c1"># 列表</span>
<span class="n">alist</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># 字典</span>
<span class="n">adict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;wangbm&quot;</span><span class="p">,</span><span class="s2">&quot;age&quot;</span><span class="p">:</span><span class="mi">18</span><span class="p">}</span>
<span class="c1"># 生成器</span>
<span class="n">agen</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>

<span class="n">new_list</span><span class="o">=</span><span class="n">gen</span><span class="p">(</span><span class="n">astr</span><span class="p">,</span> <span class="n">alist</span><span class="p">,</span> <span class="n">adict</span><span class="p">,</span> <span class="n">agen</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_list</span><span class="p">))</span>
<span class="c1"># [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;name&#39;, &#39;age&#39;, 4, 5, 6, 7]</span>
</pre></div>
</div>
<p>使用<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 字符串</span>
<span class="n">astr</span><span class="o">=</span><span class="s1">&#39;ABC&#39;</span>
<span class="c1"># 列表</span>
<span class="n">alist</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># 字典</span>
<span class="n">adict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;wangbm&quot;</span><span class="p">,</span><span class="s2">&quot;age&quot;</span><span class="p">:</span><span class="mi">18</span><span class="p">}</span>
<span class="c1"># 生成器</span>
<span class="n">agen</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">item</span>

<span class="n">new_list</span><span class="o">=</span><span class="n">gen</span><span class="p">(</span><span class="n">astr</span><span class="p">,</span> <span class="n">alist</span><span class="p">,</span> <span class="n">adict</span><span class="p">,</span> <span class="n">agen</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_list</span><span class="p">))</span>
<span class="c1"># [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;name&#39;, &#39;age&#39;, 4, 5, 6, 7]</span>
</pre></div>
</div>
<p>由上面两种方式对比，可以看出，yield
from后面加上可迭代对象，他可以把可迭代对象里的每个元素一个一个的yield出来，对比yield来说代码更加简洁，结构更加清晰。</p>
</div>
<div class="section" id="id4">
<h5>2.2 复杂应用：生成器的嵌套<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>如果你认为只是 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>
仅仅只有上述的功能的话，那你就太小瞧了它，它的更强大的功能还在后面。</p>
<p>当 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 后面加上一个生成器后，就实现了生成的嵌套。</p>
<p>当然实现生成器的嵌套，并不是一定必须要使用<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>，而是使用<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>可以让我们避免让我们自己处理各种料想不到的异常，而让我们专注于业务代码的实现。</p>
<p>如果自己用<code class="docutils literal notranslate"><span class="pre">yield</span></code>去实现，那只会加大代码的编写难度，降低开发效率，降低代码的可读性。既然Python已经想得这么周到，我们当然要好好利用起来。</p>
<p>讲解它之前，首先要知道这个几个概念
&gt;1、<code class="docutils literal notranslate"><span class="pre">调用方</span></code>：调用委派生成器的客户端（调用方）代码
&gt;2、<code class="docutils literal notranslate"><span class="pre">委托生成器</span></code>：包含yield from表达式的生成器函数
&gt;3、<code class="docutils literal notranslate"><span class="pre">子生成器</span></code>：yield from后面加的生成器函数</p>
<p>你可能不知道他们都是什么意思，没关系，来看下这个例子。</p>
<p>这个例子，是实现实时计算平均值的。
比如，第一次传入10，那返回平均数自然是10.
第二次传入20，那返回平均数是(10+20)/2=15
第三次传入30，那返回平均数(10+20+30)/3=20</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 子生成器</span>
<span class="k">def</span> <span class="nf">average_gen</span><span class="p">():</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">average</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">new_num</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">average</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">new_num</span>
        <span class="n">average</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="n">count</span>

<span class="c1"># 委托生成器</span>
<span class="k">def</span> <span class="nf">proxy_gen</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">average_gen</span><span class="p">()</span>

<span class="c1"># 调用方</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">calc_average</span> <span class="o">=</span> <span class="n">proxy_gen</span><span class="p">()</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">calc_average</span><span class="p">)</span>            <span class="c1"># 预激下生成器</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># 打印：10.0</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>  <span class="c1"># 打印：15.0</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>  <span class="c1"># 打印：20.0</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>认真阅读以上代码，你应该很容易能理解，调用方、委托生成器、子生成器之间的关系。我就不多说了</p>
<p><strong>委托生成器的作用是</strong>：在调用方与子生成器之间建立一个<code class="docutils literal notranslate"><span class="pre">双向通道</span></code>。</p>
<p>所谓的双向通道是什么意思呢？
调用方可以通过<code class="docutils literal notranslate"><span class="pre">send()</span></code>直接发送消息给子生成器，而子生成器yield的值，也是直接返回给调用方。</p>
<p>你可能会经常看到有些代码，还可以在<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>前面看到可以赋值。这是什么用法？</p>
<p>你可能会以为，子生成器yield回来的值，被委托生成器给拦截了。你可以亲自写个demo运行试验一下，并不是你想的那样。
因为我们之前说了，委托生成器，只起一个桥梁作用，它建立的是一个<code class="docutils literal notranslate"><span class="pre">双向通道</span></code>，它并没有权利也没有办法，对子生成器yield回来的内容做拦截。</p>
<p>为了解释这个用法，我还是用上述的例子，并对其进行了一些改造。添加了一些注释，希望你能看得明白。</p>
<p>按照惯例，我们还是举个例子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 子生成器</span>
<span class="k">def</span> <span class="nf">average_gen</span><span class="p">():</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">average</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">new_num</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">average</span>
        <span class="k">if</span> <span class="n">new_num</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">new_num</span>
        <span class="n">average</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="n">count</span>

    <span class="c1"># 每一次return，都意味着当前协程结束。</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="n">average</span>

<span class="c1"># 委托生成器</span>
<span class="k">def</span> <span class="nf">proxy_gen</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># 只有子生成器要结束（return）了，yield from左边的变量才会被赋值，后面的代码才会执行。</span>
        <span class="n">total</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">average</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">average_gen</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;计算完毕！！</span><span class="se">\n</span><span class="s2">总共传入 {} 个数值， 总和：{}，平均数：{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">average</span><span class="p">))</span>

<span class="c1"># 调用方</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">calc_average</span> <span class="o">=</span> <span class="n">proxy_gen</span><span class="p">()</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">calc_average</span><span class="p">)</span>            <span class="c1"># 预激协程</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># 打印：10.0</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>  <span class="c1"># 打印：15.0</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>  <span class="c1"># 打印：20.0</span>
    <span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>      <span class="c1"># 结束协程</span>
    <span class="c1"># 如果此处再调用calc_average.send(10)，由于上一协程已经结束，将重开一协程</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>运行后，输出</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>10.0
15.0
20.0
计算完毕！！
总共传入 3 个数值， 总和：60，平均数：20.0
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h4>3. 为什么要使用yield from<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>学到这里，我相信你肯定要问，既然委托生成器，起到的只是一个双向通道的作用，我还需要委托生成器做什么？我调用方直接调用子生成器不就好啦？</p>
<p>高能预警~~~</p>
<p>下面我们来一起探讨一下，到底yield from
有什么过人之处，让我们非要用它不可。</p>
<div class="section" id="id6">
<h5>3.1 因为它可以帮我们处理异常<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>如果我们去掉委托生成器，而直接调用子生成器。那我们就需要把代码改成像下面这样，我们需要自己捕获异常并处理。而不像使<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>那样省心。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 子生成器</span>
<span class="c1"># 子生成器</span>
<span class="k">def</span> <span class="nf">average_gen</span><span class="p">():</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">average</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">new_num</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">average</span>
        <span class="k">if</span> <span class="n">new_num</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">new_num</span>
        <span class="n">average</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="n">count</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="n">average</span>

<span class="c1"># 调用方</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">calc_average</span> <span class="o">=</span> <span class="n">average_gen</span><span class="p">()</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">calc_average</span><span class="p">)</span>            <span class="c1"># 预激协程</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># 打印：10.0</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>  <span class="c1"># 打印：15.0</span>
    <span class="k">print</span><span class="p">(</span><span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>  <span class="c1"># 打印：20.0</span>

    <span class="c1"># ----------------注意-----------------</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">calc_average</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">total</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">average</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;计算完毕！！</span><span class="se">\n</span><span class="s2">总共传入 {} 个数值， 总和：{}，平均数：{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">average</span><span class="p">))</span>
    <span class="c1"># ----------------注意-----------------</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>此时的你，可能会说，不就一个<code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>的异常吗？自己捕获也没什么大不了的。</p>
<p>你要是知道<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>在背后为我们默默无闻地做了哪些事，你就不会这样说了。</p>
<p>具体<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>为我们做了哪些事，可以参考如下这段代码。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#一些说明</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">_i：子生成器，同时也是一个迭代器</span>
<span class="sd">_y：子生成器生产的值</span>
<span class="sd">_r：yield from 表达式最终的值</span>
<span class="sd">_s：调用方通过send()发送的值</span>
<span class="sd">_e：异常对象</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">EXPR</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">_y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
    <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span>

<span class="k">else</span><span class="p">:</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_s</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">_y</span>
        <span class="k">except</span> <span class="ne">GeneratorExit</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">close</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_m</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">_e</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">throw</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">_e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_y</span> <span class="o">=</span> <span class="n">_m</span><span class="p">(</span><span class="o">*</span><span class="n">_x</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
                    <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_s</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">_y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_y</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
                <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span>
                <span class="k">break</span>
<span class="n">RESULT</span> <span class="o">=</span> <span class="n">_r</span>
</pre></div>
</div>
<p>以上的代码，稍微有点复杂，有兴趣的同学可以结合以下说明去研究看看。</p>
<ol class="arabic simple">
<li><p>迭代器（即可指子生成器）产生的值直接返还给调用者</p></li>
<li><p>任何使用send()方法发给委派生产器（即外部生产器）的值被直接传递给迭代器。如果send值是None，则调用迭代器next()方法；如果不为None，则调用迭代器的send()方法。如果对迭代器的调用产生StopIteration异常，委派生产器恢复继续执行yield
from后面的语句；若迭代器产生其他任何异常，则都传递给委派生产器。</p></li>
<li><p>子生成器可能只是一个迭代器，并不是一个作为协程的生成器，所以它不支持.throw()和.close()方法,即可能会产生AttributeError
异常。</p></li>
<li><p>除了GeneratorExit
异常外的其他抛给委派生产器的异常，将会被传递到迭代器的throw()方法。如果迭代器throw()调用产生了StopIteration异常，委派生产器恢复并继续执行，其他异常则传递给委派生产器。</p></li>
<li><p>如果GeneratorExit异常被抛给委派生产器，或者委派生产器的close()方法被调用，如果迭代器有close()的话也将被调用。如果close()调用产生异常，异常将传递给委派生产器。否则，委派生产器将抛出GeneratorExit
异常。</p></li>
<li><p>当迭代器结束并抛出异常时，yield from表达式的值是其StopIteration
异常中的第一个参数。</p></li>
<li><p>一个生成器中的return expr语句将会从生成器退出并抛出
StopIteration(expr)异常。</p></li>
</ol>
<p>没兴趣看的同学，只要知道，<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>帮我们做了很多的异常处理，而且全面，而这些如果我们要自己去实现的话，一个是编写代码难度增加，写出来的代码可读性极差，这些我们就不说了，最主要的是很可能有遗漏，只要哪个异常没考虑到，都有可能导致程序崩溃什么的</p>
</div>
</div>
</div>
<span id="document-c10/c10_09"></span><div class="section" id="io-asyncio">
<h3>10.9 【并发编程】初识异步IO框架：asyncio 上篇<a class="headerlink" href="#io-asyncio" title="Permalink to this headline">¶</a></h3>
<p>通过前两节的铺垫（关于协程的使用），今天我们终于可以来介绍我们整个系列的重点
– <code class="docutils literal notranslate"><span class="pre">asyncio</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">asyncio</span></code>是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p>
<p>有些同学，可能很疑惑，既然有了以生成器为基础的协程，我们直接使用<code class="docutils literal notranslate"><span class="pre">yield</span></code>
和 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 不就可以手动实现对IO的调度了吗？
为何Python吃饱了没事干，老重复造轮子。</p>
<p>这个问题很好回答，就跟为什么会有<code class="docutils literal notranslate"><span class="pre">Django</span></code>，为什么会有<code class="docutils literal notranslate"><span class="pre">Scrapy</span></code>，是一个道理。</p>
<p>他们都是框架，将很多很重复性高，复杂度高的工作，提前给你做好，这样你就可以专注于业务代码的研发。</p>
<p>跟着小明学完了协程的那些个难点，你是不是也发现了，协程的知识点我已经掌握了，但是我还是不知道怎么用，如何使用，都说它可以实现并发，但是我还是不知道如何入手？</p>
<p>那是因为，我们现在还缺少一个成熟的框架，帮助你完成那些复杂的动作。这个时候，<code class="docutils literal notranslate"><span class="pre">ayncio</span></code>就这么应运而生了。</p>
<div class="section" id="id1">
<h4>1. 如何定义/创建协程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>还记得在前两章节的时候，我们创建了生成器，是如何去检验我们创建的是不是生成器对象吗？</p>
<p>我们是借助了<code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>函数，来判断是否是<code class="docutils literal notranslate"><span class="pre">collections.abc</span></code>
里的<code class="docutils literal notranslate"><span class="pre">Generator</span></code>类的子类实现的。</p>
<p>同样的方法，我们也可以用在这里。</p>
<p>只要在一个函数前面加上 <code class="docutils literal notranslate"><span class="pre">async</span></code>
关键字，这个函数对象是一个协程，通过<code class="docutils literal notranslate"><span class="pre">isinstance</span></code>函数，它确实是<code class="docutils literal notranslate"><span class="pre">Coroutine</span></code>类型。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Coroutine</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello,&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 生成协程对象，并不会运行函数内的代码</span>
    <span class="n">coroutine</span> <span class="o">=</span> <span class="n">hello</span><span class="p">(</span><span class="s2">&quot;World&quot;</span><span class="p">)</span>

    <span class="c1"># 检查是否是协程 Coroutine 类型</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">Coroutine</span><span class="p">))</span>  <span class="c1"># True</span>
</pre></div>
</div>
<p>前两节，我们说，生成器是协程的基础，那我们是不是有办法，将一个生成器，直接变成协程使用呢。答案是有的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Coroutine</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">只要在一个生成器函数头部用上 @asyncio.coroutine 装饰器</span>
<span class="sd">就能将这个函数对象，【标记】为协程对象。注意这里是【标记】，划重点。</span>
<span class="sd">实际上，它的本质还是一个生成器。</span>
<span class="sd">标记后，它实际上已经可以当成协程使用。后面会介绍。</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="nd">@asyncio.coroutine</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="c1"># 异步调用asyncio.sleep(1):</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">coroutine</span> <span class="o">=</span> <span class="n">hello</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">Generator</span><span class="p">))</span>  <span class="c1"># True</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">Coroutine</span><span class="p">))</span>  <span class="c1"># False</span>
</pre></div>
</div>
</div>
<div class="section" id="asyncio">
<h4>2. asyncio的几个概念<a class="headerlink" href="#asyncio" title="Permalink to this headline">¶</a></h4>
<p>在了解<code class="docutils literal notranslate"><span class="pre">asyncio</span></code>的使用方法前，首先有必要先介绍一下，这几个贯穿始终的概念。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">event_loop</span> <span class="pre">事件循环</span></code>：程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coroutine</span> <span class="pre">协程</span></code>：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">future</span> <span class="pre">对象</span></code>：
代表将来执行或没有执行的任务的结果。它和task上没有本质的区别</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">task</span> <span class="pre">任务</span></code>：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。Task
对象是 Future 的子类，它将 coroutine 和 Future 联系在一起，将
coroutine 封装成一个 Future 对象。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">async/await</span> <span class="pre">关键字</span></code>：python3.5
用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。其作用在一定程度上类似于yield。</p></li>
</ul>
<p>这几个概念，干看可能很难以理解，没事，往下看实例，然后再回来，我相信你一定能够理解。</p>
</div>
<div class="section" id="id2">
<h4>3. 学习协程是如何工作的<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>协程完整的工作流程是这样的 - 定义/创建协程对象 - 将协程转为task任务 -
定义事件循环对象容器 - 将task任务扔进事件循环对象中触发</p>
<p>光说不练假把戏，一起来看下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello,&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="c1"># 定义协程对象</span>
<span class="n">coroutine</span> <span class="o">=</span> <span class="n">hello</span><span class="p">(</span><span class="s2">&quot;World&quot;</span><span class="p">)</span>

<span class="c1"># 定义事件循环对象容器</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="c1"># task = asyncio.ensure_future(coroutine)</span>

<span class="c1"># 将协程转为task任务</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>

<span class="c1"># 将task任务扔进事件循环对象中并触发</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>输出结果，当然显而易见</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hello</span><span class="p">,</span> <span class="n">World</span>
</pre></div>
</div>
</div>
<div class="section" id="awaityield">
<h4>4. await与yield对比<a class="headerlink" href="#awaityield" title="Permalink to this headline">¶</a></h4>
<p>前面我们说，<code class="docutils literal notranslate"><span class="pre">await</span></code>用于挂起阻塞的异步调用接口。其作用在<code class="docutils literal notranslate"><span class="pre">一定程度上</span></code>类似于yield。</p>
<p>注意这里是，一定程度上，意思是效果上一样（都能实现暂停的效果），但是功能上却不兼容。就是你不能在生成器中使用<code class="docutils literal notranslate"><span class="pre">await</span></code>，也不能在async
定义的协程中使用<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>。</p>
<p>小明不是胡说八道的。有实锤。 <img alt="普通函数中 不能使用 await" src="https://i.loli.net/2018/05/26/5b09794f45340.png" /> 再来一锤。
<img alt="async 中 不能使用yield" src="https://i.loli.net/2018/05/26/5b0978b646230.png" /></p>
<p>除此之外呢，还有一点很重要的。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 后面可接
<code class="docutils literal notranslate"><span class="pre">可迭代对象</span></code>，也可接<code class="docutils literal notranslate"><span class="pre">future对象</span></code>/协程对象；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">await</span></code> 后面必须要接 <code class="docutils literal notranslate"><span class="pre">future对象</span></code>/<code class="docutils literal notranslate"><span class="pre">协程对象</span></code></p></li>
</ul>
<p>如何验证呢？</p>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 后面可接
<code class="docutils literal notranslate"><span class="pre">可迭代对象</span></code>，这个前两章已经说过了，这里不再赘述。
接下来，就只要验证，<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>和<code class="docutils literal notranslate"><span class="pre">await</span></code>都可以接<code class="docutils literal notranslate"><span class="pre">future对象</span></code>/<code class="docutils literal notranslate"><span class="pre">协程对象</span></code>就可以了。</p>
<p>验证之前呢，要先介绍一下这个函数：
<code class="docutils literal notranslate"><span class="pre">asyncio.sleep(n)</span></code>，这货是asyncio自带的工具函数，他可以模拟IO阻塞，他返回的是一个协程对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Future</span><span class="p">))</span>      <span class="c1"># False</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Coroutine</span><span class="p">))</span>   <span class="c1"># True</span>
</pre></div>
</div>
<p>还有，要学习如何创建<code class="docutils literal notranslate"><span class="pre">Future对象</span></code>，不然怎么验证。
前面概念里说过，Task是Future的子类，这么说，我们只要创建一个task对象即可。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">asyncio.futures</span> <span class="kn">import</span> <span class="n">Future</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello, &#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="n">coroutine</span> <span class="o">=</span> <span class="n">hello</span><span class="p">(</span><span class="s2">&quot;World&quot;</span><span class="p">)</span>

<span class="c1"># 将协程转为task对象</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">Future</span><span class="p">))</span>   <span class="c1"># True</span>
</pre></div>
</div>
<p>好了，接下来，开始验证。 <img alt="验证通过" src="https://i.loli.net/2018/05/26/5b09814dc4714.png" /></p>
</div>
<div class="section" id="id3">
<h4>5. 绑定回调函数<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>异步IO的实现原理，就是在IO高的地方挂起，等IO结束后，再继续执行。在绝大部分时候，我们后续的代码的执行是需要依赖IO的返回值的，这就要用到回调了。</p>
<p>回调的实现，有两种，一种是绝大部分程序员喜欢的，利用的同步编程实现的回调。
这就要求我们要能够有办法取得协程的await的返回值。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;暂停了{}秒！&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="n">coroutine</span> <span class="o">=</span> <span class="n">_sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

<span class="c1"># task.result() 可以取得返回结果</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;返回结果：{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()))</span>
</pre></div>
</div>
<p>输出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>返回结果：暂停了2秒！
</pre></div>
</div>
<p>还有一种是通过asyncio自带的添加回调函数功能来实现。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">asyncio</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;暂停了{}秒！&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;这里是回调函数，获取返回结果是：&#39;</span><span class="p">,</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>

<span class="n">coroutine</span> <span class="o">=</span> <span class="n">_sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>

<span class="c1"># 添加回调函数</span>
<span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>输出</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>这里是回调函数，获取返回结果是： 暂停了2秒！
</pre></div>
</div>
<p>和上面的结果是一样的。非常好。</p>
<hr class="docutils" />
</div>
</div>
<span id="document-c10/c10_10"></span><div class="section" id="io-asyncio">
<h3>10.10 【并发编程】深入异步IO框架：asyncio 中篇<a class="headerlink" href="#io-asyncio" title="Permalink to this headline">¶</a></h3>
<p>今天的内容其实还挺多的，我准备了三天，到今天才整理完毕。希望大家看完，有所收获的，能给小明一个赞。这就是对小明最大的鼓励了。
为了更好地衔接这一节，我们先来回顾一下上一节的内容。</p>
<p>上一节，我们首先介绍了，如何创建一个协程对象. 主要有两种方法</p>
<ul class="simple">
<li><p>通过<code class="docutils literal notranslate"><span class="pre">async</span></code>关键字，</p></li>
<li><p>通过<code class="docutils literal notranslate"><span class="pre">&#64;asyncio.coroutine</span></code> 装饰函数。</p></li>
</ul>
<p>然后有了协程对象，就需要一个事件循环容器来运行我们的协程。其主要的步骤有如下几点：
- 将协程对象转为task任务对象 - 定义一个事件循环对象容器用来存放task -
将task任务扔进事件循环对象中并触发</p>
<p>为了让大家，对生成器和协程有一个更加清晰的认识，我还介绍了<code class="docutils literal notranslate"><span class="pre">yield</span></code>和<code class="docutils literal notranslate"><span class="pre">async/await</span></code>的区别。</p>
<p>最后，我们还讲了，如何给一个协程添加回调函数。</p>
<p>好了，用个形象的比喻，上一节，其实就只是讲了协程中的<code class="docutils literal notranslate"><span class="pre">单任务</span></code>。哈哈，是不是还挺难的？希望大家一定要多看几遍，多敲代码，不要光看。</p>
<p>那么这一节，我们就来看下，协程中的<code class="docutils literal notranslate"><span class="pre">多任务</span></code>。</p>
<div class="section" id="id1">
<h4>1. 协程中的并发<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>协程的并发，和线程一样。举个例子来说，就好像
一个人同时吃三个馒头，咬了第一个馒头一口，就得等这口咽下去，才能去啃第其他两个馒头。就这样交替换着吃。</p>
<p><code class="docutils literal notranslate"><span class="pre">asyncio</span></code>实现并发，就需要多个协程来完成任务，每当有任务阻塞的时候就await，然后其他协程继续工作。</p>
<p>第一步，当然是创建多个协程的列表。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 协程函数</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">do_some_work</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Waiting: &#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done after {}s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 协程对象</span>
<span class="n">coroutine1</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">coroutine2</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">coroutine3</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># 将协程转成task，并组成list</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine1</span><span class="p">),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine2</span><span class="p">),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine3</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p>第二步，如何将这些协程注册到事件循环中呢。</p>
<p>有两种方法，至于这两种方法什么区别，稍后会介绍。 -
使用<code class="docutils literal notranslate"><span class="pre">asyncio.wait()</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>使用<code class="docutils literal notranslate"><span class="pre">asyncio.gather()</span></code></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 千万注意，这里的 「*」 不能省略</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<p>最后，return的结果，可以用<code class="docutils literal notranslate"><span class="pre">task.result()</span></code>查看。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Task ret: &#39;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
</pre></div>
</div>
<p>完整代码如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 协程函数</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">do_some_work</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Waiting: &#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done after {}s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 协程对象</span>
<span class="n">coroutine1</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">coroutine2</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">coroutine3</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># 将协程转成task，并组成list</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine1</span><span class="p">),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine2</span><span class="p">),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine3</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>

<span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Task ret: &#39;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
</pre></div>
</div>
<p>输出结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Waiting</span><span class="p">:</span>  <span class="mi">1</span>
<span class="n">Waiting</span><span class="p">:</span>  <span class="mi">2</span>
<span class="n">Waiting</span><span class="p">:</span>  <span class="mi">4</span>
<span class="n">Task</span> <span class="n">ret</span><span class="p">:</span>  <span class="n">Done</span> <span class="n">after</span> <span class="mi">1</span><span class="n">s</span>
<span class="n">Task</span> <span class="n">ret</span><span class="p">:</span>  <span class="n">Done</span> <span class="n">after</span> <span class="mi">2</span><span class="n">s</span>
<span class="n">Task</span> <span class="n">ret</span><span class="p">:</span>  <span class="n">Done</span> <span class="n">after</span> <span class="mi">4</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 协程中的嵌套<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p>
<p>来看个例子。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 用于内部的协程函数</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">do_some_work</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Waiting: &#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done after {}s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 外部的协程函数</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 创建三个协程对象</span>
    <span class="n">coroutine1</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">coroutine2</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">coroutine3</span> <span class="o">=</span> <span class="n">do_some_work</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 将协程转为task，并组成list</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine1</span><span class="p">),</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine2</span><span class="p">),</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coroutine3</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># 【重点】：await 一个task列表（协程）</span>
    <span class="c1"># dones：表示已经完成的任务</span>
    <span class="c1"># pendings：表示未完成的任务</span>
    <span class="n">dones</span><span class="p">,</span> <span class="n">pendings</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">dones</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Task ret: &#39;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>如果这边，使用的是<code class="docutils literal notranslate"><span class="pre">asyncio.gather()</span></code>，是这么用的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 注意这边返回结果，与await不一样</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Task ret: &#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出还是一样的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Waiting</span><span class="p">:</span>  <span class="mi">1</span>
<span class="n">Waiting</span><span class="p">:</span>  <span class="mi">2</span>
<span class="n">Waiting</span><span class="p">:</span>  <span class="mi">4</span>
<span class="n">Task</span> <span class="n">ret</span><span class="p">:</span>  <span class="n">Done</span> <span class="n">after</span> <span class="mi">1</span><span class="n">s</span>
<span class="n">Task</span> <span class="n">ret</span><span class="p">:</span>  <span class="n">Done</span> <span class="n">after</span> <span class="mi">2</span><span class="n">s</span>
<span class="n">Task</span> <span class="n">ret</span><span class="p">:</span>  <span class="n">Done</span> <span class="n">after</span> <span class="mi">4</span><span class="n">s</span>
</pre></div>
</div>
<p>仔细查看，可以发现这个例子完全是由
上面「<code class="docutils literal notranslate"><span class="pre">协程中的并发</span></code>」例子改编而来。结果完全一样。只是把创建协程对象，转换task任务，封装成在一个协程函数里而已。外部的协程，嵌套了一个内部的协程。</p>
<p>其实你如果去看下<code class="docutils literal notranslate"><span class="pre">asyncio.await()</span></code>的源码的话，你会发现下面这种写法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<p>看似没有嵌套，实际上内部也是嵌套的。</p>
<p>这里也把源码，贴出来，有兴趣可以看下，没兴趣，可以直接跳过。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 内部协程函数</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">_wait</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">return_when</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">fs</span><span class="p">,</span> <span class="s1">&#39;Set of Futures is empty.&#39;</span>
    <span class="n">waiter</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
    <span class="n">timeout_handle</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">timeout_handle</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">_release_waiter</span><span class="p">,</span> <span class="n">waiter</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_completion</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">nonlocal</span> <span class="n">counter</span>
        <span class="n">counter</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span>
            <span class="n">return_when</span> <span class="o">==</span> <span class="n">FIRST_COMPLETED</span> <span class="ow">or</span>
            <span class="n">return_when</span> <span class="o">==</span> <span class="n">FIRST_EXCEPTION</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">cancelled</span><span class="p">()</span> <span class="ow">and</span>
                                                <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">timeout_handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">timeout_handle</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">waiter</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                <span class="n">waiter</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">_on_completion</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">await</span> <span class="n">waiter</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">timeout_handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">timeout_handle</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">remove_done_callback</span><span class="p">(</span><span class="n">_on_completion</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pending</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">done</span><span class="p">,</span> <span class="n">pending</span>

<span class="c1"># 外部协程函数</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">ALL_COMPLETED</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">futures</span><span class="o">.</span><span class="n">isfuture</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="ow">or</span> <span class="n">coroutines</span><span class="o">.</span><span class="n">iscoroutine</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;expect a list of futures, not {type(fs).__name__}&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Set of coroutines/Futures is empty.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_when</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">FIRST_COMPLETED</span><span class="p">,</span> <span class="n">FIRST_EXCEPTION</span><span class="p">,</span> <span class="n">ALL_COMPLETED</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Invalid return_when value: {return_when}&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">loop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

    <span class="n">fs</span> <span class="o">=</span> <span class="p">{</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">fs</span><span class="p">)}</span>
    <span class="c1"># 【重点】：await一个内部协程</span>
    <span class="k">return</span> <span class="n">await</span> <span class="n">_wait</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">return_when</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 协程中的状态<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>还记得我们在讲生成器的时候，有提及过生成器的状态。同样，在协程这里，我们也了解一下协程（准确的说，应该是Future对象，或者Task任务）有哪些状态。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">Pending</span></code>：创建future，还未执行
<code class="docutils literal notranslate"><span class="pre">Running</span></code>：事件循环正在调用执行任务 <code class="docutils literal notranslate"><span class="pre">Done</span></code>：任务执行完毕
<code class="docutils literal notranslate"><span class="pre">Cancelled</span></code>：Task被取消后的状态</p>
</div></blockquote>
<p>可手工 <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">xx.py</span></code> 执行这段代码，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Running in the loop...&quot;</span><span class="p">)</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">flag</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;F:</span><span class="se">\\</span><span class="s2">test.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;------&quot;</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Stop the loop&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">coroutine</span> <span class="o">=</span> <span class="n">hello</span><span class="p">()</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>

    <span class="c1"># Pending：未执行状态</span>
    <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="p">,))</span>
        <span class="c1"># t1.daemon = True</span>
        <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="c1"># Running：运行中状态</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># 取消任务</span>
        <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="c1"># Cacelled：取消任务</span>
        <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>顺利执行的话，将会打印 <code class="docutils literal notranslate"><span class="pre">Pending</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Pending：Runing</span></code> -&gt;
<code class="docutils literal notranslate"><span class="pre">Finished</span></code> 的状态变化</p>
<p>假如，执行后 立马按下 Ctrl+C，则会触发task取消，就会打印 <code class="docutils literal notranslate"><span class="pre">Pending</span></code> -&gt;
<code class="docutils literal notranslate"><span class="pre">Cancelling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Cancelling</span></code> 的状态变化。</p>
</div>
<div class="section" id="gatherwait">
<h4>4. gather与wait<a class="headerlink" href="#gatherwait" title="Permalink to this headline">¶</a></h4>
<p>还记得上面我说，把多个协程注册进一个事件循环中有两种方法吗？ -
使用<code class="docutils literal notranslate"><span class="pre">asyncio.wait()</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>使用<code class="docutils literal notranslate"><span class="pre">asyncio.gather()</span></code></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 千万注意，这里的 「*」 不能省略</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">asyncio.gather</span></code> 和 <code class="docutils literal notranslate"><span class="pre">asyncio.wait</span></code>
在asyncio中用得的比较广泛，这里有必要好好研究下这两货。</p>
<p>还是照例用例子来说明，先定义一个协程函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Task </span><span class="si">%s</span><span class="s2">: Compute factorial(</span><span class="si">%s</span><span class="s2">)...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Task </span><span class="si">%s</span><span class="s2">: factorial(</span><span class="si">%s</span><span class="s2">) = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>5. 接收参数方式<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<div class="section" id="asyncio-wait">
<h5>asyncio.wait<a class="headerlink" href="#asyncio-wait" title="Permalink to this headline">¶</a></h5>
<p>接收的tasks，必须是一个list对象，这个list对象里，存放多个的task。</p>
<p>它可以这样，用<code class="docutils literal notranslate"><span class="pre">asyncio.ensure_future</span></code>转为task对象</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tasks</span><span class="o">=</span><span class="p">[</span>
       <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
       <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
       <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<p>也可以这样，不转为task对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">tasks</span><span class="o">=</span><span class="p">[</span>
       <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
       <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="asyncio-gather">
<h5>asyncio.gather<a class="headerlink" href="#asyncio-gather" title="Permalink to this headline">¶</a></h5>
<p>接收的就比较广泛了，他可以接收list对象，但是 <code class="docutils literal notranslate"><span class="pre">*</span></code> 不能省略</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tasks</span><span class="o">=</span><span class="p">[</span>
       <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
       <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
       <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">))</span>
</pre></div>
</div>
<p>还可以这样，和上面的 <code class="docutils literal notranslate"><span class="pre">*</span></code>
作用一致，这是因为<code class="docutils literal notranslate"><span class="pre">asyncio.gather()</span></code>的第一个参数是
<code class="docutils literal notranslate"><span class="pre">*coros_or_futures</span></code>，它叫
<code class="docutils literal notranslate"><span class="pre">非命名键值可变长参数列表</span></code>，可以集合所有没有命名的变量。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
    <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="p">))</span>
</pre></div>
</div>
<p>甚至还可以这样</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">group1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span> <span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="n">group2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="n">group3</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)])</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">,</span> <span class="n">group3</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h4>6. 返回结果不同<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<div class="section" id="asyncio-wait-1">
<span id="id6"></span><h5>asyncio.wait<a class="headerlink" href="#asyncio-wait-1" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">asyncio.wait</span></code> 返回<code class="docutils literal notranslate"><span class="pre">dones</span></code>和<code class="docutils literal notranslate"><span class="pre">pendings</span></code> -
<code class="docutils literal notranslate"><span class="pre">dones</span></code>：表示已经完成的任务 - <code class="docutils literal notranslate"><span class="pre">pendings</span></code>：表示未完成的任务</p>
<p>如果我们需要获取，运行结果，需要手工去收集获取。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dones</span><span class="p">,</span> <span class="n">pendings</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

<span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">dones</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Task ret: &#39;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="asyncio-gather-1">
<span id="id7"></span><h5>asyncio.gather<a class="headerlink" href="#asyncio-gather-1" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">asyncio.gather</span></code> 它会把值直接返回给我们，不需要手工去收集。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Task ret: &#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="wait">
<h4>7. wait有控制功能<a class="headerlink" href="#wait" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">coro</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">coro</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>


<span class="c1"># 【控制运行任务数】：运行第一个任务就返回</span>
<span class="c1"># FIRST_COMPLETED ：第一个任务完全返回</span>
<span class="c1"># FIRST_EXCEPTION：产生第一个异常返回</span>
<span class="c1"># ALL_COMPLETED：所有任务完成返回 （默认选项）</span>
<span class="n">dones</span><span class="p">,</span> <span class="n">pendings</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">FIRST_COMPLETED</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;第一次完成的任务数:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dones</span><span class="p">))</span>


<span class="c1"># 【控制时间】：运行一秒后，就返回</span>
<span class="n">dones2</span><span class="p">,</span> <span class="n">pendings2</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">pendings</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;第二次完成的任务数:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dones2</span><span class="p">))</span>


<span class="c1"># 【默认】：所有任务完成后返回</span>
<span class="n">dones3</span><span class="p">,</span> <span class="n">pendings3</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">pendings2</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;第三次完成的任务数:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dones3</span><span class="p">))</span>

<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>输出结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>第一次完成的任务数: 1
第二次完成的任务数: 4
第三次完成的任务数: 5
</pre></div>
</div>
</div>
</div>
<span id="document-c10/c10_11"></span><div class="section" id="io-asyncio">
<h3>10.11 【并发编程】实战异步IO框架：asyncio 下篇<a class="headerlink" href="#io-asyncio" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 动态添加协程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>在实战之前，我们要先了解下在asyncio中如何将协程态添加到事件循环中的。这是前提。</p>
<p>如何实现呢，有两种方法： - 主线程是同步的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">def</span> <span class="nf">start_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="c1"># 一个在后台永远运行的事件循环</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">do_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="n">new_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># 定义一个线程，并传入一个事件循环对象</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">start_loop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">new_loop</span><span class="p">,))</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>

<span class="c1"># 动态添加两个协程</span>
<span class="c1"># 这种方法，在主线程是同步的</span>
<span class="n">new_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">do_sleep</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="s2">&quot;第一个&quot;</span><span class="p">)</span>
<span class="n">new_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">do_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="s2">&quot;第二个&quot;</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} 协程运行完..&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>
</pre></div>
</div>
<p>由于是同步的，所以总共耗时6+3=9秒.</p>
<p>输出结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>Thu May 31 22:11:16 2018
第一个 协程运行完..
Thu May 31 22:11:22 2018
第二个 协程运行完..
Thu May 31 22:11:25 2018
</pre></div>
</div>
<ul class="simple">
<li><p>主线程是异步的，这是重点，一定要掌握。。</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">def</span> <span class="nf">start_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="c1"># 一个在后台永远运行的事件循环</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">do_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="n">new_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># 定义一个线程，并传入一个事件循环对象</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">start_loop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">new_loop</span><span class="p">,))</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>

<span class="c1"># 动态添加两个协程</span>
<span class="c1"># 这种方法，在主线程是异步的</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run_coroutine_threadsafe</span><span class="p">(</span><span class="n">do_sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="s2">&quot;第一个&quot;</span><span class="p">),</span> <span class="n">new_loop</span><span class="p">)</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run_coroutine_threadsafe</span><span class="p">(</span><span class="n">do_sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="s2">&quot;第二个&quot;</span><span class="p">),</span> <span class="n">new_loop</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} 协程运行完..&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>
</pre></div>
</div>
<p>输出结果</p>
<p>由于是同步的，所以总共耗时max(6, 3)=<code class="docutils literal notranslate"><span class="pre">6</span></code>秒</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>Thu May 31 22:23:35 2018
第二个 协程运行完..
Thu May 31 22:23:38 2018
第一个 协程运行完..
Thu May 31 22:23:41 2018
</pre></div>
</div>
</div>
<div class="section" id="redis">
<h4>2. 利用redis实现动态添加任务<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h4>
<p>对于并发任务，通常是用生成消费模型，对队列的处理可以使用类似master-worker的方式，master主要用户获取队列的msg，worker用户处理消息。</p>
<p>为了简单起见，并且协程更适合单线程的方式，我们的主线程用来监听队列，子线程用于处理队列。这里使用redis的队列。主线程中有一个是无限循环，用户消费队列。</p>
<p>先安装Redis 到 <a class="reference external" href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a> 下载
<img alt="image0" src="https://i.loli.net/2018/06/03/5b13ba8525bcf.png" /> 解压到你的路径。 <img alt="image1" src="https://i.loli.net/2018/06/03/5b13ba9f66baa.png" /></p>
<p>然后，在当前路径运行cmd，运行redis的服务端。 <img alt="image2" src="https://i.loli.net/2018/06/03/5b13bab682a32.png" />
服务开启后，我们就可以运行我们的客户端了。
并依次输入key=queue，value=5,3,1的消息。 <img alt="image3" src="https://i.loli.net/2018/06/03/5b13bad79f5ce.png" /></p>
<p>一切准备就绪之后，我们就可以运行我们的代码了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">redis</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">def</span> <span class="nf">start_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="c1"># 一个在后台永远运行的事件循环</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">do_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;ok&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_redis</span><span class="p">():</span>
    <span class="n">connection_pool</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">ConnectionPool</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">connection_pool</span><span class="o">=</span><span class="n">connection_pool</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">rcon</span><span class="o">.</span><span class="n">rpop</span><span class="p">(</span><span class="s2">&quot;queue&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">run_coroutine_threadsafe</span><span class="p">(</span><span class="n">do_sleep</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">queue</span><span class="p">),</span> <span class="n">new_loop</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>
    <span class="n">new_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

    <span class="c1"># 定义一个线程，运行一个事件循环对象，用于实时接收新任务</span>
    <span class="n">loop_thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">start_loop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">new_loop</span><span class="p">,))</span>
    <span class="n">loop_thread</span><span class="o">.</span><span class="n">setDaemon</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">loop_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c1"># 创建redis连接</span>
    <span class="n">rcon</span> <span class="o">=</span> <span class="n">get_redis</span><span class="p">()</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="c1"># 子线程：用于消费队列消息，并实时往事件对象容器中添加新任务</span>
    <span class="n">consumer_thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">)</span>
    <span class="n">consumer_thread</span><span class="o">.</span><span class="n">setDaemon</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">consumer_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;协程运行完..&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;当前时间：&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>
</pre></div>
</div>
<p>稍微讲下代码</p>
<p><code class="docutils literal notranslate"><span class="pre">loop_thread</span></code>：单独的线程，运行着一个事件对象容器，用于实时接收新任务。
<code class="docutils literal notranslate"><span class="pre">consumer_thread</span></code>：单独的线程，实时接收来自Redis的消息队列，并实时往事件对象容器中添加新任务。</p>
<p>输出结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>Thu May 31 23:42:48 2018
协程运行完..
当前时间： Thu May 31 23:42:49 2018

协程运行完..
当前时间： Thu May 31 23:42:51 2018

协程运行完..
当前时间： Thu May 31 23:42:53 2018
</pre></div>
</div>
<p>我们在Redis，分别发起了5s，3s，1s的任务。
从结果来看，这三个任务，确实是并发执行的，1s的任务最先结束，三个任务完成总耗时5s</p>
<p>运行后，程序是一直运行在后台的，我们每一次在Redis中输入新值，都会触发新任务的执行。。</p>
</div>
</div>
<span id="document-c10/c10_12"></span><div class="section" id="id1">
<h3>10.12 【并发编程】生成器与协程，你分清了吗？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>如你所见，下面这代码将定义一个生成器的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">eat</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">food</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;小明 吃完{}了&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">food</span><span class="p">))</span>
        <span class="k">yield</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;小明 要开始吃{}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">food</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">food</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">MING</span> <span class="o">=</span> <span class="n">eat</span><span class="p">()</span>     <span class="c1"># 产生一个生成器</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># 预激</span>
<span class="n">food</span> <span class="o">=</span> <span class="s2">&quot;面包&quot;</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;面包&#39;</span><span class="p">)</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;苹果&#39;</span><span class="p">)</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;香肠&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行一下，从结果中可以看出，不管我们塞给小明什么东西，小明都将只能将他们当成面包吃。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">小明</span> <span class="n">要开始吃面包</span><span class="o">...</span>
<span class="n">小明</span> <span class="n">吃完面包了</span>
<span class="n">小明</span> <span class="n">要开始吃面包</span><span class="o">...</span>
<span class="n">小明</span> <span class="n">吃完面包了</span>
<span class="n">小明</span> <span class="n">要开始吃面包</span><span class="o">...</span>
<span class="n">小明</span> <span class="n">吃完面包了</span>
</pre></div>
</div>
<p>那再来看一下协程的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">eat</span><span class="p">():</span>
    <span class="n">food</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">food</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;小明 吃完{}了&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">food</span><span class="p">))</span>
        <span class="n">food</span> <span class="o">=</span> <span class="k">yield</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;小明 开始吃{}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">food</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">MING</span> <span class="o">=</span> <span class="n">eat</span><span class="p">()</span>      <span class="c1"># 产生一个生成器</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>   <span class="c1"># 预激</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;面包&#39;</span><span class="p">)</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;苹果&#39;</span><span class="p">)</span>
<span class="n">MING</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;香肠&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行一下，从结果中可以看出，小明已经可以感知我们塞给他的是什么食物。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">小明</span> <span class="n">开始吃面包</span><span class="o">...</span>
<span class="n">小明</span> <span class="n">吃完面包了</span>
<span class="n">小明</span> <span class="n">开始吃苹果</span><span class="o">...</span>
<span class="n">小明</span> <span class="n">吃完苹果了</span>
<span class="n">小明</span> <span class="n">开始吃香肠</span><span class="o">...</span>
<span class="n">小明</span> <span class="n">吃完香肠了</span>
</pre></div>
</div>
<p>仔细观察一下，上面两段代码并没有太大的区别，我们将主要关注点集中在
<code class="docutils literal notranslate"><span class="pre">yidld</span></code> 关键词上。</p>
<p>可以发现，生成器里 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 左边并没有变量，而在协程里，<code class="docutils literal notranslate"><span class="pre">yield</span></code>
左边有一个变量。</p>
<p>在函数被调用后，一个生成器就产生了，而一般的生成器不能再往生成器内部传递参数了，而这个当生成器里的
yield
左边有变量时，就不一样了，它仍然可以在外部接收新的参数。这就是生成器与协程的最大区别。</p>
<p><strong>协程的优点：</strong></p>
<ul class="simple">
<li><p>线程属于系统级别调度，而协程是程序员级别的调度。使用协程避免了无意义的调度，减少了线程上下文切换的开销，由此可以提高性能。</p></li>
<li><p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p></li>
<li><p>无需原子操作锁定及同步的开销</p></li>
<li><p>方便切换控制流，简化编程模型</p></li>
</ul>
<p><strong>协程的缺点：</strong></p>
<p>　　（1）无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU
的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p>
<p>　　（2）进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>
<p>协程很类似于Javascript单线程下异步处理的概念，协程同样是单线程的，之所以能够进行并发是因为通过某种方式保存了执行栈的上下文，在一定条件下将执行权交由其他栈，在一定条件下又通过执行栈上下文恢复栈。</p>
</div>
<span id="document-c10/c10_13"></span><div class="section" id="id1">
<h3>10.14 【并发编程】浅谈线程安全那些事儿<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>在并发编程时，如果多个线程访问同一资源，我们需要保证访问的时候不会产生冲突，数据修改不会发生错误，这就是我们常说的
<strong>线程安全</strong> 。</p>
<p>那什么情况下，访问数据时是安全的？什么情况下，访问数据是不安全的？如何知道你的代码是否线程安全？要如何访问数据才能保证数据的安全？</p>
<p>本篇文章会一一回答你的问题。</p>
<div class="section" id="id2">
<h4>1. 线程不安全是怎样的？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>要搞清楚什么是线程安全，就要先了解线程不安全是什么样的。</p>
<p>比如下面这段代码，开启两个线程，对全局变量 number 各自增
10万次，每次自增 1。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Lock</span>

<span class="n">number</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">target</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">number</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">thread_01</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="n">thread_02</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="n">thread_01</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">thread_02</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">thread_01</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">thread_02</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</pre></div>
</div>
<p>正常我们的预期输出结果，一个线程自增100万，两个线程就自增 200
万嘛，输出肯定为 2000000 。</p>
<p>可事实却并不是你想的那样，不管你运行多少次，每次输出的结果都会不一样，而这些输出结果都有一个特点是，都小于
200 万。</p>
<p>以下是执行三次的结果</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">1459782</span>
<span class="mi">1379891</span>
<span class="mi">1432921</span>
</pre></div>
</div>
<p>这种现象就是线程不安全，究其根因，其实是我们的操作 <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">+=</span> <span class="pre">1</span></code>
，不是原子操作，才会导致的线程不安全。</p>
</div>
<div class="section" id="id3">
<h4>2. 什么是原子操作？<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>原子操作（<strong>atomic
operation</strong>），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程。</p>
<p>它有点类似数据库中的 <strong>事务</strong>。</p>
<p>在 Python
的<a class="reference external" href="https://docs.python.org/3.5/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe">官方文档</a>上，列出了一些常见原子操作</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">L1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L2</span>
<span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">x</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
<span class="n">D</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>而下面这些就不是原子操作</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>像上面的我使用自增操作 <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">+=</span> <span class="pre">1</span></code>，其实等价于
<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">=</span> <span class="pre">number</span> <span class="pre">+</span> <span class="pre">1</span></code>，可以看到这种可以拆分成多个步骤（先读取相加再赋值），并不属于原子操作。</p>
<p>这样就导致多个线程同时读取时，有可能读取到同一个 number
值，读取两次，却只加了一次，最终导致自增的次数小于预期。</p>
<p>当我们还是无法确定我们的代码是否具有原子性的时候，可以尝试通过 <code class="docutils literal notranslate"><span class="pre">dis</span></code>
模块里的 dis 函数来查看</p>
<p><img alt="image0" src="http://image.iswbm.com/20200506080445.png" /></p>
<p>当我们执行这段代码时，可以看到 <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">+=</span> <span class="pre">1</span></code>
这一行代码，由两条字节码实现。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BINARY_ADD</span></code> ：将两个值相加</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">STORE_GLOBAL</span></code>： 将相加后的值重新赋值</p></li>
</ul>
<p>每一条字节码指令都是一个整体，无法分割，他实现的效果也就是我们所说的原子操作。</p>
<p>当一行代码被分成多条字节码指令的时候，就代表在线程线程切换时，有可能只执行了一条字节码指令，此时若这行代码里有被多个线程共享的变量或资源时，并且拆分的多条指令里有对于这个共享变量的写操作，就会发生数据的冲突，导致数据的不准确。</p>
<p>为了对比，我们从上面列表的原子操作拿一个出来也来试试，是不是真如官网所说的原子操作。</p>
<p>这里我拿字典的 update 操作举例，代码和执行过程如下图</p>
<p><img alt="image1" src="http://image.iswbm.com/20200506081541.png" /></p>
<p>从截图里可以看到，<code class="docutils literal notranslate"><span class="pre">info.update(new)</span></code> 虽然也分为好几个操作</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code>：加载全局变量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LOAD_ATTR</span></code>： 加载属性，获取 update 方法</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LOAD_FAST</span></code>：加载 new 变量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CALL_FUNCTION</span></code>：调用函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">POP_TOP</span></code>：执行更新操作</p></li>
</ul>
<p>但我们要知道真正会引导数据冲突的，其实不是读操作，而是写操作。</p>
<p>上面这么多字节码指令，写操作都只有一个（<strong>POP_TOP</strong>），因此字典的
update 方法是原子操作。</p>
</div>
<div class="section" id="id4">
<h4>3. 实现人工原子操作<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>在多线程下，我们并不能保证我们的代码都具有原子性，因此如何让我们的代码变得具有
“原子性” ，就是一件很重要的事。</p>
<p>方法也很简单，就是当你在访问一个多线程间共享的资源时，加锁可以实现类似原子操作的效果，一个代码要嘛不执行，执行了的话就要执行完毕，才能接受线程的调度。</p>
<p>因此，我们使用加锁的方法，对例子一进行一些修改，使其具备原子性。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Lock</span>


<span class="n">number</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">target</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">number</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">thread_01</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="n">thread_02</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="n">thread_01</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">thread_02</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">thread_01</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">thread_02</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</pre></div>
</div>
<p>此时，不管你执行多少遍，输出都是 2000000.</p>
</div>
<div class="section" id="queue">
<h4>4. 为什么 Queue 是线程安全的？<a class="headerlink" href="#queue" title="Permalink to this headline">¶</a></h4>
<p>Python 的 threading 模块里的消息通信机制主要有如下三种：</p>
<ol class="arabic simple">
<li><p>Event</p></li>
<li><p>Condition</p></li>
<li><p>Queue</p></li>
</ol>
<p>使用最多的是
Queue，而我们都知道它是线程安全的。当我们对它进行写入和提取的操作不会被中断而导致错误，这也是我们在使用队列时，不需要额外加锁的原因。</p>
<p>他是如何做到的呢？</p>
<p>其根本原因就是 Queue
实现了锁原语，因此他能像第三节那样实现人工原子操作。</p>
<blockquote>
<div><p>原语指由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性；即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</div></blockquote>
</div>
<div class="section" id="id5">
<h4>参考文章：<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://zhuanlan.zhihu.com/p/34150765">https://zhuanlan.zhihu.com/p/34150765</a></p>
<p><a class="reference external" href="https://juejin.im/post/5b129a1be51d45068a6c91d4#comment">https://juejin.im/post/5b129a1be51d45068a6c91d4#comment</a></p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p11"></span><div class="section" id="id1">
<h2>第十一章：代码美化<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c11/c11_01"></span><div class="section" id="id1">
<h3>11.1 【代码美化】如何更好进行变量的命名？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>命名是一件困难的事情，要想出一个恰到好处的命名需要一番功夫，尤其我们的母语还不是编程语言所通用的英语。不过这一切都是值得了，好的命名让你的代码更直观，更有表达力。</p>
<p>在进行变量的命名时，应注意：</p>
<ol class="arabic simple">
<li><p>变量名，最好能体现 『变量用途』，『数据类型』，『单复数』等</p></li>
<li><p>变量名，请不要过于随便，如使用数字 1，和字母 a</p></li>
<li><p>变量名，不要如不能正确引导，至少要做到不误导。比如 user_list
不应该是一个字典类型</p></li>
<li><p>变量名，请使用蛇形命名法（如
user_info），而不是使用驼峰命名法（userInfo）。</p></li>
</ol>
</div>
<span id="document-c11/c11_02"></span><div class="section" id="id1">
<h3>11.2 【代码美化】写好函数的 6 个建议<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Python 虽然好用，但用好真的很难。</p>
<p>尤其是函数部分，只要写不好，后面的一连串人都会遭殃。</p>
<p>看又看不懂，测试起来也麻烦，维护又维护不动，真是让人头疼。</p>
<p>那怎么写好一个 Python 函数呢？</p>
<p>《Writing Idiomatic Python》一书的作者在 Medium 上发表了一篇文章，给出了
6 个建议。</p>
<p>希望能够给你带来帮助。</p>
<div class="section" id="id2">
<h4>0. 怎样算是好函数？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>“好”的 Python 函数和“差”的 Python
函数之间有什么差别呢？每个人都有自己的理解。基于我的理解，如果一个
Python 函数能够符合下面的大部分条件，我会认为它是一个“好”函数：</p>
<ul class="simple">
<li><p>命名合理</p></li>
<li><p>单一功能</p></li>
<li><p>包括文档字符串</p></li>
<li><p>返回一个值</p></li>
<li><p>不超过 50 行</p></li>
<li><p>是幂等函数或纯函数</p></li>
</ul>
<p>对许多人来说，这些要求可能显得过于苛刻了。</p>
<p>不过，我保证，如果你的函数遵循这些规则，你的代码会非常漂亮，会让其他的程序员都“馋哭”的。</p>
<p>下面，我将一一讨论这些规则，然后总结它们是如何创造“好”函数的。</p>
</div>
<div class="section" id="id3">
<h4>1. 注意命名<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>在这个问题上，我最喜欢的一句话是：</p>
<blockquote>
<div><p>计算机科学中只有两件事很让人头疼：缓存失效和命名。</p>
</div></blockquote>
<p>尽管这听起来很莫名其妙，但给一个事情命名太难了。下面是一个反面案例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getknn</span><span class="p">(</span><span class="n">from_df</span><span class="p">):</span>
</pre></div>
</div>
<p>原文中这个代码没有放上去，我们根据上下文信息进行了补充。</p>
<p>这个函数命名的第一个问题是它使用了缩写。</p>
<p>对于那些并不出名的缩略词来说，使用完整的英语单词会更好。缩写单词的唯一原因是为了节省打字时间，但是每个现代编辑器都有自动填充功能，所以你只需要键入一次全名就可以了。</p>
<p>缩写通常是特定领域的。在上面的代码中，KNN 指的是“K-Nearest
Neighbors”，df
指的是“DataFrame”，这是一个数据结构。如果另一个不熟悉这些首字母缩写的程序员正在阅读代码，几乎很难看懂。</p>
<p>关于这个函数的名字还有另外两个小瑕疵：</p>
<ul class="simple">
<li><p>“get”这个词是无关紧要的。对于大多数命名比较好的函数来说，很明显有一些东西会从函数中返回，它的名字将反映这一点。</p></li>
<li><p>from_df
也不是必要的。如果没有明确的参数名称，函数的文档字符串或类型注释会描述参数的类型。</p></li>
</ul>
<p>那么我们如何重命名这个函数呢？很简单：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">k_nearest_neighbors</span><span class="p">(</span><span class="n">dataframe</span><span class="p">):</span>
</pre></div>
</div>
<p>即使是外行，这个函数要计算的内容也很清楚，参数的名称(dataframe)也清楚地表明了参数类型。</p>
</div>
<div class="section" id="id4">
<h4>2. 单一功能<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>单一功能原则不仅适用于类和模块，也同样适用于函数。</p>
<p>一个函数应该只有一个功能。也就是说，它应该只做一件事。</p>
<p>一个重要的原因是，如果每个函数只做一件事，只有这件事发生了变化，才需要改变这个函数。</p>
<p>此外，如果这个函数的单个功能不再需要了，直接把它删了就行了。</p>
<p>还是用例子来说明吧。下面这个函数，可以做不止一件“事情”:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_and</span> <span class="n">print_stats</span><span class="p">(</span><span class="n">list_of_numbers</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">list_of_numbers</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">list_of_numbers</span><span class="p">)</span>
    <span class="n">median</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">list_of_numbers</span><span class="p">)</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">list_of_numbers</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;-----------------Stats-----------------&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;SUM: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;MEAN: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;MEDIAN: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">median</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;MODE: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
</pre></div>
</div>
<p>这个函数做了两件事：一是计算一组关于数字列表的统计数据，二是将它们打印到
STDOUT。</p>
<p>如果需要计算新的或不同的统计数据，或者需要改变输出的格式，就需要对这个函数进行调整。</p>
<p>所以，这个函数最好写成两个独立的函数：一个用来执行并返回计算结果，另一个用来获取这些结果并打印出来。</p>
<p>这种处理方式，不仅能让测试函数更容易，并且还允许这两个部分有了迁移性，如果合适的话，还可能一起应用到不同的模块中。</p>
<p>在编程中，你会发现好多函数都可以做很多很多事情。同样，为了可读性和可测试性，这些函数应该被分解成更小的函数，每个函数只有一个功能。</p>
</div>
<div class="section" id="docstrings">
<h4>3. 文档字符串（Docstrings）<a class="headerlink" href="#docstrings" title="Permalink to this headline">¶</a></h4>
<p>虽然每个人似乎都知道 PEP - 8，它定义了 Python
的样式指南，但是很少有人知道 PEP -
257，它是关于文档字符串的。我再这里不简单地重复 PEP - 257
的内容了，你可以在闲暇时读一下。其中的关键内容是：</p>
<ul class="simple">
<li><p>每个函数都需要有一个文档字符串</p></li>
<li><p>使用适当的语法和标点符号；用完整的句子写</p></li>
<li><p>首先对函数的作用进行一句话的总结</p></li>
<li><p>使用说明性语言而不是描述性语言</p></li>
</ul>
<p>在编写函数时，要养成写文档字符串的习惯，并在编写函数代码之前尝试写一下。</p>
<p>如果你不能写一个清晰的文档字符串来描述函数做什么，就说明你需要再考虑考虑为什么要写这个函数了。</p>
</div>
<div class="section" id="id5">
<h4>4. 返回值<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>函数可以被认为是一些独立的程序。它们以参数的形式接受一些输入，并返回一些结果。</p>
<p>参数有没有都可以，但从 Python
内部的角度来看，返回值是必须要有的。你不可能创建一个没有返回值的函数。如果函数没有返回值，Python
会“强制”返回 None。你可以测试一下这段代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>❯ python3
Python 3.7.0 (default, Jul 232018, 20:22:55)
[Clang 9.1.0 (clang-902.0.39.2)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot;or&quot;license&quot;for more information.
&gt;&gt;&gt; def add(a, b):
...   print(a + b)
...
&gt;&gt;&gt; b = add(1, 2)
3
&gt;&gt;&gt; b
&gt;&gt;&gt; b isNone
True
</pre></div>
</div>
<p>你会发现 b 的返回值实际上是
None。即使你写的函数没有返回语句，它仍然会返回一些东西。而且，每个函数都应该返回一个有用的值，测试起来也会更方便。毕竟，你写的代码应该能够被测试。</p>
<p>试想一下，测试上面的 add
函会有多艰难。遵循这个概念，我们应该这样写代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">input_file</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">input_file</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;cat&#39;</span><span class="p">):</span>
        <span class="c1"># ... do something useful with these lines</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">line.strip().lower().endswith(‘cat’):</span></code>
这一行能够工作，是因为每个字符串方法( strip ( )、lower ( )、end swith (
) )都返回一个字符串作为调用函数的结果。</p>
<p>当给定函数没有返回值时，有一些常见的原因：</p>
<p><strong>“它所做的只是[一些与 I/O
相关的事情，比如将一个值保存到数据库中]。我不能返回任何有用的东西。”</strong></p>
<p>我不同意。如果操作顺利完成，函数可以返回 True。</p>
<p><strong>“我们修改了其中一个参数，将其用作参考参数。”</strong></p>
<p>这里有两点需要注意。首先，尽最大努力避免这种做法。用好了令人惊讶，用不好非常危险。</p>
<p>其次，即使这样做不可行，复制某个参数的成本太高，你也可以回到上一条建议。</p>
<p><strong>“我需要返回多个值。单独返回一个值是没有意义的。”</strong></p>
<p>可以使用元组返回多个值。</p>
<p>总是返回一个有用的值，调用者总是可以自由地忽略它们。</p>
</div>
<div class="section" id="id6">
<h4>5. 函数长度<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>让你读一个 200 行的函数，并说出它是做什么的，你是什么感受？</p>
<p>函数的长度直接影响可读性，从而影响可维护性。所以要保持你的函数简短。50
行是一个随意的数字，在我看来是合理的。你编写的大多数函数应该要短一些。</p>
<p>如果一个函数遵循单一功能原则，它很可能是相当短的。如果它是纯函数或是幂等的(下面讨论)
，它也可能是短的。</p>
<p>那么，如果函数太长，应该怎么做？重构。这会改变程序的结构而不改变其行为。</p>
<p>从一个长函数中提取几行代码，并把它们变成自己的函数。这是缩短长函数的最快、也是最常见的方式。</p>
<p>加上你给所有这些新函数取了合适的名称，因此生成的代码读起来也会更容易。</p>
</div>
<div class="section" id="id7">
<h4>6. 幂等和函数纯度<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>不管被调用了多少次，幂等函数总是在给定相同参数集的情况下返回相同的值。</p>
<p>结果不依赖于非局部变量、参数的可变性或来自任何 I / O
流的数据。下面的这个 add_three(number)函数是幂等函数：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_three</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return *number* + 3.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">3</span>
</pre></div>
</div>
<p>不管一个人调用 add_three(7)多少次，答案总是 10。以下是一个非幂等函数：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_three</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return 3 + the number entered by the user.&quot;&quot;&quot;</span>
    <span class="n">number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Enter a number: &#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">3</span>
</pre></div>
</div>
<p>这个函数的返回值取决于 I / O，即用户输入的数字。对
add_three()的每次调用都会返回不同的值。</p>
<p>如果它被调用两次，用户可以第一次输入 3，第二次输入 7，分别调用
add_three()返回 6 和 10。</p>
<p>幂等性的一个现实中例子是在电梯前点击“向上”按钮。第一次按时，电梯会被“通知”你要上去。因为按按钮是幂等的，所以反复按它都没有什么影响。结果是一样的。</p>
<div class="section" id="id8">
<h5>6.1 为什么幂等很重要？<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>可维护性和可维护性。幂等函数很容易测试，因为在使用相同的参数时，它们总是返回相同的结果。</p>
<p>测试仅仅是检查通过不同调用返回值的预期值。更重要的是，这些测试很快，这是单元测试中一个重要且经常被忽视的问题。</p>
<p>而在处理幂等函数时，重构是轻而易举的事情。无论如何在函数之外更改代码，使用相同的参数调用它的结果总是一样的。</p>
</div>
<div class="section" id="id9">
<h5>6.2 什么是纯函数？<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>在函数编程中，如果一个函数既幂等又没有可观察到的副作用，它就被认为是纯函数。函数外部的任何东西都不会影响这个值。</p>
<p>然而，这并不意味着函数不能影响非局部变量或 I / O
流之类的事情。例如，如果上面
add_three(number)的幂等版本在返回结果之前打印了结果，那么它仍然被认为是幂等的，因为当它访问
I / O 流时，这个访问与从函数返回的值无关。</p>
<p>调用
print()只是一个副作用：除了返回值之外，还与程序的其他部分或系统本身进行了一些交互。</p>
<p>让我们把我们的
add_three(number)示例再向前推进一步。我们可以编写下面的代码片段来确定调用
add_three(number)的次数：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add_three_calls</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">add_three</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return *number* + 3.&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">add_three_calls</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Returning {number + 3}&#39;</span><span class="p">)</span>
    <span class="n">add_three_calls</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">def</span> <span class="nf">num_calls</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the number of times *add_three* was called.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">add_three_calls</span>
</pre></div>
</div>
<p>我们现在正在打印到控制台(一个副作用)并修改一个非局部变量(另一个副作用)，但是由于这两者都不影响函数返回的值，它仍然是幂等的。</p>
<p>纯函数没有副作用。它不仅不使用任何“外部数据”来计算值，除了计算和返回所述值之外，它与系统/程序的其余部分都没有交互。因此，虽然我们新的
add_three(number)定义仍然是幂等的，但它不再是纯的。</p>
<p>纯函数没有日志语句或
print()调用。它们不使用数据库或互联网连接。它们不访问或修改非局部变量。它们不调用任何其他非纯函数。</p>
<p>简而言之，它们无法做到爱因斯坦所说的“远距离幽灵般的行动”(在计算机科学环境中)。它们不会以任何方式修改程序或系统的其余部分。</p>
<p>在命令式编程(编写 Python
代码时所做的那种)中，它们是所有函数中最安全的函数。</p>
<p>它们也很容易被测试和维护，甚至比只是幂等函数更重要的是，测试它们基本上可以和执行它们一样快。</p>
<p>测试本身很简单：没有数据库连接或其他外部资源进行模拟，也不需要安装代码，之后也没有什么需要清理的。</p>
<p>明确地说，幂等性和纯函数只是一种期望，不是必需的。也就是说，由于好处很多，我们可能会希望只编写纯函数或幂等函数，但这不现实。</p>
<p>重要的是，我们要有意识开始写代码来隔离副作用和外部依赖性。这会使得我们编写的每一行代码都更容易被测试。</p>
</div>
</div>
</div>
<span id="document-c11/c11_03"></span><div class="section" id="pep8">
<h3>11.3 【代码美化】自觉遵守 PEP8 代码风格<a class="headerlink" href="#pep8" title="Permalink to this headline">¶</a></h3>
<p>每个编程语言都有自己的编码，而在 Python 中最受认可的是 PEP
8的编码风格规范。每个写 Python 代码的人都有必要过一遍 PEP 8的内容
，它可以让你的代码“ 更好看”，更容易被阅读。</p>
<div class="section" id="id1">
<h4>1. 代码编排<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。</p></li>
<li><p>每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。</p></li>
<li><p>类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。</p></li>
</ol>
</div>
<div class="section" id="id2">
<h4>2. 文档编排<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。</p></li>
<li><p>不要在一句import中多个库，比如import os, sys不推荐。</p></li>
<li><p>如果采用from XX import XX引用库，可以省略
module，都是可能出现命名冲突，这时就要采用import XX。</p></li>
</ol>
</div>
<div class="section" id="id3">
<h4>3. 空格的使用<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>总体原则，避免不必要的空格。</p>
<ol class="arabic simple">
<li><p>各种右括号前不要加空格。</p></li>
<li><p>逗号、冒号、分号前不要加空格。</p></li>
<li><p>函数的左括号前不要加空格。如Func(1)。</p></li>
<li><p>序列的左括号前不要加空格。如list[2]。</p></li>
<li><p>操作符左右各加一个空格，不要为了对齐增加空格。</p></li>
<li><p>函数默认参数使用的赋值符左右省略空格。</p></li>
<li><p>不要将多句语句写在同一行，尽管使用‘；’允许。</p></li>
<li><p>if/for/while语句中，即使执行语句只有一句，也必须另起一行。</p></li>
</ol>
</div>
<div class="section" id="id4">
<h4>4. 注释<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。</p>
<p>1、块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Description : Module config.</span>
<span class="c1">#</span>
<span class="c1"># Input : None</span>
<span class="c1">#</span>
<span class="c1"># Output : None</span>
</pre></div>
</div>
<p>2、行注释，在一句代码后加注释。比如：(但是这种方式尽量少使用)</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">x</span> <span class="o">=</span> x + <span class="m">1</span>       <span class="c1"># Increment x</span>
</pre></div>
</div>
<p>3、避免无谓的注释。</p>
</div>
<div class="section" id="id5">
<h4>5. 文档描述<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。</p></li>
<li><p>如果docstring要换行，参考如下例子,详见PEP 257</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Return a foobang</span>
<span class="sd">Optional plotz says to frobnicate the bizbaz first.</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>6. 命名规范<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。</p>
<ol class="arabic simple">
<li><p>尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。</p></li>
<li><p>模块命名尽量短小，使用全部小写的方式，可以使用下划线。</p></li>
<li><p>包命名尽量短小，使用全部小写的方式，不可以使用下划线。
4.类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。</p></li>
<li><p>异常命名使用CapWords+Error后缀的方式。</p></li>
<li><p>全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是<strong>all</strong>机制;二是前缀一个下划线。</p></li>
<li><p>函数命名使用全部小写的方式，可以使用下划线。</p></li>
<li><p>常量命名使用全部大写的方式，可以使用下划线。</p></li>
<li><p>类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。</p></li>
<li><p>类的属性有3种作用域public、non-public和subclass
API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。</p></li>
<li><p>类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。</p></li>
<li><p>为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。</p></li>
<li><p>类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。</p></li>
</ol>
</div>
</div>
<span id="document-c11/c11_04"></span><div class="section" id="pythonic-15">
<h3>11.4 【代码美化】Pythonic 代码的 15 个案例<a class="headerlink" href="#pythonic-15" title="Permalink to this headline">¶</a></h3>
<p>Python由于语言的简洁性，让我们以人类思考的方式来写代码，新手更容易上手，老鸟更爱不释手。</p>
<p>要写出
Pythonic（优雅的、地道的、整洁的）代码，还要平时多观察那些大牛代码，这里明哥收集了一些比较常见的
Pythonic 写法，帮助你养成写优秀代码的习惯。</p>
<div class="section" id="id1">
<h4>01. 变量交换<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>交换两个变量的值，正常都会想利用一个中间临时变量来过渡。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span>
</pre></div>
</div>
<p>能用一行代码解决的（并且不影响可读性的），决不用三行代码。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span><span class="n">a</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>02. 列表推导<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>下面是一个非常简单的 for 循环。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">my_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>在一个 for
循环中，如果逻辑比较简单，不如试用一下列表的列表推导式，虽然只有一行代码，但也逻辑清晰。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>03. 单行表达式<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>上面两个案例，都将多行代码用另一种方式写成了一行代码。</p>
<p>这并不意味着，代码行数越少，就越 Pythonic 。</p>
<p>比如下面这样写，就不推荐。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;hello,world&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="o">&lt;</span><span class="nb">complex</span> <span class="n">comparison</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="o">&lt;</span><span class="n">other</span> <span class="nb">complex</span> <span class="n">comparison</span><span class="o">&gt;</span><span class="p">:</span>
    <span class="c1"># do something</span>
</pre></div>
</div>
<p>建议还是按照如下的写法来</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>print（&#39;hello&#39;）
print（&#39;world&#39;）

if x == 1:
    print(&#39;hello,world&#39;)

cond1 = &lt;complex comparison&gt;
cond2 = &lt;other complex comparison&gt;
if cond1 and cond2:
    # do something
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>04. 带索引遍历<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>使用 for 循环时，如何取得对应的索引，初学者习惯使用 range + len 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_list</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="n">my_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>更好的做法是利用 enumerate 这个内置函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;--&gt;&quot;</span><span class="p">,</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>05. 序列解包<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">*</span></code> 可以对一个列表解包</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1"># a = 1, rest = [2, 3]</span>

<span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">middle</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1"># a = 1, middle = [2, 3], c = 4</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>06. 字符串拼接<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>如果一个列表（或者可迭代对象）中的所有元素都是字符串对象，想要将他们连接起来，通常做法是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">]</span>
<span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
<span class="k">for</span> <span class="n">let</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">let</span>
</pre></div>
</div>
<p>更推荐的做法是使用 join 函数</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">]</span>
<span class="n">word</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>07. 真假判断<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>判断一个变量是否为真（假），新手习惯直接使用 <code class="docutils literal notranslate"><span class="pre">==</span></code> 与 True、False、None
进行对比</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;True!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;attr is None!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>实际上，<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">[]</span></code>、<code class="docutils literal notranslate"><span class="pre">{}</span></code>
这些没有任何元素的容器都是假值，可直接使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">xx</span></code> 来判断。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">attr</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;attr is truthy!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;attr is falsey!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>08. 访问字典元素<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>当直接使用 <code class="docutils literal notranslate"><span class="pre">[]</span></code>
来访问字典里的元素时，若key不存在，是会抛异常的，所以新会可能会先判断一下是否有这个
key，有再取之。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;hello&#39;</span><span class="p">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}</span>
<span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">])</span>    <span class="c1"># prints &#39;world&#39;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;default_value&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>更推荐的做法是使用 <code class="docutils literal notranslate"><span class="pre">get</span></code> 来取，如果没有该 key 会默认返回
None（当然你也可以设置默认返回值）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;hello&#39;</span><span class="p">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}</span>

<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;default_value&#39;</span><span class="p">))</span> <span class="c1"># prints &#39;world&#39;</span>
<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;thingy&#39;</span><span class="p">,</span> <span class="s1">&#39;default_value&#39;</span><span class="p">))</span> <span class="c1"># prints &#39;default_value&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>09. 操作列表<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>下面这段代码，会根据条件过滤过列表中的元素</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>实际上可以使用列表推导或者高阶函数 filter 来实现</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1"># Or:</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>除了 filter 之外，还有 map、reduce 这两个函数也很好用</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="c1"># b: [6,7,8]</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h4>10. 文件读取<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>文件读取是非常常用的操作，在使用完句柄后，是需要手动调用 close
函数来关闭句柄的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;file.txt&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>如果代码写得太长，即使你知道需要手动关闭句柄，却也会经常会漏掉。因此推荐养成习惯使用
<code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">open</span></code> 来读写文件，上下文管理器会自动执行关闭句柄的操作</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;file.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4>11. 代码续行<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>将一个长度较长的字符串放在一行中，是很影响代码可读性的(下面代码可向左滑动)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">long_string</span> <span class="o">=</span> <span class="s1">&#39;For a long time I used to go to bed early. Sometimes, when I had put out my candle, my eyes would close so quickly that I had not even time to say “I’m going to sleep.”&#39;</span>
</pre></div>
</div>
<p>稍等注重代码可读性的人，会使用三个引号 <code class="docutils literal notranslate"><span class="pre">\</span></code>来续写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">long_string</span> <span class="o">=</span> <span class="s1">&#39;For a long time I used to go to bed early. &#39;</span> \
              <span class="s1">&#39;Sometimes, when I had put out my candle, &#39;</span> \
              <span class="s1">&#39;my eyes would close so quickly that I had not even time to say “I’m going to sleep.”&#39;</span>
</pre></div>
</div>
<p>不过，对我来说，我更喜欢这样子写 使用括号包裹 <code class="docutils literal notranslate"><span class="pre">()</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">long_string</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;For a long time I used to go to bed early. Sometimes, &quot;</span>
    <span class="s2">&quot;when I had put out my candle, my eyes would close so quickly &quot;</span>
    <span class="s2">&quot;that I had not even time to say “I’m going to sleep.”&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>导包的时候亦是如此</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">some.deep.module.inside.a.module</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">a_nice_function</span><span class="p">,</span> <span class="n">another_nice_function</span><span class="p">,</span> <span class="n">yet_another_nice_function</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h4>12. 显式代码<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>有时候出于需要，我们会使用一些特殊的魔法来使代码适应更多的场景不确定性。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_complex</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
</pre></div>
</div>
<p>但若非必要，请不要那么做。无端增加代码的不确定性，会让原先本就动态的语言写出更加动态的代码。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h4>13. 使用占位符<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>对于暂不需要，却又不得不接收的的变量，请使用占位符</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foobar.txt&#39;</span>
<span class="n">basename</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>14. 链式比较<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>对于下面这种写法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">score</span> <span class="o">=</span> <span class="mi">85</span>
<span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="mi">80</span> <span class="ow">and</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;良好&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>其实还有更好的写法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">score</span> <span class="o">=</span> <span class="mi">85</span>
<span class="k">if</span> <span class="mi">80</span> <span class="o">&lt;</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;良好&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你理解了上面的链式比较操作，那么你应该知道为什么下面这行代码输出的结果是
False</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">==</span> <span class="kc">False</span> <span class="o">==</span> <span class="kc">True</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>15. 三目运算<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>对于简单的判断并赋值</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">age</span> <span class="o">=</span> <span class="mi">20</span>
<span class="k">if</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">:</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;adult&quot;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;teenager&quot;</span>
</pre></div>
</div>
<p>其实是可以使用三目运算，一行搞定。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">age</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;adult&quot;</span> <span class="k">if</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">18</span> <span class="k">else</span> <span class="s2">&quot;teenager&quot;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c11/c11_05"></span><div class="section" id="python-20">
<h3>11.5 【代码美化】写出漂亮 Python 代码的 20条准则<a class="headerlink" href="#python-20" title="Permalink to this headline">¶</a></h3>
<p>通常，当我们在学校学习时，编程美学不是一个关键问题。用 Python
写代码时，个人也会遵循自己的风格。然而，当我们必须花大把时间来理解一个人的隐式代码时，这项工作肯定不受欢迎，这种情况同样可能发生在别人阅读我们的代码时。所以，让我们聚焦
Python 之禅和一些改进技巧，从而解决问题。</p>
<div class="section" id="python">
<h4>1. Python 之禅？<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h4>
<p>对于此前没听说过的人，请在 Python
解释器中键入并执行<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>，会出现由 Tim Peters 撰写的 19
条指导原则：</p>
<ol class="arabic simple">
<li><p>优美胜于丑陋；</p></li>
<li><p>明了胜于晦涩；</p></li>
<li><p>简单胜于复杂；</p></li>
<li><p>复杂胜于晦涩；</p></li>
<li><p>扁平胜于嵌套；</p></li>
<li><p>间隔胜于紧凑；</p></li>
<li><p>可读性很重要；</p></li>
<li><p>特例不足以特殊到违背这些原则；</p></li>
<li><p>实用性胜过纯粹；</p></li>
<li><p>永远不要默默地忽视错误；</p></li>
<li><p>除非明确需要这样做；</p></li>
<li><p>面对模棱两可，拒绝猜测；</p></li>
<li><p>解决问题最直接的方法应该有一种，最好只有一种；</p></li>
<li><p>当然这是没法一蹴而就的，除非你是荷兰人；</p></li>
<li><p>做也许好过不做；</p></li>
<li><p>但不想就做还不如不做；</p></li>
<li><p>如果方案难以描述明白，那么一定是个糟糕的方案；</p></li>
<li><p>如果实现容易描述，那可能是个好方案；</p></li>
<li><p>命名空间是一种绝妙的理念，多加利用！</p></li>
</ol>
<p>在这篇文章中，我将分享自己对这些格言的理解以及我学到的一些有用的 Python
技巧。</p>
</div>
<div class="section" id="id1">
<h4>2. 优美胜于丑陋<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Python 具有语法简单、代码可读性强和命令类似英语等特点，这让编写 Python
代码比使用其他编程语言更容易、更高效。例如，使用<code class="docutils literal notranslate"><span class="pre">or</span></code>
<code class="docutils literal notranslate"><span class="pre">and</span></code>和<code class="docutils literal notranslate"><span class="pre">||</span> <span class="pre">&amp;&amp;</span></code>构建语义相同的表达式：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># &amp;&amp;, ||</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>

<span class="c1"># and, or</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>

<span class="c1"># 这两个逻辑表达式在 Python 中是相同的</span>
<span class="c1"># 从语义的角度来看，可以使用选择操作符来构造完全相同的表达式。</span>
</pre></div>
</div>
<p>此外，代码的布局和组成非常重要，有大量资源涉及这个主题。下面是最受欢迎也是我最喜欢的一个：PEP
8——Python 代码风格指南。</p>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></p>
<p>浏览完 PEP8 后，看看下面这些文章，其中展示了一些亮点和应用：</p>
<ul>
<li><p>如何参照 PEP 8 编写漂亮的 Python 代码</p>
<p><a class="reference external" href="https://realpython.com/python-pep8/">https://realpython.com/python-pep8/</a></p>
</li>
<li><p>优雅的 Python 与 PEP8</p>
<p><a class="reference external" href="https://medium.com/&#64;mariasurmenok/stylish-python-with-pep8-c3ca93531418">https://medium.com/&#64;mariasurmenok/stylish-python-with-pep8-c3ca93531418</a></p>
</li>
<li><p>PEP-8 的陷阱</p>
<p><a class="reference external" href="https://medium.com/&#64;ian.reinert/the-pitfalls-of-pep-8-b6108b006ed9">https://medium.com/&#64;ian.reinert/the-pitfalls-of-pep-8-b6108b006ed9</a></p>
</li>
</ul>
<p>永远不要弄乱你的代码。要优雅而美丽。</p>
</div>
<div class="section" id="id2">
<h4>3. 明了胜于晦涩<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在 Python
中，良好的命名约定不仅可以提升你的课堂成绩，而且还能让你的代码更明了。幸运的是，你能在
PEP8 中找到一些指导原则，我想在下面强调其中的一些要点。</p>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></p>
<ul class="simple">
<li><p>一般来说，避免使用以下名称：</p></li>
<li><p>太宽泛，如<code class="docutils literal notranslate"><span class="pre">my_list</span></code>；</p></li>
<li><p>太冗长，如<code class="docutils literal notranslate"><span class="pre">list_of_machine_learning_data_set</span></code>；</p></li>
<li><p>太模糊，如“1”、“I”、“o”、“O”。</p></li>
<li><p>包 / 模块名应该全部小写：</p></li>
<li><p>首选使用一个单词命名；</p></li>
<li><p>当需要使用多个单词时，使用下划线分割它们。</p></li>
<li><p>类名应遵循 UpperCaseCamelCase 规范</p></li>
<li><p>变量:raw-latex:<cite>方法</cite>:raw-latex:<a href="#id3"><span class="problematic" id="id4">`</span></a>函数应该采用小写`（如果需要，用下划线分割）</p></li>
<li><p>常量名必须全大写（如果需要，用下划线分割）</p></li>
</ul>
<p>一切都必须清晰易懂。</p>
</div>
<div class="section" id="id5">
<h4>4. 简单胜于复杂<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>简单比复杂更难：你必须付出巨大艰辛，化繁为简。但这一切到最后都是值得的，因为一旦你做到了，你便能创造奇迹。——乔布斯</p>
</div></blockquote>
<p>很多时候，在处理迭代器时，我们还需要保存迭代计数。Python
通过提供一个名为<code class="docutils literal notranslate"><span class="pre">enumerate()</span></code>的内置函数简化这一任务。以下是一种不成熟的方法，然后是推荐方法：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hannibal&#39;</span><span class="p">,</span> <span class="s1">&#39;Hanny&#39;</span><span class="p">,</span> <span class="s1">&#39;Steeve&#39;</span><span class="p">]</span>
<span class="c1"># 不成熟的方法</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># 推荐方法</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
</pre></div>
</div>
<p>另一个示例是使用内置的<code class="docutils literal notranslate"><span class="pre">zip()</span></code>函数，该函数创建一个迭代器，对来自两个或多个迭代器的元素进行配对。你可以使用它来快速有效地解决常见的编程问题，比如创建字典。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">subjects</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;math&#39;</span><span class="p">,</span> <span class="s1">&#39;chemistry&#39;</span><span class="p">,</span> <span class="s1">&#39;biology&#39;</span><span class="p">,</span> <span class="s1">&#39;pyhsics&#39;</span><span class="p">]</span>
<span class="n">grades</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;100&#39;</span><span class="p">,</span> <span class="s1">&#39;83&#39;</span><span class="p">,</span> <span class="s1">&#39;90&#39;</span><span class="p">,</span> <span class="s1">&#39;92&#39;</span><span class="p">]</span>
<span class="n">grades_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">subjects</span><span class="p">,</span> <span class="n">grades</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">grades_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>化繁为简的能力就是消除不必要的东西，保留必要的东西。</p>
</div>
<div class="section" id="id6">
<h4>5. 复杂胜于晦涩<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>复杂（complex ）和晦涩（complicated
）的区别在于，复杂是指组件的系统层级，晦涩是指难度高。</p>
<p>有时候，尽管我们试图让任务变得简单和傻瓜化，结果可能仍然很糟。</p>
<p>在这种情况下，编程优化变得很有必要，我最喜欢的学习方法是完成 coding
challenge websites
上的工作。你可以查看其他人的解决方案，甚至能受到更好算法的启发。</p>
<p><a class="reference external" href="https://www.freecodecamp.org/news/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f/">https://www.freecodecamp.org/news/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f/</a></p>
<p>对于入门，HackerRank
提供了适合新手程序员的各种级别任务，这非常棒。之后，可以去尝试更专业的网站，比如
Coderbyte 和 Topcoder。</p>
</div>
<div class="section" id="id7">
<h4>6. 扁平胜于嵌套<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>嵌套模块在 Python
中并不常见——至少我之前没有见过像<code class="docutils literal notranslate"><span class="pre">module.class.subclass.function</span></code>这样的东西——可读性不好。虽然在另一个子模块中构建子模块可能会减少代码行数，但我们不希望用户被不直观的语法所困扰。</p>
</div>
<div class="section" id="id8">
<h4>7. 间隔胜于紧凑<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>不要在一行中插入太多代码，这会给读者带来压力。建议最大行长度 79
个字符。这样，当使用代码评审工具时，编辑器窗口宽度限制才能很好工作。</p>
<div class="figure align-default" id="id22">
<img alt="图片" src="https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfMzTLUy6PYSgelg6KLczXnGicNUf2LGstS3SGLuVibOgibic4NLRFtUYVLXwNTEhVQLt90icgp7WUObPXw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" />
<p class="caption"><span class="caption-text">图片</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</div>
<p>使用 Python 从 Unsplash 下载图片</p>
</div>
<div class="section" id="id9">
<h4>8. 可读性很重要<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>代码的阅读次数比编写次数多。考虑下缩进，它让代码更容易阅读，比较下面的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">money</span> <span class="o">=</span> <span class="mi">10000000</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;I earn&quot;</span><span class="p">,</span> <span class="n">money</span><span class="p">,</span> <span class="s2">&quot;dollars by writing on medium.&quot;</span><span class="p">)</span>

<span class="n">money</span> <span class="o">=</span> <span class="mi">10</span><span class="n">_000_000</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;I earn {money} dollars by writing on medium.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>在本例中，代码结果相同，但是后一段代码通过使用下划线占位符和 f-string
提供了更好的可读性。在 Python 3.6 发布后，f-string
开始让格式化变得更简单，并且在处理包含更多变量的更长的句子时更强大。</p>
<blockquote>
<div><p>一个作家的风格不应该在他的思想和读者的思想间设置障碍。</p>
</div></blockquote>
</div>
<div class="section" id="id10">
<h4>9. 特例不足以特殊到违背这些原则<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>关键是为一般情况提供一贯支持，尝试将一个繁琐的项目重新组织成一个简单形式。例如，根据其功能，结构化类的代码或将其分类到不同的文件中，即使
Python 并不强迫你这样做。由于 Python
是一种多范式编程语言，解决问题的一个强大方法是创建对象，这就是所谓的面向对象编程。</p>
<p>面向对象编程是一种组织程序结构的编程范式，让属性和行为可以被看作是单独对象。它的优点是直观和易于操作，许多教程都很好地解释了这些概念。</p>
</div>
<div class="section" id="id11">
<h4>10. 实用性胜过纯粹<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>这句格言与前一句相矛盾，它提醒我们保持它们之间的平衡</p>
</div>
<div class="section" id="id12">
<h4>11. 永远不要默默地忽视错误<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>放过错误最终会留下隐式 Bug，并且这些 Bug 更难被发现。Python
提供了健壮的错误处理，与其他语言相比，程序员使用该工具并不难。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Please enter an Integer: &quot;</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Oops! This is not an Integer.&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;You did it! Great job!&#39;</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;ヽ(✿ﾟ▽ﾟ)ノ&#39;</span><span class="p">)</span>

<span class="c1"># 1. 这段代码可能中断。</span>
<span class="c1"># 2. 如果出现值错误就会触发。</span>
<span class="c1"># 3. 处理值错误之外的错误。</span>
<span class="c1"># 4. 如果没有触发错误就执行。</span>
<span class="c1"># 5. 不管是否触发错误都执行。</span>
</pre></div>
</div>
<p>根据 Python
文档：“即使一个语句或表达式在语法上是正确的，在试图执行它时也可能会导致错误。”特别是对于大型项目，我们不希望在耗时的计算后，代码崩溃。这就是异常管理的魅力所在。</p>
</div>
<div class="section" id="id13">
<h4>12. 除非明确需要这样做<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>在某些情况下，小错误不会困扰你。不过，也许你想捕获特定错误。要获得关于特定错误消息的更多细节，我建议阅读官方的内置异常文档并找到你需要的内容。</p>
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html">https://docs.python.org/3/library/exceptions.html</a></p>
</div>
<div class="section" id="id14">
<h4>13. 面对模棱两可，拒绝猜测<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>重要的是要不断学习，享受挑战，容忍歧义。我们都不知道最终会怎样。——玛蒂娜·霍纳</p>
</div></blockquote>
<p>这句话优雅而抒情，但在编程中不是一个好的隐喻。歧义可能是指不清楚的语法、复杂的程序结构或触发错误消息的错误。例如，第一次使用<code class="docutils literal notranslate"><span class="pre">numpy</span></code>模块时的一个简单错误：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;smaller than 3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div><p>ValueError: 具有多个元素的数组的真值不明确，请使用 a.any() 或 a.all()</p>
</div></blockquote>
<p>如果执行上面代码，你将在输出中发现一个由 5 个布尔值组成的数组，表明值在
3
以下。因此，<code class="docutils literal notranslate"><span class="pre">if</span></code>语句不可能确定状态。消息中显示的内置函数<code class="docutils literal notranslate"><span class="pre">.all</span></code>()
和<code class="docutils literal notranslate"><span class="pre">.any()</span></code>用于代替 And/Or。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>
</pre></div>
</div>
<p>输出表明，<code class="docutils literal notranslate"><span class="pre">.all()</span></code>仅在所有项都为<code class="docutils literal notranslate"><span class="pre">True</span></code>时才返回<code class="docutils literal notranslate"><span class="pre">True</span></code>，而.<code class="docutils literal notranslate"><span class="pre">any()</span></code>在有一项为<code class="docutils literal notranslate"><span class="pre">True</span></code>时就返回<code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</div>
<div class="section" id="id15">
<h4>14. 解决问题最直接的方法应该有一种，最好只有一种<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>想想为什么 Python 被描述为一种易于学习的编程语言。Python
具有非凡的内置函数 /
库和高度的可扩展性，它鼓励程序员优雅地编写代码。尽管有更多的解决方案可以提供灵活性，但对于同一个问题，它们可能会花费更多时间。</p>
<div class="figure align-default" id="id23">
<img alt="图片" src="https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfMzTLUy6PYSgelg6KLczXnGIo9gTfssaxcxk8D8PG5ibKNkDNxeUUvuy8vtUGwicFTYUWyENr5siaYiaA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" />
<p class="caption"><span class="caption-text">图片</span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></p>
</div>
<p>输入 import antigravity 并执行</p>
</div>
<div class="section" id="id16">
<h4>15. 当然这是没法一蹴而就的，除非你是荷兰人<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>Python 之父 Guido van Rossum
是一位荷兰程序员，他让这句格言变得无可争议。你不会声称自己比他更了解
Python……至少我不会。</p>
<div class="figure align-default" id="id24">
<img alt="图片" src="https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfMzTLUy6PYSgelg6KLczXnGibY7lauWJvjo7zaFtARAiaPjq0sQzRkCibrBrRboNjkCTMiap155Tf55KQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" />
<p class="caption"><span class="caption-text">图片</span><a class="headerlink" href="#id24" title="Permalink to this image">¶</a></p>
</div>
<p>照片来自 GitHub</p>
</div>
<div class="section" id="id17">
<h4>16. 做也许好过不做<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>你可以拖延，但时间不会，失去的时间一去不复返。——本杰明·富兰克林</p>
</div></blockquote>
<p>对于那些像我一样患有拖延症，正在寻求改变的人，看看这个，和恐慌怪兽合作。</p>
<p><a class="reference external" href="https://embed.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator">https://embed.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator</a></p>
<p>另一方面，这个格言的另一个方面是阻止你过度计划，这并不比看 Netflix
更有效率。</p>
<p>拖延和过度计划的共同特征就是“什么都做不了。”</p>
</div>
<div class="section" id="id18">
<h4>17. 不想就做还不如不做<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>“做也许好过不做”并不意味着计划没用。把你的想法写下来，设定一个要征服的目标，比不想就做要好。</p>
<p>例如，我通常在每个星期天花一个小时来制定我的周计划，并在睡觉前更新我明天的计划，看看有什么需要推迟的事情。</p>
</div>
<div class="section" id="id19">
<h4>18. 如果解决方案难以解释清楚，那一定很糟糕<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>回想一下“复杂胜于晦涩”的理念。通常，晦涩的代码意味着弱设计，特别是在像
Python 这样的高级编程语言中。</p>
<p>然而，在某些情况下，其领域知识的复杂性可能会让实现难以解释，而如何优化让其明晰易懂至关重要。这里有一个规划项目指南，可以给你提供帮助。</p>
<p><a class="reference external" href="https://docs.python-guide.org/writing/structure/">https://docs.python-guide.org/writing/structure/</a></p>
</div>
<div class="section" id="id20">
<h4>19. 如果实现容易描述，那可能是个好方案<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>使设计（甚至人们的生活）更容易，即使背景知识可能很深刻，这是编程的专业知识，我认为也是编程中最困难的部分。</p>
<p>利用 Python 的简单性和可读性来实现一些疯狂的想法。</p>
</div>
<div class="section" id="id21">
<h4>20. 命名空间是一种绝妙的理念，多加利用！<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>最后但同样重要的是，命名空间是一组符号，用于组织各种对象，以便这些对象可以通过惟一的名称引用。在
Python 中，命名空间是由以下元素组成的系统：</p>
<ol class="arabic simple">
<li><p>内置命名空间：可以在不创建自定义函数或导入模块（如<code class="docutils literal notranslate"><span class="pre">print()</span></code>函数）的情况下调用。</p></li>
<li><p>全局命名空间：当用户创建一个类或函数时，将创建一个全局命名空间。</p></li>
<li><p>局部命名空间：局部作用域中的命名空间。</p></li>
</ol>
<div class="figure align-default" id="id25">
<img alt="图片" src="https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfMzTLUy6PYSgelg6KLczXnGvVCX3ibtpTl3zVpqx2Ra5JCxjwwp8cibBicP70SibReicNbWWetSeg7GlIA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" />
<p class="caption"><span class="caption-text">图片</span><a class="headerlink" href="#id25" title="Permalink to this image">¶</a></p>
</div>
<p>命名空间关系图</p>
<p>命名空间系统可以防止 Python 模块名称之间产生冲突。</p>
<p>延展阅读：</p>
<p><a class="reference external" href="https://medium.com/better-programming/how-to-make-python-programming-more-elegant-and-decent-4b5962695aa9">https://medium.com/better-programming/how-to-make-python-programming-more-elegant-and-decent-4b5962695aa9</a></p>
</div>
</div>
<span id="document-c11/c11_06"></span><div class="section" id="eafp-lbyl">
<h3>11.6 【代码美化】择优选择 EAFP 和 LBYL 代码风格<a class="headerlink" href="#eafp-lbyl" title="Permalink to this headline">¶</a></h3>
<div class="section" id="eafp">
<h4>1. EAFP 风格<a class="headerlink" href="#eafp" title="Permalink to this headline">¶</a></h4>
<p>Python 有一套自己的哲学，其中 EAFP 是其中比较有名的。它的全称是</p>
<blockquote>
<div><p>Easier to Ask for Forgiveness than Permission</p>
</div></blockquote>
<p>强行翻译一下，就是 <strong>寻求原谅比获得授权更容易</strong>。</p>
<p>对于第一次接触这个 EAFP 名词的同学，可能不好理解这句话的意思。</p>
<p>没有关系，咱先看一下 EAFP 风格的代码是什么样的，你就能立马 get 了。</p>
<p>下面这段代码，我在 try 里使用 <code class="docutils literal notranslate"><span class="pre">[key]</span></code> 的方法获取字典一个 value
值，但是由于 profile 并没有 age 的键。所以会抛出异常。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">}</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">])</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Key is not exist&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>像这种，先相信代码本身没有问题，任其执行，有问题了再通过捕获进行处理的代码风格，就叫做
EAFP 风格。</p>
<p>我个人把这种写法，称之为 <strong>面向崩溃编程</strong>。</p>
</div>
<div class="section" id="lbyl">
<h4>2. LBYL 风格<a class="headerlink" href="#lbyl" title="Permalink to this headline">¶</a></h4>
<p>LBYL 的全称是</p>
<blockquote>
<div><p>Look Before You Leap</p>
</div></blockquote>
<p>翻译一下，就是
<code class="docutils literal notranslate"><span class="pre">你跳之前先看看</span></code>，这是一种比较保守的写法。这种写法可能会有让你写很多的
if 判断语句来规避可能出现错误的各种场景。</p>
<p>还是以上面的代码为例，使用 LBYL 风格来写的话，是这样的</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;王炳明&quot;</span><span class="p">}</span>
<span class="k">if</span> <span class="s2">&quot;age&quot;</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Key is not exist&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h4>3. 选择哪种风格？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>用一个生动的例子来描述他们的区别。</p>
<p>有一对小伙伴一起约去某名山游玩，由于这座山比较险峻，有各种各校的悬崖。</p>
<p>伙伴A，是一个比较大胆开放的人，他自己穿上了降落伞，所以在游玩的时候，无所顾忌，都不看路，一旦不小心跌落悬崖了也有降落伞保命。
– <code class="docutils literal notranslate"><span class="pre">这是</span> <span class="pre">EAFP</span> <span class="pre">风格</span></code></p>
<p>而伙伴B，是一个比较保守的人，他没有穿降落伞，所以每走一走都要看一看，前面是不是悬崖。–
<code class="docutils literal notranslate"><span class="pre">这是</span> <span class="pre">LBLY</span> <span class="pre">风格</span></code></p>
<p>EAFP虽然是 Python
比较推荐的一种编码风格，但更多情况下，这两种风格会同时存在于你的代码中代码风格的目的是增强代码的可读性和健壮性，在有些场景下
EAFP 风格更加易读，在有些场景下 LBLY
风格更加易读，因此不必纠结使用哪种风格，具体情况应该具体分析。</p>
</div>
</div>
<span id="document-c11/c11_07"></span><div class="section" id="flake8">
<h3>11.7 【代码美化】使用 flake8 保证代码风格<a class="headerlink" href="#flake8" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pep8</span></code> 是Python
语言的一个代码编写规范。如若你是新手，目前只想快速掌握基础，而不想过多去注重代码的的编写风格（虽然这很重要），那你可以尝试一下这个工具
- <code class="docutils literal notranslate"><span class="pre">autopep8</span></code></p>
<p>首先在全局环境中（不要在虚拟环境中安装），安装一下这个工具。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo pip install autopep8
</pre></div>
</div>
<p>然后在 PyCharm 导入这个工具，具体设置如下图</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Name: AutoPep8
Description: autopep8 your code
Program: autopep8
Arguments: --in-place --aggressive --aggressive $FilePath$
Working directory: $ProjectFileDir$
Output filters: $FILE_PATH$\:$LINE$\:$COLUMN$\:.*
</pre></div>
</div>
<p><img alt="image0" src="http://image.iswbm.com/20190323164120.png" /></p>
<p>我随意写了一段不符合 pep8 规范的代码。</p>
<p><img alt="image1" src="http://image.iswbm.com/20190323211635.png" /></p>
<p>点击右键，选择 <code class="docutils literal notranslate"><span class="pre">External</span> <span class="pre">Tools</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">AutoPep8</span></code></p>
<p><img alt="image2" src="http://image.iswbm.com/20190323211301.png" /></p>
<p>看一下效果，还是挺明显的。</p>
<p><img alt="image3" src="http://image.iswbm.com/20190324111603.png" /></p>
<p>你可能会说，Pycharm 本身就自带这个功能了呀，快捷键
<code class="docutils literal notranslate"><span class="pre">Command</span></code>+<code class="docutils literal notranslate"><span class="pre">Option</span></code>+<code class="docutils literal notranslate"><span class="pre">L</span></code>
，就可以实现一键pep8了。你可以对比一下，Pycharm 自带的代码 pep8 化功能
并没有像这个<code class="docutils literal notranslate"><span class="pre">autopep8</span></code> 来得彻底。 我相信你最终的选择肯定是后者。</p>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p12"></span><div class="section" id="id1">
<h2>第十二章：虚拟环境<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c12/c12_01"></span><div class="section" id="id1">
<h3>12.1 【虚拟环境】为什么要有虚拟环境？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>虚拟环境的意义，就如同虚拟机
一样，它可以实现不同环境中Python依赖包相互独立，互不干扰。</p>
<p>举个例子吧。</p>
<p>假设我们的电脑里有两个项目，他们都用到同一个第三方包，本来一切都顺利。但是由于某种原因，项目B由于某些原因要使用这个第三方包的一些新特性（新版本才有），而如果就这样贸然升级了，对项目A的影响我们无法评估，这个时候我们就特别需要有一种解决方案可以让项目A和B，处于两个不同的Python环境中。互不影响。</p>
<p>为了方便大家对虚拟环境有个认识，我列举了下其优点：</p>
<ul class="simple">
<li><p>使不同应用开发环境独立</p></li>
<li><p>环境升级不影响其他应用，也不会影响全局的python环境</p></li>
<li><p>可以防止系统中出现包管理混乱和版本的冲突</p></li>
</ul>
<p>市场上管理 Python 版本和环境的工具有很多，这里列举几个：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>：非常简单的交互式 python 版本管理工具。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pyenv</span></code>：简单的 Python 版本管理工具。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Vex</span></code>：可以在虚拟环境中执行命令。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtualenv</span></code>：创建独立 Python 环境的工具。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtualenvwrapper</span></code>：virtualenv 的一组扩展。</p></li>
</ul>
<p>工具很多，但个人认为最好用的，当属
<code class="docutils literal notranslate"><span class="pre">virtualenvwrapper</span></code>，推荐大家也使用。</p>
</div>
<span id="document-c12/c12_02"></span><div class="section" id="virtualenv">
<h3>12.2 【虚拟环境】方案一：使用 virtualenv<a class="headerlink" href="#virtualenv" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 安装virtualenv<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>由于 virtualenvwrapper 是 virtualenv 的一组扩展，所以如果要使用
virtualenvwrapper，就必须先安装 virtualenv。</p>
<p><strong>基本使用</strong></p>
<p>由于virtualenv创建虚拟环境是在当前环境下创建的。所以我们要准备一个专门存放虚拟环境的目录。（以下操作在Linux在完成，windows相对简单，请自行完成，有不明白的请微信与我联系。）</p>
<p><strong>创建</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 准备目录并进入</span>
$ mkdir -p /home/wangbm/Envs
$ <span class="nb">cd</span> !$

<span class="c1"># 创建虚拟环境（按默认的Python版本）</span>
<span class="c1"># 执行完，当前目录下会有一个my_env01的目录</span>
$ virtualenv my_env01

<span class="c1"># 你也可以指定版本</span>
$ virtualenv -p /usr/bin/python2.7 my_env01
$ virtualenv -p /usr/bin/python3.6 my_env02

<span class="c1"># 你肯定觉得每次都要指定版本，相当麻烦吧？</span>
<span class="c1"># 在Linux下，你可以把这个选项写进入环境变量中</span>
$ <span class="nb">echo</span> <span class="s2">&quot;export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7&quot;</span> &gt;&gt; ~/.bashrc
</pre></div>
</div>
<p><strong>进入/退出</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> /home/wangbm/Envs

<span class="c1"># 进入</span>
$ <span class="nb">source</span> my_env01/bin/activate

<span class="c1"># 退出</span>
$ deactivate
</pre></div>
</div>
<p><strong>删除</strong>
删除虚拟环境，只需删除对应的文件夹就行了。并不会影响全局的Python和其他环境。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> /home/wangbm/Envs
$ rm -rf my_env01
</pre></div>
</div>
<blockquote>
<div><p>注意：
创建的虚拟环境，不会包含原生全局环境的第三方包，其会保证新建虚拟环境的干净。</p>
</div></blockquote>
<p>如果你需要和全局环境使用相同的第三方包。可以使用如下方法：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 导出依赖包</span>
$ pip freeze &gt; requirements.txt

<span class="c1"># 安装依赖包</span>
$ pip install -r requirements.txt
</pre></div>
</div>
</div>
<div class="section" id="virtualenvwrapper">
<h4>2. 使用 virtualenvwrapper<a class="headerlink" href="#virtualenvwrapper" title="Permalink to this headline">¶</a></h4>
<p>virtualenv 虽然已经相当好用了，可是功能还是不够完善。</p>
<p>你可能也发现了，要进入虚拟环境，必须得牢记之前设置的虚拟环境目录，如果你每次按规矩来，都将环境安装在固定目录下也没啥事。但是很多情况下，人是会懒惰的，到时可能会有很多个虚拟环境散落在系统各处，你将有可能忘记它们的名字或者位置。</p>
<p>还有一点，virtualenv 切换环境需要两步，退出 -&gt; 进入。不够简便。</p>
<p>为了解决这两个问题，virtualenvwrapper就诞生了。</p>
<p><strong>安装</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 安装 - Linux</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">virtualenvwrapper</span>

<span class="c1"># 安装 - Windows</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">virtualenvwrapper</span><span class="o">-</span><span class="n">win</span>
</pre></div>
</div>
<p><strong>配置</strong> 先find一下<code class="docutils literal notranslate"><span class="pre">virtualenvwrapper.sh</span></code>文件的位置</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="n">find</span> <span class="p">/</span> <span class="n">-name</span> <span class="n">virtualenvwrapper</span><span class="p">.</span><span class="n">sh</span>
<span class="c"># /usr/bin/virtualenvwrapper.sh</span>
</pre></div>
</div>
<p>若是 windows 则使用everything 查找 virtualenvwrapper.bat 脚本</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">D</span><span class="p">:</span>\<span class="n">Program</span> <span class="n">Files</span> <span class="p">(</span><span class="n">x86</span><span class="p">)</span>\<span class="n">Python38</span><span class="o">-</span><span class="mi">32</span>\<span class="n">Scripts</span>\<span class="n">virtualenvwrapper</span><span class="o">.</span><span class="n">bat</span>
</pre></div>
</div>
<p>在~/.bashrc 文件新增配置</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$HOME/workspace
export VIRTUALENVWRAPPER_SCRIPT=/usr/bin/virtualenvwrapper.sh
source /usr/bin/virtualenvwrapper.sh
</pre></div>
</div>
<p>若是 windows 则新增环境变量：<code class="docutils literal notranslate"><span class="pre">WORKON_HOME</span></code></p>
<p><img alt="image0" src="http://image.iswbm.com/20200209161935.png" /></p>
<p><strong>基本语法</strong>：</p>
<p>mkvirtualenv [-a project_path] [-i package] [-r requirements_file]
[virtualenv options] ENVNAME</p>
<p><strong>常用方法</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建</span>
$ mkvirtualenv my_env01

<span class="c1"># 进入</span>
$ workon my_env01

<span class="c1"># 退出</span>
$ deactivate

<span class="c1"># 列出所有的虚拟环境，两种方法</span>
$ workon
$ lsvirtualenv

<span class="c1"># 在虚拟环境内直接切换到其他环境</span>
$ workon my_env02

<span class="c1"># 删除虚拟环境</span>
$ rmvirtualenv my_env01
</pre></div>
</div>
<p><strong>其他命令</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 列出帮助文档</span>
$ virtualenvwrapper

<span class="c1"># 拷贝虚拟环境</span>
$ cpvirtualenv ENVNAME <span class="o">[</span>TARGETENVNAME<span class="o">]</span>

<span class="c1"># 在所有的虚拟环境上执行命令</span>
$ allvirtualenv pip install -U pip

<span class="c1"># 删除当前环境的所有第三方包</span>
$ wipeenv

<span class="c1"># 进入到当前虚拟环境的目录</span>
$ cdsitepackages

<span class="c1"># 进入到当前虚拟环境的site-packages目录</span>
$ cdvirtualenv

<span class="c1"># 显示 site-packages 目录中的内容</span>
$ lssitepackages
</pre></div>
</div>
<p>更多内容，可查看 官方文档
<a class="reference external" href="https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html">https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html</a></p>
</div>
<div class="section" id="id2">
<h4>3. 实战演示<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>以上内容，是一份使用指南。接下来，一起来看看，如何在项目中使用虚拟环境。</p>
<p>如何使用在我们的开发中使用我们的虚拟环境呢</p>
<p>通常我们使用的场景有如下几种</p>
<ul class="simple">
<li><p>交互式中</p></li>
<li><p>PyCharm中</p></li>
<li><p>工程中</p></li>
</ul>
<p>接下来，我将一一展示。</p>
<div class="section" id="id3">
<h5>3.1 交互式中<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>先对比下，全局环境和虚拟环境的区别，全局环境中有requests包，而虚拟环境中并未安装。
当我们敲入
<code class="docutils literal notranslate"><span class="pre">workon</span> <span class="pre">my_env01</span></code>，前面有<code class="docutils literal notranslate"><span class="pre">my_env01</span></code>的标识，说明我们已经处在虚拟环境中。后面所有的操作，都将在虚拟环境下执行。
<img alt="image1" src="https://i.loli.net/2018/06/11/5b1e7d36ce8ad.png" /></p>
</div>
<div class="section" id="id4">
<h5>3.2 工程项目中<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>我们的工程项目，都有一个入口文件，仔细观察，其首行可以指定Python解释器。</p>
<p>倘若我们要在虚拟环境中运行这个项目，只要更改这个文件头部即可。</p>
<p>现在我还是以，<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">requests</span></code>
为例，来说明，是否是在虚拟环境下运行的，如果是，则和上面一样，会报错。</p>
<p>文件内容：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/root/.virtualenvs/my_env01/bin/python</span>

<span class="kn">import</span> <span class="nn">requests</span>
<span class="k">print</span> <span class="s2">&quot;ok&quot;</span>
</pre></div>
</div>
<p>运行前，注意添加执行权限。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ chmod +x ming.py
</pre></div>
</div>
<p>好了。来执行一下</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ./ming.py
</pre></div>
</div>
<p>发现和预期一样，真的报错了。说明我们指定的虚拟环境有效果。 <img alt="image2" src="https://i.loli.net/2018/06/11/5b1e7f140be6a.png" /></p>
</div>
<div class="section" id="pycharm">
<h5>3.3 PyCharm中<a class="headerlink" href="#pycharm" title="Permalink to this headline">¶</a></h5>
<p>点击 File - Settings - Project - Interpreter <img alt="image3" src="https://i.loli.net/2018/06/11/5b1e805c996c8.png" />
点击小齿轮。如图点击添加，按提示添加一个虚拟环境。然后点 OK
就可以使用这个虚拟环境，之后的项目都会在这个虚拟环境下运行。 <img alt="image4" src="https://i.loli.net/2018/06/11/5b1e812db603f.png" /></p>
</div>
</div>
</div>
<span id="document-c12/c12_03"></span><div class="section" id="pipenv">
<h3>12.3 【虚拟环境】方案二：使用 pipenv<a class="headerlink" href="#pipenv" title="Permalink to this headline">¶</a></h3>
<p>以前一直使用pip+virtualenv+virtualwrapper管理模块和环境，
但是virtualwrapper在windows上使用不太方便，而且包和环境分开管理确实经常不记得哪个是哪个了。</p>
<p>为什么 会推荐 pipenv 呢？</p>
<ul class="simple">
<li><p>它是 <code class="docutils literal notranslate"><span class="pre">virtualenv</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 的合体，可以合起来使用；</p></li>
<li><p>使用<code class="docutils literal notranslate"><span class="pre">Pipfile</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Pipfile.lock</span></code>替代<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code></p></li>
<li><p>可以使用 <code class="docutils literal notranslate"><span class="pre">pipenv</span> <span class="pre">graph</span></code>很方便的看出包的依赖关系。</p></li>
<li><p>通过加载<code class="docutils literal notranslate"><span class="pre">.env</span></code>文件简化开发工作流程</p></li>
</ul>
<div class="section" id="id1">
<h4>1. 安装pipenv<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>如果你的电脑上没有安装 pipenv，可以使用如下方法安装</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># mac</span>
$ brew install pipenv

<span class="c1"># windows</span>
$ pip install <span class="o">[</span>--user<span class="o">]</span> pipenv
</pre></div>
</div>
<p>如果你的电脑是 windows 的。</p>
<p><img alt="image0" src="http://image.iswbm.com/Fk6WZ2xbqg2DM3AvnYCpsiKQ4xOn" /></p>
<p>需要将如标示路径，加入到 环境变量 PATH 中。</p>
<p><img alt="image1" src="http://image.iswbm.com/FjuJ8yZsgjkzVuBRZHxK1ZnnzaEX" /></p>
<p>然后需要重启一下，CMD 终端才能够刷新环境变量。</p>
</div>
<div class="section" id="id2">
<h4>2. 创建虚拟环境<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>DjangoWebBlog 是我们的项目目录，进入这个目录下创建虚拟环境</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mkdir DjangoWebBlog <span class="o">&amp;&amp;</span> <span class="nb">cd</span> DjangoWebBlog

<span class="c1"># 在当前目录下创建一个虚拟环境（默认的Python版本）</span>
$ pipenv install
</pre></div>
</div>
<p>你也可以指定版本创建</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipenv --two      <span class="c1"># 相当于 pipenv --python /usr/bin/python2</span>
$ pipenv --three    <span class="c1"># 相当于 pipenv --python /usr/bin/python3</span>

$ pipenv --python <span class="m">3</span>.7 <span class="c1"># 也可以指定具体的版本</span>
pipenv install --python <span class="m">2</span>
</pre></div>
</div>
<p>这边以安装 python2 版本的虚拟环境为例说明。</p>
<p><img alt="image2" src="http://image.iswbm.com/20190612211330.png" /></p>
<p>如果你原项目使用的是 requirements.txt 这个管理包的方式，这时候执行
<code class="docutils literal notranslate"><span class="pre">pipenv</span> <span class="pre">--tow</span></code> 创建一个虚拟环境后，会找到 requirements.txt
，并根据这里面的依赖包生成 Pipfile文件。</p>
<p><img alt="image3" src="http://image.iswbm.com/20190612213015.png" /></p>
</div>
<div class="section" id="id3">
<h4>3. 查询虚拟环境<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 返回项目的路径</span>
$ pipenv --where

<span class="c1"># 返回虚拟环境路径</span>
$ pipenv --venv

<span class="c1"># 返回该虚拟环境的解释器</span>
$ pipenv --py
</pre></div>
</div>
<p>演示如下：</p>
<p><img alt="image4" src="http://image.iswbm.com/20190612213950.png" /></p>
</div>
<div class="section" id="id4">
<h4>4. 操作虚拟环境<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 进入这个虚拟环境</span>
$ pipenv shell

<span class="c1"># 退出这个虚拟环境</span>
$ <span class="nb">exit</span>
$ deactivate

<span class="c1"># 移除当前目录的虚拟环境</span>
$ pipenv --rm
</pre></div>
</div>
<p>执行 <code class="docutils literal notranslate"><span class="pre">pipenv</span> <span class="pre">shell</span></code>
就可以进入这个虚拟环境，在头部会有虚拟环境的标识名称。有这个标识，说明已经进入虚拟环境。</p>
<p><img alt="image5" src="http://image.iswbm.com/20190612211925.png" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 在当前虚拟环境中运行
$ pipenv run python  # 进入交互式,跟直接执行 python 一样
$ pipenv run python 文件名 # 运行文件
$ pipenv run pip ...  # 运行pip
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>5. 虚拟环境包管理<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 安装一个本地包（setup.py）到虚拟环境（Pipfile）</span>
$ pipenv install -e .

<span class="c1"># 安装、卸载模块</span>
$ pipenv install requests
$ pipenv uninstall requests
$ pipenv uninstall --all   <span class="c1"># 卸载全部包</span>
$ pipenv install -r path/to/requirements.txt


<span class="c1"># 安装所有依赖</span>
$ pipenv install --dev

<span class="c1"># 更新包</span>
$ pipenv update <span class="c1"># 更新所有包</span>
$ pipenv update --outdated <span class="c1"># 打印所有要更新的包</span>
$ pipenv update &lt;包名&gt; <span class="c1"># 更新指定的包</span>

<span class="c1"># 将Pipfile和Pipfile.lock文件里面的包导出为requirements.txt文件</span>
$ pipenv run pip freeze  <span class="c1"># 相当于pipenv run pip freeze &gt;requirements.txt</span>

$ pipenv lock -r &gt; requirements.txt
$ pipenv lock -r --dev <span class="c1"># 若只想导出开发用的包</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>6. 其他命令<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建一个包含预发布的锁文件:</span>
$ pipenv lock --pre

<span class="c1"># 打印所有包的依赖关系图</span>
$ pipenv graph

<span class="c1"># 检查安全漏洞</span>
$ pipenv check
</pre></div>
</div>
<p>打印该虚拟环境下所有包的依赖关系图</p>
<p><img alt="image6" src="http://image.iswbm.com/20190614000336.png" /></p>
<p>有的python第三方包旧版本会有安全漏洞，使用 pipenv check
可以检查安全漏洞。</p>
<p><img alt="image7" src="http://image.iswbm.com/20190612215924.png" /></p>
</div>
</div>
<span id="document-c12/c12_04"></span><div class="section" id="pipx">
<h3>12.4 【虚拟环境】方案三：使用 pipx<a class="headerlink" href="#pipx" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 什么是 pipx<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>pipx 是一款用于帮助你安装和运行那些用 python 编写的终端程序，它类似于
macOS 上的 brew，Ubuntu 上的 apt，CentOS 上的 yum。</p>
<p>pipx 依赖 pip 和 venv，它只能在 python 3.6+ 的 Python 版本中才能使用。</p>
<p>默认情况下，pipx 和 pip 一样会从 pypi 上安装包，同时 pipx 也能像 pip
一样从本地、git仓库、wheel 文件中安装包。</p>
<p>为了避免你在安装 python app时，由于多版本而导致冲突，通常我们会使用 venv
或者 virtualenv 新建一个虚拟环境，然后将 app 安装到虚拟环境中。</p>
<p>后续你对这个 app 的管理操作，都得先进入这个虚拟环境。</p>
<p>发现没有？好像有点麻烦。</p>
<p>pipx 的存在使这个流程变得更加舒畅，使用 pipx
你可以无需关注虚拟环境的存在，并在你的机器上安装多个版本的 python app。</p>
</div>
<div class="section" id="id2">
<h4>2. 安装使用<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>安装 pipx</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pip install --user pipx
$ python3 -m userpath append ~/.local/bin
Success!
</pre></div>
</div>
<p>使用 Pipx 需要注意两个路径</p>
<ol class="arabic simple">
<li><p>二进制文件的保存位置：默认是 <code class="docutils literal notranslate"><span class="pre">~/.local/bin</span></code>，可使用环境变量
<code class="docutils literal notranslate"><span class="pre">PIPX_BIN_DIR</span></code>
进行更改，或者执行如下命令(<code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">userpath</span> <span class="pre">append</span> <span class="pre">${you_path}</span></code>)</p></li>
<li><p>虚拟环境的保存位置：默认是 <code class="docutils literal notranslate"><span class="pre">~/.local/pipx</span></code>，可使用环境变量
<code class="docutils literal notranslate"><span class="pre">PIPX_HOME</span></code> 进行更改</p></li>
</ol>
<p>在我安装好 pipx ，准备使用的时候，发现全局找不到 pipx 这个命令。</p>
<p><img alt="image0" src="http://image.iswbm.com/image-20201130124107950.png" /></p>
<p>按照如上图所示，难道使用全路径执行命令？</p>
<p><strong>不，怎么都觉得不太对劲。。</strong></p>
<p>想要解决这个问题，其实很简单，有两种方法（两种都可以，我演示使用的第一种方法）：</p>
<ol class="arabic simple">
<li><p>添加个软链接指向刚刚那个全路径就好啦</p></li>
<li><p>将这个路径添加到 PATH 中 <code class="docutils literal notranslate"><span class="pre">/Users/MING/Library/Python/3.9/bin/</span></code></p></li>
</ol>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ln -s /Users/MING//Library/Python/3.9/bin/pipx /usr/local/bin/pipx
</pre></div>
</div>
<p>软链接建好后，就可以直接使用 <code class="docutils literal notranslate"><span class="pre">pipx</span></code> 的命令啦。</p>
<p><img alt="image1" src="http://image.iswbm.com/image-20201130124554404.png" /></p>
<p>刚刚我使用 pipx 安装了 youtube-dl 后，其实并没有将这个 youtube-dl
安装到系统全局的 Python 环境中。</p>
<p>还记得最开始，我强调过两个非常重要的路径吗？</p>
<p>现在来看一下，这个路径下面都有哪些东西？</p>
<p><img alt="image2" src="http://image.iswbm.com/image-20201130125257203.png" /></p>
<p>从截图上可以看出</p>
<ul class="simple">
<li><p>pipx 在 <code class="docutils literal notranslate"><span class="pre">~/.local/pipx/venvs</span></code> 目录下新建了个名叫 <code class="docutils literal notranslate"><span class="pre">youtube-dl</span></code>
的虚拟机环境</p></li>
<li><p>并将 <code class="docutils literal notranslate"><span class="pre">youtube-dl</span></code> 安装到这个虚拟机环境中</p></li>
<li><p>然后在 <code class="docutils literal notranslate"><span class="pre">~/.local/bin</span></code> 的目录下新建一个软链接，指向这个虚拟环境中</p></li>
<li><p>这样 <code class="docutils literal notranslate"><span class="pre">youtube-dl</span></code> 就变成全局的工具啦。</p></li>
</ul>
<p><img alt="image3" src="http://image.iswbm.com/image-20201130131138939.png" /></p>
<p>为了避免你新安装的 youtube-dl 与全局的冲突，你也可以指定 pipx
的命令来运行 youtube-dl</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx run youtube-dl --no-check-certificate https://www.bilibili.com/video/BV1jK4y1h7uA
</pre></div>
</div>
<p>运行效果如下：</p>
<p><img alt="image4" src="http://image.iswbm.com/image-20201130210539907.png" /></p>
<p>pip run 也可以直接执行在线的 python 脚本</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.py
pipx is working!
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 查看包<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>查看已安装过的包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx list
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>4. 安装包<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>下载最新版本的 python 包，并安装到新建的虚拟环境中</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx install &lt;PACKAGE&gt;
</pre></div>
</div>
</div>
<div class="section" id="app">
<h4>4. 运行APP<a class="headerlink" href="#app" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">pipx</span> <span class="pre">run</span></code> 后面可接一个包的 url
链接，会将这个包下载下来并运行，也可以接已安装过的应用名来直接运行它</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx run &lt;PACKAGE_URL/APP&gt;
</pre></div>
</div>
<p>如果一个 app 有多个版本，那么可以通过 <code class="docutils literal notranslate"><span class="pre">spec</span></code> 指定版本号</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx run --spec <span class="nv">PACKAGE</span><span class="o">==</span><span class="m">1</span>.0.0 app
</pre></div>
</div>
<p>更神奇的是，pipx 支持指定 git 代码仓库直接运行</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx run --spec git+https://github.com/psf/black.git black

<span class="c1"># 指定分支</span>
$ pipx run --spec git+https://github.com/psf/black.git@branch black

<span class="c1"># 指定某个git hash</span>
$ pipx run --spec git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 black

<span class="c1"># 指定某个发行版本</span>
$ pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black <span class="c1"># install a release</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>5. 升级包<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>升级某个包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx upgrade &lt;pkg&gt;
</pre></div>
</div>
<p>升级全部包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx upgrade-all
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>6. 卸载包<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>卸载某个包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx uninstall &lt;pkg&gt;
</pre></div>
</div>
<p>卸载全部包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx uninstall-all
</pre></div>
</div>
<p>重装全部包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx reinstall-all
</pre></div>
</div>
</div>
<div class="section" id="pip">
<h4>7. 使用 pip<a class="headerlink" href="#pip" title="Permalink to this headline">¶</a></h4>
<p>每执行一次 pipx install
就会新建一个虚拟环境，那我们有没有办法管理这些虚拟机环境呢？</p>
<p>比如我想看这个虚拟环境里安装了哪些包？</p>
<p>使用如下命令就可以像使用 pip 一样，来管理 pipx 的虚拟环境</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pipx runpip &lt;env_name&gt; &lt;args&gt;
</pre></div>
</div>
<p>效果如下</p>
<p><img alt="image5" src="http://image.iswbm.com/image-20201130215320069.png" /></p>
</div>
<div class="section" id="id7">
<h4>8. 其他<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>执行 <code class="docutils literal notranslate"><span class="pre">pipx</span> <span class="pre">completions</span></code> 可以启用 pipx 的补全说明。</p>
<p>对于不同的终端开启方式不一样，我使用的是 zsh，方法是</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ autoload -U bashcompinit
$ bashcompinit
$ <span class="nb">eval</span> <span class="s2">&quot;</span><span class="k">$(</span>register-python-argcomplete pipx<span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>我安装好后，可以使用 tab 键进行命令补全。</p>
<p><img alt="image6" src="http://image.iswbm.com/image-20201130220233001.png" /></p>
<p>执行 <code class="docutils literal notranslate"><span class="pre">pipx</span> <span class="pre">ensurepath</span></code> 可以确保 <code class="docutils literal notranslate"><span class="pre">~/.local/bin</span></code>
这个重要的目录，已经放入到 <code class="docutils literal notranslate"><span class="pre">$PATH</span></code> 的变量中。</p>
<p><img alt="image7" src="http://image.iswbm.com/image-20201130215826513.png" /></p>
</div>
<div class="section" id="pipx-vs-pip">
<h4>9. pipx vs pip<a class="headerlink" href="#pipx-vs-pip" title="Permalink to this headline">¶</a></h4>
<p>pipx 只是解决 pip
的一个痛点，因此他的适用场景比较单一，它只适用于安装和运行那些有提供命令行入口的app。</p>
<ul class="simple">
<li><p>pip 适用于大多数的 Python 版本，而 pipx 需要 Python 3.6+ 才可以使用</p></li>
<li><p>pipx 依赖 pip 和 venv，可以使用 pip 安装pipx ，反过来则不行。</p></li>
<li><p>pip 和 pipx 默认都是从 pypi 上安装包</p></li>
<li><p>pipx 在安装和管理 cli 应用程序时，比 pip
更灵活，它可以在允许在隔离环境中安装和运行 Python 应用</p></li>
</ul>
</div>
<div class="section" id="id8">
<h4>10. 参考文章<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/pipxproject/pipx">https://github.com/pipxproject/pipx</a></p></li>
<li><p><a class="reference external" href="https://pipxproject.github.io/pipx/comparisons/">https://pipxproject.github.io/pipx/comparisons/</a></p></li>
</ul>
</div>
</div>
<span id="document-c12/c12_05"></span><div class="section" id="poetry">
<h3>12.5 【虚拟环境】方案四：使用 poetry<a class="headerlink" href="#poetry" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 安装 poetry<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>poetry提供多种安装方式，个人推荐从以下2种方式中选择：</p>
<p>方式一：（推荐）使用在线脚本进行安装，是最为推荐的安装方式</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py <span class="p">|</span> python
</pre></div>
</div>
<p>方式二：（pip） 官方不建议这么做，因为有可能会造成依赖冲突，可以考虑用
pipx 或 pipsi</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip install --user poetry
</pre></div>
</div>
<p>安装后，可以使用如下命令检测是否可用</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry --version
Poetry version <span class="m">1</span>.1.4
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 创建项目<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>如果你是在一个已有的项目里使用 Poetry，你只需要执行 poetry init
命令来创建一个 pyproject.toml 文件：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry init
</pre></div>
</div>
<p>而如果是新建 一个项目，可以使用这个命令</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry new demo-priject
</pre></div>
</div>
<p>运行完后，在当前目录下就会多一个 <code class="docutils literal notranslate"><span class="pre">demo-project</span></code>
的目录，这个目录下的文件结构如下</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree demo-priject
demo-priject
├── README.rst
├── demo_priject
│   └── __init__.py
├── pyproject.toml
└── tests
    ├── __init__.py
    └── test_demo_priject.py
</pre></div>
</div>
<p>如果要把项目代码放入到 src 目录下，在创建项目时，可以加上 <code class="docutils literal notranslate"><span class="pre">--src</span></code>
参数。</p>
</div>
<div class="section" id="id3">
<h4>3. 创建虚拟环境<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>使用 poetry install 命令创建虚拟环境（确保当前目录有 pyproject.toml
文件）：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry install
</pre></div>
</div>
<p>这个命令会读取 pyproject.toml
中的所有依赖（包括开发依赖）并安装，如果不想安装开发依赖，可以附加
–no-dev 选项。如果项目根目录有 poetry.lock
文件，会安装这个文件中列出的锁定版本的依赖。如果执行 add/remove
命令的时候没有检测到虚拟环境，也会为当前目录自动创建虚拟环境。</p>
<p><img alt="image0" src="http://image.iswbm.com/image-20201220164337699.png" /></p>
</div>
<div class="section" id="id4">
<h4>4. 使用虚拟环境<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>创建虚拟环境后，如果想要在虚拟环境下执行命令，比如去执行脚本，去使用 pip
list 等等。</p>
<p>可以在项目目录下，使用如下命令</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry run &lt;commands&gt;
</pre></div>
</div>
<p>比如我查看该虚拟环境中安装了哪些包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry run pip list
</pre></div>
</div>
<p>再比如我想在该虚拟环境下执行 <code class="docutils literal notranslate"><span class="pre">app.py</span></code></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry run python app.py
</pre></div>
</div>
<p>每次在虚拟环境下做点啥事，命令前面都要加上
<code class="docutils literal notranslate"><span class="pre">poetry</span> <span class="pre">run</span></code>，有点太麻烦了。</p>
<p>这时可以使用下面这条命令，直接激活当前的虚拟环境</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry shell
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>5. 包的管理<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>安装包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry add &lt;pkg&gt;
</pre></div>
</div>
<p>添加 –dev 参数可以指定为开发依赖</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry add pytest --dev
</pre></div>
</div>
<p>查看所有安装的依赖包</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry show
</pre></div>
</div>
<p>加上 <code class="docutils literal notranslate"><span class="pre">--tree</span></code> 可以查看他们的依赖关系</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry show --tree
</pre></div>
</div>
<p>加上 <code class="docutils literal notranslate"><span class="pre">--outdated</span></code> 可以查看可以更新的依赖</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry show --outdated
</pre></div>
</div>
<p>如果要更新依赖可以执行这个命令</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 更新全部</span>
$ poetry update

<span class="c1"># 更新某个依赖</span>
$ poetry update foo
</pre></div>
</div>
<p>想卸载某个包，用这个命令</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry remove foo
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>6. 常用配置<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Poetry 的配置存储在单独的文件中，比 Pipenv
设置环境变量的方式要方便一点。配置通过 poetry config
命令设置，比如下面的命令可以写入 PyPI 的账号密码信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry config http-basic.pypi username password
</pre></div>
</div>
<p>下面的命令设置在项目内创建虚拟环境文件夹：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ poetry config settings.virtualenvs.in-project <span class="nb">true</span>
</pre></div>
</div>
<p>另一个常用的配置是设置 PyPI 镜像源，以使用豆瓣提供的 PyPI
镜像源为例，你需要在 pyproject.toml 文件里加入这部分内容：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">tool</span><span class="o">.</span><span class="n">poetry</span><span class="o">.</span><span class="n">source</span><span class="p">]]</span>
<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;douban&quot;</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://pypi.doubanio.com/simple/&quot;</span>
</pre></div>
</div>
<p>不过经过测试 Poetry 会使用 pip.ini 设置的 PyPI
镜像，而且豆瓣的源好像很久没更新了（创建虚拟环境安装的默认依赖里
importlib-metadata==0.20
找不到），<a class="reference external" href="https://link.zhihu.com/?target=http%3A//greyli.com/set-custom-pypi-mirror-url-for-pip-pipenv-poetry-and-flit/">这篇文章</a>列出了一些其他国内的
PyPI 源。</p>
</div>
<div class="section" id="id7">
<h4>7. 参考文章<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://zhuanlan.zhihu.com/p/81025311">相比 Pipenv，Poetry
是一个更好的选择</a></p></li>
</ul>
</div>
</div>
<span id="document-c12/c12_06"></span><div class="section" id="venv">
<h3>12.6 【虚拟环境】方案五：使用 venv<a class="headerlink" href="#venv" title="Permalink to this headline">¶</a></h3>
<p>在前面介绍的几种方法中，都需要借助第三方模块来完成虚拟环境的管理。</p>
<p>但其实在 Python 3 中就自带了一个专门用门管理虚拟环境的模块，它叫
<code class="docutils literal notranslate"><span class="pre">venv</span></code>。</p>
<div class="section" id="id1">
<h4>1. 创建虚拟环境<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">venv</span></code>
后可以接一个目录（如果此目录不存在，会自动创建）用于创建你的虚拟环境，他可以是绝对路径，也可以是相对路径。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># mac or linux</span>
$ python3 -m venv <span class="o">[</span>venv_dir<span class="o">]</span>

<span class="c1"># windows: 一定要指定  --without-pip</span>
<span class="c1"># 最后再手动执行命令安装 python -m ensurepip</span>
$ python3 -m venv --without-pip <span class="o">[</span>venv_dir<span class="o">]</span>
</pre></div>
</div>
<p>使用 venv 创建虚拟环境的速度非常快，大概只需要两三秒的样子。</p>
<p><img alt="image0" src="http://image.iswbm.com/image-20201226172542169.png" /></p>
<p>创建完成后，在你所指定的目录下会有一个 <code class="docutils literal notranslate"><span class="pre">pyvenv.cfg</span></code>
的配置文件，它记录着虚拟环境的基本信息，包括你使用的 Python
的家目录，还有当前虚拟环境的 Python 版本，是否开启使用系统的
site-packages
模块，如果开启了，那么当你就可以直接使用系统中已经装过的第三方模块，但是你在虚拟环境下装的模块就不能被其他地方的程序使用。</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">home</span> <span class="o">=</span> <span class="s">/usr/local/bin</span>
<span class="na">include-system-site-packages</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">version</span> <span class="o">=</span> <span class="s">3.9.1</span>
</pre></div>
</div>
<p>如果你的环境中有 Python 3.8 也有 Python 3.9 ，那该怎么办呢？</p>
<p>只要你在创建时，用你预期版本的 Python 去执行就好啦</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3.8 -m venv <span class="o">[</span>venv_dir<span class="o">]</span>
$ python3.9 -m venv <span class="o">[</span>venv_dir<span class="o">]</span>
</pre></div>
</div>
<p>可如果你的环境中有两个 Python 3.9 呢？你想使用不在 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 的中的
Python 去创建，就要用绝对路径去创建了。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ /usr/local/bin/python3 -m venv <span class="o">[</span>venv_dir<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 进入创建环境<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>进入虚拟环境的方法，对比之前介绍的方案，venv 的方法就相当原始了。</p>
<p>如果你使用 Windows ，那么在 cmd 下进行 <code class="docutils literal notranslate"><span class="pre">Scripts</span></code> 目录，执行
<code class="docutils literal notranslate"><span class="pre">activate.bat</span></code></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># cmd.exe</span>
$ .<span class="se">\S</span>cripts<span class="se">\a</span>ctivate.bat

<span class="c1"># PowserShell</span>
$ .<span class="se">\S</span>cripts<span class="se">\A</span>ctivate.ps1
</pre></div>
</div>
<p>如果你使用PowserShell激活虚拟环境出现如下错误，那要先执行这个命令：<code class="docutils literal notranslate"><span class="pre">Set-ExecutionPolicy</span> <span class="pre">RemoteSigned</span></code>，再按
<code class="docutils literal notranslate"><span class="pre">Y</span></code></p>
<p><img alt="image1" src="http://image.iswbm.com/20201231140727.png" /></p>
<p>而如果你使用的 Mac 或者 Linux，那么直接执行下面命令就行</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">source</span> bin/activate
</pre></div>
</div>
<p>执行完后，若在你的命令行下有 <code class="docutils literal notranslate"><span class="pre">demo</span></code> 字样（之所以是 demo
，因为我们创建时的目录名就是 demo），说明你已经处于虚拟环境下。
由于虚拟环境是全新的干净环境，此时你使用 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">list</span></code>
，会看到啥包都没有，只有最基本的 pip 和 setuptools 。</p>
<p><img alt="image2" src="http://image.iswbm.com/image-20201226174305992.png" /></p>
</div>
<div class="section" id="id3">
<h4>3. 退出虚拟环境<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>退出虚拟环境，无论是 Windows 、 Mac 、 还是 Linux
，方法都是同一条命令。退出后，你的虚拟环境名称（如上面的 <code class="docutils literal notranslate"><span class="pre">demo</span></code>
）也会消失。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ deactivate
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>4. 总结一下<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">venv</span></code> 是 Python3
中自带的虚拟环境管理工具，不需要额外安装，功能简单，用法也简单。但是它不能像
poetry 和 pipenv 用于项目的管理，因此 venv
建议只做了解，在一些简单的场景中可以使用，如果是复杂的项目中，可以直接上
poetry 和 pipenv。</p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p13"></span><div class="section" id="id1">
<h2>第十三章：绝佳工具<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c13/c13_01"></span><div class="section" id="mypy">
<h3>13.1 【静态检查】mypy 的使用<a class="headerlink" href="#mypy" title="Permalink to this headline">¶</a></h3>
<p>Python 3.6以后，允许为参数和函数返回类型添加类型标注（type hinting）。</p>
<p>这就为程序进行静态类型检查提供了可能，mypy就是一个利用类型注解对python代码进行静态类型检查的工具。</p>
<p>使用pip安装</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pip3 install mypy
</pre></div>
</div>
<div class="section" id="id1">
<h4>1. 有问题的代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>下面的代码在执行时不会报任何错误，但严格来讲是存在问题的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stu</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;{name} {age}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>


<span class="n">stu1</span> <span class="o">=</span> <span class="n">Stu</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mf">16.5</span><span class="p">)</span>
<span class="n">stu2</span> <span class="o">=</span> <span class="n">Stu</span><span class="p">(</span><span class="s1">&#39;小刚&#39;</span><span class="p">,</span> <span class="s1">&#39;17&#39;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">stu1</span><span class="p">,</span> <span class="n">stu2</span><span class="p">)</span>
</pre></div>
</div>
<p>在创建Stu实例时，age参数应该传入int类型数据。但由于python是动态类型语言，因此，传入float或者字符串都不会引发错误，除非在后续的属性使用中对类型有明确要求。</p>
<p>这样的代码是不安全的，在程序运行前，可以通过静态类型检查来发现问题，这需要类型标注的帮助</p>
</div>
<div class="section" id="id2">
<h4>2. 添加类型标注<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>将上面的代码修改成如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stu</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;{name} {age}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>


<span class="n">stu1</span> <span class="o">=</span> <span class="n">Stu</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mf">16.5</span><span class="p">)</span>
<span class="n">stu2</span> <span class="o">=</span> <span class="n">Stu</span><span class="p">(</span><span class="s1">&#39;小刚&#39;</span><span class="p">,</span> <span class="s1">&#39;17&#39;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">stu1</span><span class="p">,</span> <span class="n">stu2</span><span class="p">)</span>
</pre></div>
</div>
<p>仅仅是添加了类型标注，我所使用的pycharm就已经提示我创建Stu实例时的age参数有问题，这种提示是委婉的，你可以不用理会。</p>
<p>接下来使用mypy进行静态类型检查</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mypy demo.py
demo.py:10: error: Argument <span class="m">2</span> to <span class="s2">&quot;Stu&quot;</span> has incompatible <span class="nb">type</span> <span class="s2">&quot;float&quot;</span><span class="p">;</span> expected <span class="s2">&quot;int&quot;</span>
demo.py:11: error: Argument <span class="m">2</span> to <span class="s2">&quot;Stu&quot;</span> has incompatible <span class="nb">type</span> <span class="s2">&quot;str&quot;</span><span class="p">;</span> expected <span class="s2">&quot;int&quot;</span>
Found <span class="m">2</span> errors in <span class="m">1</span> file <span class="o">(</span>checked <span class="m">1</span> <span class="nb">source</span> file<span class="o">)</span>
</pre></div>
</div>
<p>mypy准确的找出了两处类型与参数预期不符的情况</p>
</div>
</div>
<span id="document-c13/c13_02"></span><div class="section" id="pytest">
<h3>13.2 【代码测试】pytest 的使用<a class="headerlink" href="#pytest" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>转载自：<a class="reference external" href="http://kuanghy.github.io/2018/05/08/pytest">http://kuanghy.github.io/2018/05/08/pytest</a></p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Pytest</span></code> 是一个比较成熟且功能完备的 Python
测试框架。其提供完善的在线文档，并有着大量的第三方插件和内置帮助，适用于许多小型或大型项目。Pytest
灵活易学，打印调试和测试执行期间可以捕获标准输出，适合简单的单元测试到复杂的功能测试。还可以执行
nose, unittest 和 doctest 风格的测试用例，甚至 Django 和
trial。支持良好的集成实践， 支持扩展的 xUnit 风格 setup，支持非 python
测试。支持生成测试覆盖率报告，支持 PEP8 兼容的编码风格。</p>
<div class="section" id="id1">
<h4>1. 基本使用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">usage</span><span class="p">:</span> <span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="p">[</span><span class="n">file_or_dir</span><span class="p">]</span> <span class="p">[</span><span class="n">file_or_dir</span><span class="p">]</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="id2">
<h5>用例查找规则<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>如果不带参数运行
pytest，那么其先从配置文件(pytest.ini，tox.ini，setup.cfg)中查找配置项
<code class="docutils literal notranslate"><span class="pre">testpaths</span></code> 指定的路径中的 test
case，如果没有则从当前目录开始查找，否者，命令行参数就用于目录、文件查找。查找的规则如下：</p>
<ul class="simple">
<li><p>查找指定目录中以 <code class="docutils literal notranslate"><span class="pre">test</span></code> 开头的目录</p></li>
<li><p>递归遍历目录，除非目录指定了不同递归</p></li>
<li><p>查找文件名以 <code class="docutils literal notranslate"><span class="pre">test_</span></code> 开头的文件</p></li>
<li><p>查找以 <code class="docutils literal notranslate"><span class="pre">Test</span></code> 开头的类(该类不能有 init 方法)</p></li>
<li><p>查找以 <code class="docutils literal notranslate"><span class="pre">test_</span></code> 开头的函数和方法并进行测试</p></li>
</ul>
<p>如果要从默认的查找规则中忽略查找路径，可以加上 <code class="docutils literal notranslate"><span class="pre">--ingore</span></code> 参数，例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pytest –ignore<span class="o">=</span>tests/test_foobar.py
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>调用 pytest<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><p>py.test：</p></li>
</ul>
<p>Pytest 提供直接调用的命令行工具，即 <code class="docutils literal notranslate"><span class="pre">py.test</span></code>，最新版本 <code class="docutils literal notranslate"><span class="pre">pytest</span></code>
和 <code class="docutils literal notranslate"><span class="pre">py.test</span></code> 两个命令行工具都可用</p>
<ul class="simple">
<li><p>python -m pytest：</p></li>
</ul>
<p>效果和 <code class="docutils literal notranslate"><span class="pre">py.test</span></code> 一样, 这种调用方式在多 Python 版本测试的时候是有用的,
例如测试 Python3：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pytest <span class="o">[</span>…<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h5>部分参数介绍<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">--</span><span class="n">version</span>               <span class="n">查看版本</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">--</span><span class="n">fixtures</span><span class="p">,</span> <span class="o">--</span><span class="n">funcargs</span>  <span class="n">查看可用的</span> <span class="n">fixtures</span>
<span class="n">pytest</span> <span class="o">--</span><span class="n">markers</span>                <span class="n">查看可用的</span> <span class="n">markers</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="o">--</span><span class="n">help</span>              <span class="n">命令行和配置文件帮助</span>

<span class="c1"># 失败后停止</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">x</span>           <span class="n">首次失败后停止执行</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">--</span><span class="n">maxfail</span><span class="o">=</span><span class="mi">2</span>  <span class="n">两次失败之后停止执行</span>

<span class="c1"># 调试输出</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="o">--</span><span class="n">showlocals</span>  <span class="n">在</span> <span class="n">traceback</span> <span class="n">中显示本地变量</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">q</span><span class="p">,</span> <span class="o">--</span><span class="n">quiet</span>       <span class="n">静默模式输出</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="o">--</span><span class="n">verbose</span>     <span class="n">输出更详细的信息</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">s</span>                <span class="n">捕获输出</span><span class="p">,</span> <span class="n">例如显示</span> <span class="nb">print</span> <span class="n">函数的输出</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">r</span> <span class="n">char</span>           <span class="n">显示指定测试类型的额外摘要信息</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">--</span><span class="n">tb</span><span class="o">=</span><span class="n">style</span>        <span class="n">错误信息输出格式</span>
    <span class="o">-</span> <span class="n">long</span>    <span class="n">默认的traceback信息格式化形式</span>
    <span class="o">-</span> <span class="n">native</span>  <span class="n">标准库格式化形式</span>
    <span class="o">-</span> <span class="n">short</span>   <span class="n">更短的格式</span>
    <span class="o">-</span> <span class="n">line</span>    <span class="n">每个错误一行</span>

<span class="c1"># 运行指定 marker 的测试</span>
<span class="n">pytest</span> <span class="o">-</span><span class="n">m</span> <span class="n">MARKEXPR</span>

<span class="c1"># 运行匹配的测试</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">-</span><span class="n">k</span> <span class="n">stringexpr</span>

<span class="c1"># 只收集并显示可用的测试用例，但不运行测试用例</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">--</span><span class="n">collect</span><span class="o">-</span><span class="n">only</span>

<span class="c1"># 失败时调用 PDB</span>
<span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="o">--</span><span class="n">pdb</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>执行选择用例<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><p>执行单个模块中的全部用例:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ py.test test_mod.py
</pre></div>
</div>
<ul class="simple">
<li><p>执行指定路径下的全部用例:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ py.test somepath
</pre></div>
</div>
<ul class="simple">
<li><p>执行字符串表达式中的用例:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ py.test -k stringexpr
</pre></div>
</div>
<p>比如 “MyClass?and not method”，选择
TestMyClass.test_something，排除了TestMyClass.test_method_simple。</p>
<ul class="simple">
<li><p>导入 package，使用其文件系统位置来查找和执行用例。执行 pkg
目录下的所有用例:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ py.test –pyargs pkg
</pre></div>
</div>
<ul class="simple">
<li><p>运行指定模块中的某个用例，如运行 test_mod.py 模块中的 test_func
测试函数:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pytest test_mod.py::test_func
</pre></div>
</div>
<ul class="simple">
<li><p>运行某个类下的某个用例，如运行 TestClass 类下的 test_method 测试方法:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ pytest test_mod.py::TestClass::test_method
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h4>2. 断言<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>通常情况下使用 <code class="docutils literal notranslate"><span class="pre">assert</span></code>
语句就能对大多数测试进行断言。对于异常断言，可以使用上下文管理器
<code class="docutils literal notranslate"><span class="pre">pytest.raises</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_zero_division</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">):</span>
        <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span>

<span class="c1"># 还可以捕获异常信息</span>
<span class="k">def</span> <span class="nf">test_zero_division</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;integer division or modulo by zero&#39;</span><span class="p">):</span>
        <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span>
</pre></div>
</div>
<p>对于警告断言，可以使用上下文管理器 <code class="docutils literal notranslate"><span class="pre">pytest.</span> <span class="pre">warns</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">warns</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;my warning&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

<span class="k">with</span> <span class="n">warns</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="s1">&#39;must be 0 or None&#39;</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;value must be 0 or None&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

<span class="k">with</span> <span class="n">warns</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;must be \d+$&#39;</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;value must be 42&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
</pre></div>
</div>
<p>如果仅需断言 <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code>
警告，可以使用 <code class="docutils literal notranslate"><span class="pre">pytest.deprecated_call</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">api_call_v2</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;use v3 of this api&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">200</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">deprecated_call</span><span class="p">():</span>
        <span class="k">assert</span> <span class="n">api_call_v2</span><span class="p">()</span> <span class="o">==</span> <span class="mi">200</span>
</pre></div>
</div>
<p>对于自定义类型的 assert 比较断言，可以通过在 <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code>
文件中实现<code class="docutils literal notranslate"><span class="pre">pytest_assertrepr_compare</span></code> 函数来实现：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_foocompare.py</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">val</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_compare</span><span class="p">():</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">f3</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f3</span>
    <span class="k">assert</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span>


<span class="c1"># content of conftest.py</span>
<span class="k">def</span> <span class="nf">pytest_assertrepr_compare</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">test_foocompare</span> <span class="kn">import</span> <span class="n">Foo</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span> <span class="ow">and</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;==&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;Comparing Foo instances:&#39;</span><span class="p">,</span> <span class="s1">&#39;vals: </span><span class="si">%s</span><span class="s1"> != </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">)]</span>
</pre></div>
</div>
<p>如果需要手动设置失败原因，可以使用 <code class="docutils literal notranslate"><span class="pre">pytest.fail</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_sys_version</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;python2 not supported&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">pytest.skip</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pytest.xfail</span></code> 能够实现跳过测试的功能，skip
表示直接跳过测试，而 xfail 则表示存在预期的失败，但两者的效果差不多：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_skip_and_xfail</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s1">&#39;only support python3&#39;</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;--- start&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">xfail</span><span class="p">(</span><span class="s2">&quot;division by zero: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;--- end&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pytest.importorskip</span></code>
可以在导入失败的时候跳过测试，还可以要求导入的包要满足特定的版本：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docutils</span> <span class="o">=</span> <span class="n">pytest</span><span class="o">.</span><span class="n">importorskip</span><span class="p">(</span><span class="s2">&quot;docutils&quot;</span><span class="p">)</span>
<span class="n">docutils</span> <span class="o">=</span> <span class="n">pytest</span><span class="o">.</span><span class="n">importorskip</span><span class="p">(</span><span class="s2">&quot;docutils&quot;</span><span class="p">,</span> <span class="n">minversion</span> <span class="o">=</span> <span class="s2">&quot;0.3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>断言近似相等可以使用 <code class="docutils literal notranslate"><span class="pre">pytest.approx</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="mf">2.2</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mf">2.3</span><span class="p">)</span>
<span class="k">assert</span> <span class="mf">2.2</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">2.2</span>
</pre></div>
</div>
</div>
<div class="section" id="conftest-py">
<h4>3. conftest.py<a class="headerlink" href="#conftest-py" title="Permalink to this headline">¶</a></h4>
<p>从广义理解，<code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> 是一个本地的 <code class="docutils literal notranslate"><span class="pre">per-directory</span></code>
插件，在该文件中可以定义目录特定的 hooks 和 fixtures。<code class="docutils literal notranslate"><span class="pre">py.test</span></code>
框架会在它测试的项目中寻找 conftest.py
文件，然后在这个文件中寻找针对整个目录的测试选项，比如是否检测并运行
doctest 以及应该使用哪种模式检测测试文件和函数。</p>
<p>总结起来，<code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> 文件大致有如下几种功能：</p>
<ul class="simple">
<li><p><strong>Fixtures:</strong>
用于给测试用例提供静态的测试数据，其可以被所有的测试用于访问，除非指定了范围</p></li>
<li><p><strong>加载插件:</strong> 用于导入外部插件或模块:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest_plugins</span> <span class="o">=</span><span class="s2">&quot;myapp.testsupport.myplugin&quot;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>定义钩子:</strong> 用于配置钩子(hook)，如
pytest_runtest_setup、pytest_runtest_teardown、pytest_config 等：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pytest_runtest_setup</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;called before `pytest_runtest_call(item)`&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>再比如添加命令行选项的钩子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of conftest.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="k">def</span> <span class="nf">pytest_addoption</span><span class="p">(</span><span class="n">parser</span><span class="p">):</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">addoption</span><span class="p">(</span><span class="s2">&quot;--full&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_ture&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;run full test&quot;</span><span class="p">)</span>

<span class="c1"># content of test.py</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">skipif</span><span class="p">(</span><span class="ow">not</span> <span class="n">pytest</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&quot;--runslow&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_func_slow_1</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;当在命令行执行 --runslow 参数时才执行该测试&quot;&quot;&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;skip slow&#39;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>测试根路径:</strong> 如果将 conftest.py 文件放在项目根路径中，则 pytest
会自己搜索项目根目录下的子模块，并加入到 sys.path
中，这样便可以对项目中的所有模块进行测试，而不用设置 PYTHONPATH
来指定项目模块的位置。</p></li>
</ul>
<p>可以有多个 <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code>
文件同时存在，其作用范围是目录。例如测试非常复杂时，可以为特定的一组测试创建子目录，并在该目录中创建
conftest.py 文件，并定义一个 futures 或 hooks。就像如下的结构：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>tests
├── conftest.py
├── mod
│   └── conftest.py
├── mod2
│   └── conftest.py
└── mod3
    └── conftest.py
</pre></div>
</div>
</div>
<div class="section" id="fixtures">
<h4>4. Fixtures<a class="headerlink" href="#fixtures" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">fixture</span></code> 是 pytest 特有的功能，它用 pytest.fixture
标识，定义在函数前面。在编写测试函数的时候，可以将此函数名称做为传入参数，pytest
将会以依赖注入方式，将该函数的返回值作为测试函数的传入参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s1">&#39;function&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autouse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="id7">
<h5>作为参数<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">fixture</span></code> 可以作为其他测试函数的参数被使用，前提是其必须返回一个值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;hello&quot;</span>

<span class="k">def</span> <span class="nf">test_string</span><span class="p">(</span><span class="n">hello</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">hello</span> <span class="o">==</span> <span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="s2">&quot;fixture should return hello&quot;</span>
</pre></div>
</div>
<p>一个更加实用的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">smtp</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">smtplib</span>
    <span class="k">return</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;smtp.gmail.com&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_ehlo</span><span class="p">(</span><span class="n">smtp</span><span class="p">):</span>
    <span class="n">response</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">smtp</span><span class="o">.</span><span class="n">ehlo</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">response</span> <span class="o">==</span> <span class="mi">250</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="c1"># for demo purposes</span>
</pre></div>
</div>
</div>
<div class="section" id="setup">
<h5>作为 setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">fixture</span></code> 也可以不返回值，这样可以用于在测试方法运行前运行一段代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">()</span>  <span class="c1"># 默认参数，每个测试方法前调用</span>
<span class="k">def</span> <span class="nf">before</span><span class="p">():</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;before each test&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_1</span><span class="p">(</span><span class="n">before</span><span class="p">):</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;test_1()&#39;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;before&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_2</span><span class="p">():</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;test_2()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方式与 setup_method、setup_module 等的用法相同，其实它们也是特殊的
fixture。</p>
<p>在上例中，有一个测试用了 <code class="docutils literal notranslate"><span class="pre">pytest.mark.usefixtures</span></code>
装饰器来标记使用哪个 fixture，这中用法表示在开始测试前应用该 fixture
函数但不需要其返回值。使用这种用法时，通过 <code class="docutils literal notranslate"><span class="pre">addfinallizer</span></code>
注册释放函数，以此来做一些“善后”工作，这类似于
teardown_function、teardown_module 等用法。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">smtp</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">smtplib</span>
    <span class="n">smtp</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;smtp.gmail.com&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fin</span><span class="p">():</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;teardown smtp&quot;</span><span class="p">)</span>
        <span class="n">smtp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">request</span><span class="o">.</span><span class="n">addfinalizer</span><span class="p">(</span><span class="n">fin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">smtp</span>  <span class="c1"># provide the fixture value</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h5>作用范围<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">fixtrue</span></code> 可以通过设置 scope
参数来控制其作用域（同时也控制了调用的频率）。如果
<code class="docutils literal notranslate"><span class="pre">scope='module'</span></code>，那么 fixture 就是模块级的，这个 fixture
函数只会在每次相同模块加载的时候执行。这样就可以复用一些需要时间进行创建的对象。fixture
提供三种作用域，用于指定 fixture 初始化的规则：</p>
<ul class="simple">
<li><p>function：每个测试函数之前执行一次，默认</p></li>
<li><p>module：每个模块加载之前执行一次</p></li>
<li><p>session：每次 session 之前执行一次，即每次测试执行一次</p></li>
</ul>
</div>
<div class="section" id="id9">
<h5>反向请求<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">fixture</span></code> 函数可以通过接受 <code class="docutils literal notranslate"><span class="pre">request</span></code>
对象来反向获取请求中的测试函数、类或模块上下文。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">smtp</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">smtplib</span>
    <span class="n">server</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="s2">&quot;smtpserver&quot;</span><span class="p">,</span> <span class="s2">&quot;smtp.qq.com&quot;</span><span class="p">)</span>
    <span class="n">smtp</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="mi">587</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">smtp</span>
    <span class="n">smtp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>有时需要全面测试多种不同条件下的一个对象，功能是否符合预期。可以通过设置
fixture 的 params 参数，然后通过 request 获取设置的值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">return</span> <span class="kc">True</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]])</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Foo</span><span class="p">(</span><span class="o">*</span><span class="n">request</span><span class="o">.</span><span class="n">param</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_foo</span><span class="p">(</span><span class="n">foo</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="o">.</span><span class="n">echo</span><span class="p">()</span>
</pre></div>
</div>
<p>设置 params 参数后，运行 test 时将生成不同的测试 id，可以通过 ids 自定义
id：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">param_a</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>

<span class="k">def</span> <span class="nf">test_param_a</span><span class="p">(</span><span class="n">param_a</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">param_a</span>
</pre></div>
</div>
<p>运行以上实例会有如下结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_fixture</span><span class="o">.</span><span class="n">py</span><span class="p">::</span><span class="n">test_param_a</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="mi">1</span>
<span class="n">PASSED</span>
<span class="n">test_fixture</span><span class="o">.</span><span class="n">py</span><span class="p">::</span><span class="n">test_param_a</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="mi">2</span>
<span class="n">PASSED</span>
<span class="n">test_fixture</span><span class="o">.</span><span class="n">py</span><span class="p">::</span><span class="n">test_param_a</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="mi">4</span>
<span class="n">PASSED</span>
<span class="n">test_fixture</span><span class="o">.</span><span class="n">py</span><span class="p">::</span><span class="n">test_param_a</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="mi">8</span>
<span class="n">PASSED</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h5>自动执行<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>有时候需要某些 fixture
在全局自动执行，如某些全局变量的初始化工作，亦或一些全局化的清理或者初始化函数。这时可以通过设置
fixture 的 autouse 参数来让 fixture 自动执行。设置为 autouse=True
即可使得函数默认执行。以下例子会在开始测试前清理可能残留的文件，接着将程序目录设置为该目录，：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">work_dir</span> <span class="o">=</span> <span class="s2">&quot;/tmp/app&quot;</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">,</span> <span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">clean_workdir</span><span class="p">():</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">work_dir</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">work_dir</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chrdir</span><span class="p">(</span><span class="n">work_dir</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="setup-teardown">
<h4>5. setup/teardown<a class="headerlink" href="#setup-teardown" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">setup/teardown</span></code>
是指在模块、函数、类开始运行以及结束运行时执行一些动作。比如在一个函数中测试一个数据库应用，测需要在函数开始前连接数据库，在函数运行结束后断开与数据库的连接。setup/teardown
是特殊的 fixture，其可以有一下几种实现方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 模块级别</span>
<span class="k">def</span> <span class="nf">setup_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">teardown_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># 类级别</span>
<span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setup_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">teardown_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># 方法级别</span>
<span class="k">def</span> <span class="nf">setup_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">teardown_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># 函数级别</span>
<span class="k">def</span> <span class="nf">setup_function</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">teardown_function</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>有时候，还希望有全局的 setup 或
teardown，以便在测试开始时做一些准备工作，或者在测试结束之后做一些清理工作。这可以用
hook 来实现：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pytest_sessionstart</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="c1"># setup_stuff</span>

<span class="k">def</span> <span class="nf">pytest_sessionfinish</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">exitstatus</span><span class="p">):</span>
    <span class="c1"># teardown_stuff</span>
</pre></div>
</div>
<p>也可以用 fixture 的方式实现：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_fixture</span><span class="p">():</span>
    <span class="c1"># setup_stuff</span>
    <span class="k">yield</span>
    <span class="c1"># teardown_stuff</span>
</pre></div>
</div>
</div>
<div class="section" id="markers">
<h4>6. Markers<a class="headerlink" href="#markers" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">marker</span></code> 的作用是，用来标记测试，以便于选择性的执行测试用例。Pytest
提供了一些内建的 marker：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 跳过测试</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="n">reason</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># 满足某个条件时跳过该测试</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">skipif</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>

<span class="c1"># 预期该测试是失败的</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">xfail</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">raises</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># 参数化测试函数。给测试用例添加参数，供运行时填充到测试中</span>
<span class="c1"># 如果 parametrize 的参数名称与 fixture 名冲突，则会覆盖掉 fixture</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">argnames</span><span class="p">,</span> <span class="n">argvalues</span><span class="p">)</span>

<span class="c1"># 对给定测试执行给定的 fixtures</span>
<span class="c1"># 这种用法与直接用 fixture 效果相同</span>
<span class="c1"># 只不过不需要把 fixture 名称作为参数放在方法声明当中</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="n">fixturename1</span><span class="p">,</span> <span class="n">fixturename2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>

<span class="c1"># 让测试尽早地被执行</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">tryfirst</span>

<span class="c1"># 让测试尽量晚执行</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">trylast</span>
</pre></div>
</div>
<p>例如一个使用参数化测试的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">((</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;expected&quot;</span><span class="p">),</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">])</span>
<span class="k">def</span> <span class="nf">test_increment</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
     <span class="k">assert</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">expected</span>
</pre></div>
</div>
<p>除了内建的 markers 外，pytest 还支持没有实现定义的 markers，如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">old_test</span>
<span class="k">def</span> <span class="nf">test_one</span><span class="p">():</span>
    <span class="k">assert</span> <span class="kc">False</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">new_test</span>
<span class="k">def</span> <span class="nf">test_two</span><span class="p">():</span>
    <span class="k">assert</span> <span class="kc">False</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">windows_only</span>
<span class="k">def</span> <span class="nf">test_three</span><span class="p">():</span>
    <span class="k">assert</span> <span class="kc">False</span>
</pre></div>
</div>
<p>通过使用 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 参数可以让 pytest 选择性的执行部分测试：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pytest test.py -m &#39;not windows_only&#39;
...
collected 3 items / 1 deselected

test_marker.py::test_one FAILED
</pre></div>
</div>
<p>更详细的关于 marker 的说明可以参考官方文档：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/mark.html">https://docs.pytest.org/en/latest/mark.html</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/example/markers.html">https://docs.pytest.org/en/latest/example/markers.html</a></p></li>
</ul>
</div>
<div class="section" id="id11">
<h4>7. 第三方插件<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>pytest-randomly: 测试顺序随机</p></li>
<li><p>pytest-xdist: 分布式测试</p></li>
<li><p>pytest-cov: 生成测试覆盖率报告</p></li>
<li><p>pytest-pep8: 检测代码是否符合 PEP8 规范</p></li>
<li><p>pytest-flakes: 检测代码风格</p></li>
<li><p>pytest-html: 生成 html 报告</p></li>
<li><p>pytest-rerunfailures: 失败重试</p></li>
<li><p>pytest-timeout: 超时测试</p></li>
</ul>
</div>
<div class="section" id="id12">
<h4>8. 参考资料<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/example/">https://docs.pytest.org/en/latest/example/</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/assert.html">https://docs.pytest.org/en/latest/assert.html</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/reference.html">https://docs.pytest.org/en/latest/reference.html</a></p></li>
<li><p><a class="reference external" href="http://doc.pytest.org/en/latest/xunit_setup.html">http://doc.pytest.org/en/latest/xunit_setup.html</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/skipping.html">https://docs.pytest.org/en/latest/skipping.html</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/fixture.html">https://docs.pytest.org/en/latest/fixture.html</a></p></li>
<li><p><a class="reference external" href="http://senarukana.github.io/2015/05/29/pytest-fixture/">http://senarukana.github.io/2015/05/29/pytest-fixture/</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/parametrize.html">https://docs.pytest.org/en/latest/parametrize.html</a></p></li>
<li><p><a class="reference external" href="https://docs.pytest.org/en/latest/plugins.html">https://docs.pytest.org/en/latest/plugins.html</a></p></li>
</ul>
</div>
</div>
<span id="document-c13/c13_03"></span><div class="section" id="pre-commit-hook">
<h3>13.3 【代码提交】pre-commit hook<a class="headerlink" href="#pre-commit-hook" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>转载自：<a class="reference external" href="https://juejin.cn/post/6844903844103585805">https://juejin.cn/post/6844903844103585805</a></p>
</div></blockquote>
<p>代码规范、测试是开发中很重要的一环，重要性无需我多说。我们需要一些自动化工具，来帮助我们更轻松地管理项目。本文推荐几个实用的自动化工具。</p>
<p>pre-commit 我在之前的一篇文章 <a class="reference external" href="https://juejin.im/post/6844903838382555143">推荐一些维护大型 Python
项目的工具</a>中简要提到过，这里再稍微讲一下。</p>
<p>pre-commit
用到一个配置文件：<code class="docutils literal notranslate"><span class="pre">.pre-commit-config.yaml</span></code>，官方文档在<a class="reference external" href="https://pre-commit.com">这里</a>。这里针对
Python 项目，希望 git precommit hooks 能够实现以下功能：能找出不符合
pep8规范的代码，并且能够自动格式化。这需要用到两个工具：<code class="docutils literal notranslate"><span class="pre">black</span></code>和<code class="docutils literal notranslate"><span class="pre">flake8</span></code>，<code class="docutils literal notranslate"><span class="pre">black</span></code>自动格式化，<code class="docutils literal notranslate"><span class="pre">flake8</span></code>检测代码不规范的地方。</p>
<p>整个的 workflow 如下图所示：</p>
<p><img alt="image0" src="http://image.iswbm.com/20201213224702.png" /></p>
<p>具体的执行步骤如下：</p>
<ol class="arabic simple">
<li><p>安装 pre-commit : <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pre-commit</span></code></p></li>
<li><p>写<code class="docutils literal notranslate"><span class="pre">.pre-commit-config.yaml</span></code>配置文件</p></li>
<li><p>用<code class="docutils literal notranslate"><span class="pre">pre-commit</span> <span class="pre">install</span></code>安装git hooks到你的<code class="docutils literal notranslate"><span class="pre">.git/</span></code>目录</p></li>
</ol>
<p>我们的<code class="docutils literal notranslate"><span class="pre">.pre-commit-config.yaml</span></code>很简单，如下：</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">repos:</span>
<span class="na">- repo: https://github.com/ambv/black</span>
  <span class="na">rev: stable</span>
  <span class="na">hooks:</span>
    <span class="na">- id: black</span>
      <span class="na">language_version: python3.7</span>
<span class="na">- repo: https://github.com/pre-commit/pre-commit-hooks</span>
  <span class="na">rev: v1.2.3</span>
  <span class="na">hooks:</span>
    <span class="na">- id: flake8</span>
</pre></div>
</div>
<p>然后我们下一次提交 commit
的时候，会先运行<code class="docutils literal notranslate"><span class="pre">black</span></code>和<code class="docutils literal notranslate"><span class="pre">flake8</span></code>，检查出哪有不规范的地方，并且能自动帮你格式化。你修改之后重新提交
commit，就能顺利提交了。</p>
<p>实际操作一下：</p>
<p>新建一个测试文件：<code class="docutils literal notranslate"><span class="pre">bad_pep8.py</span></code>：</p>
<p><img alt="image1" src="http://image.iswbm.com/20201213224716.png" /></p>
<p>有好几处不符合 pep8规范，我们试着 commit 一下：</p>
<p><img alt="image2" src="http://image.iswbm.com/20201213224726.png" /></p>
<p>可以看到两个 hook 都没有通过，另外 <code class="docutils literal notranslate"><span class="pre">black</span></code>帮我们把代码格式化了。</p>
<p><img alt="image3" src="http://image.iswbm.com/20201213224737.png" /></p>
<p>同时<code class="docutils literal notranslate"><span class="pre">flake8</span></code>提示我们<code class="docutils literal notranslate"><span class="pre">x</span></code>变量定义了但是没有使用，把这一行删掉，然后重新add
并 commit：</p>
<p><img alt="image4" src="http://image.iswbm.com/20201213224752.png" /></p>
<p>如果你觉得没有必要强制要求不能定义变量而不使用（从输出可以看出这个规范的编号为F841），可以在项目根目录建一个<code class="docutils literal notranslate"><span class="pre">.flake8</span></code>配置文件，如下图。更加详细的配置请看<a class="reference external" href="http://flake8.pycqa.org/en/latest/user/configuration.html">官方文档</a>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">flake8</span><span class="p">]</span>
<span class="n">ignore</span> <span class="o">=</span> <span class="n">F841</span>
</pre></div>
</div>
</div>
<span id="document-c13/c13_04"></span><div class="section" id="cookiecutter">
<h3>13.4 【项目生成】cookiecutter 的使用<a class="headerlink" href="#cookiecutter" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>转载自：<a class="reference external" href="https://note.qidong.name/2018/10/cookiecutter/">https://note.qidong.name/2018/10/cookiecutter/</a></p>
</div></blockquote>
<p>IDE都会有一套生成新项目的向导（Wizard），通过点点点，就可以得到一个可以运行的某类程序。
这样的程序，具备了推荐的项目结构，配置的基本的编译、打包、测试，尽管功能只是一个<code class="docutils literal notranslate"><span class="pre">helloworld</span></code>。
这个功能，极大地降低了初学者的进入门槛，也统一了某类项目的文件结构，是一个了不起的进步。
最早使用这类手段的，似乎是Visual Studio。</p>
<p>令人惋惜的是，Python的IDE——PyCharm并不自带这个功能。
这其中，也有Python项目千变万化的因素。
Python的适用范围太广，从桌面到服务器，从游戏到数据分析，都做一套显然投入太大。
而Python又是一门解释型语言，随便写个文件也能直接执行，似乎没有这个必要。</p>
<p>然而，我要说，还是有必要的！</p>
<p>因为Python系缺失一个Wizard，也缺少项目结构的标准，于是出现了<a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>。
这是一个项目生成器，也可称为引擎，因为它只完成了最核心的功能。
真正决定一个项目长什么样的模板，却可以自由定制。
也因此，它能生成任何一种语言的项目。</p>
<div class="section" id="id1">
<h4>1. 快速安装<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ pip install cookiecutter
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>就是一个已经发布的Python包，因此用Python的手段可以直接安装。</p>
<p>对于非Python系的程序员来说，也可以使用包管理器的方式安装。</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># For Mac</span>
$ brew install cookiecutter
<span class="c1"># For Debian/Ubuntu</span>
$ sudo apt install cookiecutter
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 如何使用<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>首先，寻找一个合适的<a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>项目。
最主要的方式，就是访问其GitHub主页的<a class="reference external" href="https://github.com/audreyr/cookiecutter/tree/db14e06a1dcc0187beeafde72685c3acef93eb68#a-pantry-full-of-cookiecutters">A Pantry Full of
Cookiecutters</a>。</p>
<p>如果挑选完毕（这里以<a class="reference external" href="https://github.com/audreyr/cookiecutter-pypackage">cookiecutter-pypackage</a>为例），则可直接执行<code class="docutils literal notranslate"><span class="pre">cookiecutter</span></code>生成项目。</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git
full_name <span class="o">[</span>Yan QiDong<span class="o">]</span>:
email <span class="o">[</span>yanqd0@outlook.com<span class="o">]</span>:
github_username <span class="o">[</span>yanqd0<span class="o">]</span>:
project_name <span class="o">[</span>Python Boilerplate<span class="o">]</span>: trycookie
project_slug <span class="o">[</span>trycookie<span class="o">]</span>:
project_short_description <span class="o">[</span>Python Boilerplate contains all the boilerplate you need to create a Python package.<span class="o">]</span>: A description
pypi_username <span class="o">[</span>yanqd0<span class="o">]</span>:
version <span class="o">[</span><span class="m">0</span>.1.0<span class="o">]</span>:
use_pytest <span class="o">[</span>n<span class="o">]</span>:
use_pypi_deployment_with_travis <span class="o">[</span>y<span class="o">]</span>:
add_pyup_badge <span class="o">[</span>n<span class="o">]</span>:
Select command_line_interface:
<span class="m">1</span> - Click
<span class="m">2</span> - No command-line interface
Choose from <span class="m">1</span>, <span class="m">2</span> <span class="o">(</span><span class="m">1</span>, <span class="m">2</span><span class="o">)</span> <span class="o">[</span><span class="m">1</span><span class="o">]</span>:
create_author_file <span class="o">[</span>y<span class="o">]</span>:
Select open_source_license:
<span class="m">1</span> - MIT license
<span class="m">2</span> - BSD license
<span class="m">3</span> - ISC license
<span class="m">4</span> - Apache Software License <span class="m">2</span>.0
<span class="m">5</span> - GNU General Public License v3
<span class="m">6</span> - Not open <span class="nb">source</span>
Choose from <span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span>, <span class="m">5</span>, <span class="m">6</span> <span class="o">(</span><span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span>, <span class="m">5</span>, <span class="m">6</span><span class="o">)</span> <span class="o">[</span><span class="m">1</span><span class="o">]</span>:
</pre></div>
</div>
<p>在项目生成过程中，会产生一些提示，需要输入对应信息。
这和各类Wizard的GUI中，填写项目名、包名什么的，是同类操作。
以上是，除了项目名叫<code class="docutils literal notranslate"><span class="pre">trycookie</span></code>，基本都选默认的一个结果。</p>
<p>查看项目结构：</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ tree -a trycookie
trycookie
├── .editorconfig
├── .github
│   └── ISSUE_TEMPLATE.md
├── .gitignore
├── .travis.yml
├── AUTHORS.rst
├── CONTRIBUTING.rst
├── HISTORY.rst
├── LICENSE
├── MANIFEST.in
├── Makefile
├── README.rst
├── docs
│   ├── Makefile
│   ├── authors.rst
│   ├── conf.py
│   ├── contributing.rst
│   ├── history.rst
│   ├── index.rst
│   ├── installation.rst
│   ├── make.bat
│   ├── readme.rst
│   └── usage.rst
├── requirements_dev.txt
├── setup.cfg
├── setup.py
├── tests
│   ├── __init__.py
│   └── test_trycookie.py
├── tox.ini
└── trycookie
    ├── __init__.py
    ├── cli.py
    └── trycookie.py

<span class="m">4</span> directories, <span class="m">30</span> files
</pre></div>
</div>
<p>如此庞大而复杂的一个项目结构，融合了作者<a class="reference external" href="https://github.com/audreyr">audreyr</a>对一个开源PyPI项目的理解。
虽然未必适用于任何一个人，但对于什么也不懂的菜鸟来说，却无疑是福音。</p>
</div>
<div class="section" id="id3">
<h4>3. 基本原理<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>的工作原理，是先下载一个模板项目，然后替换模板项目的某些内容，生成新的项目。
在以上的示例中，<code class="docutils literal notranslate"><span class="pre">https://github.com/audreyr/cookiecutter-pypackage.git</span></code>就是一个项目的Git链接。
这可以换成任何一个可以用<code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span></code>来下载的链接，包括各种私有Git托管平台。</p>
<p>如果是GitHub，还可以用以下的等效形式：</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cookiecutter gh:audreyr/cookiecutter-pypackage
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>的简短形式，支持以下三种平台。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Platform</p></th>
<th class="head"><p>abbreviation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://github.com/">GitHub</a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gh</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://bitbucket.org/">BitBucket</a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bb</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://gitlab.com/">GitLab</a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gl</span></code></p></td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>也支持Mercurial（<code class="docutils literal notranslate"><span class="pre">hg</span></code>）。</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cookiecutter hg+ssh://hg@bitbucket.org/audreyr/cookiecutter-pypackage
</pre></div>
</div>
<p>使用过模板的项目，默认都已经被下载到<code class="docutils literal notranslate"><span class="pre">~/.cookiecutter</span></code>目录下。
如果需要再次使用，而又无需更新，可以直接用项目名。</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cookiecutter cookiecutter-pypackage
</pre></div>
</div>
<p>利用这个特点，可以先用各种手段，把模板项目下载到<code class="docutils literal notranslate"><span class="pre">~/.cookiecutter</span></code>目录下，再来使用。</p>
<p>参考：<a class="reference external" href="https://cookiecutter.readthedocs.io/en/latest/usage.html">Usage — cookiecutter 1.6.0
documentation</a></p>
</div>
<div class="section" id="id4">
<h4>4. 配置文件<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>默认情况下，<code class="docutils literal notranslate"><span class="pre">~/.cookiecutterrc</span></code>就是配置文件。
它实际上是一个YAML文件。 以下是孤的配置文件示例。</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># vim: set filetype=yaml:</span>

<span class="nt">default_context</span><span class="p">:</span>
  <span class="nt">full_name</span><span class="p">:</span> <span class="s">&quot;Yan</span><span class="nv"> </span><span class="s">QiDong&quot;</span>
  <span class="nt">email</span><span class="p">:</span> <span class="s">&quot;yanqd0@outlook.com&quot;</span>
  <span class="nt">github_username</span><span class="p">:</span> <span class="s">&quot;yanqd0&quot;</span>
<span class="nt">cookiecutters_dir</span><span class="p">:</span> <span class="s">&quot;~/.cookiecutters/&quot;</span>
<span class="nt">abbreviations</span><span class="p">:</span>
    <span class="nt">pp</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">https://github.com/audreyr/cookiecutter-pypackage.git</span>
    <span class="nt">gh</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">https://github.com/{0}.git</span>
</pre></div>
</div>
<p>可配置项中，<code class="docutils literal notranslate"><span class="pre">default_context</span></code>是设置生成项目时，一些提示信息的默认参数。
<code class="docutils literal notranslate"><span class="pre">cookiecutters_dir</span></code>则是项目的下载位置，一般默认就好。
<code class="docutils literal notranslate"><span class="pre">abbreviations</span></code>是自定义简短形式，属于高级定制功能，仅适用于重度用户。
通常，填一填<code class="docutils literal notranslate"><span class="pre">default_context</span></code>就好。</p>
<p>如果对<code class="docutils literal notranslate"><span class="pre">~/.cookiecutterrc</span></code>这个配置文件的名称和位置不满意，
可以通过环境变量<code class="docutils literal notranslate"><span class="pre">COOKIECUTTER_CONFIG</span></code>，
或者在命令行指定参数<code class="docutils literal notranslate"><span class="pre">--config-file</span></code>来指定新的配置文件。</p>
<p>参考：<a class="reference external" href="https://cookiecutter.readthedocs.io/en/latest/advanced/user_config.html">User Config (0.7.0+) — cookiecutter 1.6.0
documentation</a></p>
</div>
<div class="section" id="id5">
<h4>5. 总结一下<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://github.com/audreyr/cookiecutter">cookiecutter</a>是一个简单好用的项目生成器引擎，并且已经有很多各种类型的模板。
除了Python项目，还有很多其它语言的项目模板。
它可以极大地省去一个项目初始化的重复劳动，也可以帮助菜鸟程序员成长。</p>
<p>当然，如果不满意，还是可以自己修改、定制模板的。</p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-chapters/p14"></span><div class="section" id="id1">
<h2>第十四章：数据可视化<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-c14/c14_01"></span><div class="section" id="matplotlibmatplotlib">
<h3>6.1 【可视化之matplotlib】一图带你入门matplotlib<a class="headerlink" href="#matplotlibmatplotlib" title="Permalink to this headline">¶</a></h3>
<p>Python在数据分析领域有一个很完备的生态系统，在数据处理方面有
Pandas，在数据可视化方面有 Matplotlib，在数据爬取方面有
Scrapy（或者不用框架），在数据挖掘方面有 Scikit-learn等等。</p>
<p>最近这几篇文章，就先来讲讲，比较酷炫的数据可视化，相信你学完之后一定会有满满的成就感。</p>
<p>Matplotlib 是 Python
的一个绘图库。它包含了大量的工具，你可以使用这些工具创建各种图形，包括简单的散点图，正弦曲线，甚至是三维图形。Python
科学计算社区经常使用它完成数据可视化的工作。它几乎可以画出你所能想到各种有逼格，文艺的，高雅的图形。</p>
<p>学习 matplotlib 最好的途径是
官网（<a class="reference external" href="http://matplotlib.org/">http://matplotlib.org/</a>），以下内容都是本人从官网上一点一点消化总结出来的，都是精华提炼，毫不含糊。希望你看完也能有所收获。</p>
<div class="section" id="id1">
<h4>01. 使用工具<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>在上一篇文章中，小明首先讲了一个工具，以后文章里的所有操作都将在这里面实现，还没有阅读的小伙伴，记得先去学习下：Jupyter
NoteBook。</p>
<p>为什么会推荐使用这个工具呢？</p>
<p>你在一些早期的文章中，可能会看到如下，两种语句，</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">inline</span></code> # IPython模式下</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%pylab</span> <span class="pre">inline</span></code> # Jupyter Notebook模式下</p></li>
</ol>
<p>将这两个命令放在你绘图代码前面，它可以在绘图时，将图片内嵌在交互窗口，而不是弹出一个图片窗口（体验感超差有木有）。在这两种模式下，是只要有plt出现，图片会立马show出来（所以可以不用显式的plt.show()）。</p>
<p>但是，这也有一个缺陷：除非将代码一次执行，否则，无法叠加绘图，</p>
<p>看完上面，现在的你可能不知道它们有啥用。不过不要紧，现在你可以完全忽视上面这两个语句，因为现在使用
Jupyter NoteBook 已经不再需要指定这两种语句了。</p>
</div>
<div class="section" id="id2">
<h4>02. 两种方式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在网上有些教程文章，画图使用的是 pylab，而有些使用的是
pyplot。这是常见的两种</p>
<p>那么 pyplot 和 pylab 有什么区别呢？</p>
<p>Matplotlib，大家都很清楚，是整个包的名字。</p>
<p>而 pyplot 和 pyplab 都是 matplotlib 中的一个模块;
pyplot是一个提供了面向对象的底层状态机接口的绘图库</p>
<p>而 pylab 在官网上，有这样一段话：</p>
<blockquote>
<div><p>pylab is a convenience module that bulk imports matplotlib.pyplot
(for plotting) and numpy (for mathematics and working with arrays) in
a single name space. Although many examples use pylab, it is no
longer recommended.</p>
</div></blockquote>
<p>它的内部其实已经导入了 pyplot 和 numpy
。其实我暂时并不知道它有什么弊端，但是最后一句，给我们提了一个醒，它上面说
pylab 已经不再推荐使用了。所以你如果是一个初学者，在网上看到 pylab
的教程文章，那么你可以跳过不学。所以下面的教程，我都将使用 pyplot。</p>
</div>
<div class="section" id="id3">
<h4>03. 图表的基本结构<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>前两天的官网上闲逛的时候，发现了一张图，可以说把一个图表该有的元素都很好的展示出来了。从这张图入手，一点一点地实现这里面的每个元素，我们也算是入门了matplotlib了。
<img alt="image0" src="https://i.loli.net/2018/08/12/5b6ff3716fdc0.png" /></p>
<p>这里面的大部分元素，我相信会点英文的你都能很轻松的理解。</p>
<p>唯独有这两个概念，我要在这里强调一下，就是 aixs 和 axes 的区别：</p>
<p><code class="docutils literal notranslate"><span class="pre">axis</span></code>：可以认为是两个轴，他可以设置轴的大小限制，set_xlim()
，set_ylim() ，还有设置刻度
ticks（由Locator对象定义），还有ticklabel（由Formatter对象定义）等</p>
<p><code class="docutils literal notranslate"><span class="pre">axes</span></code>：可以认为是axis的复数，是多个axis组成的。在二维图里，就是两个axis组成，在三D图里，就是三个axis组成。所以你可以粗浅的理解为一个图表就是一个axes，他们可以设置
标题：set_title()，标签：set_xlabel()，set_ylabel()等</p>
</div>
<div class="section" id="id4">
<h4>04. 画个简单的图<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>学习完了如上的一些基本元素，我们来看看如何一点一点实现它。</p>
<p>以下的代码都在 NoteBook单元格里运行，后面不再赘述。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c1"># x轴对应的值</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># 画图，并设置线形和颜色。 b代表 blue，- 代表线型</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>

<span class="c1"># 设置x轴和y轴的名字</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<span class="c1"># 设置标题</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;First Figure&quot;</span><span class="p">)</span>

<span class="c1"># 设置栅格</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># 设置坐标范围</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="c1"># 在指定坐标处，标注文字</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;y=x^2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># 添加图例，注意是个tuple，加逗号</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">((</span><span class="s1">&#39;MING&#39;</span><span class="p">,),</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>

<span class="c1"># 设置刻度标签</span>
<span class="n">lables</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">lables</span><span class="p">)</span>

<span class="c1"># 打开次刻度</span>
<span class="n">plt</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>

<span class="c1"># 显示图片，在NoteBook中可以不写</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>以上的注释，可以说是很直白啦。一张图表该有的东西都有了，不花哨，但实用。
看看我们的代码输出的图表是啥样的。</p>
<p><img alt="image1" src="http://image.iswbm.com/20190511164650.png" /></p>
<hr class="docutils" />
<p><img alt="image2" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
<span id="document-c14/c14_02"></span><div class="section" id="matplotlib">
<h3>6.2 【可视化之matplotlib】详解六种可视化图表<a class="headerlink" href="#matplotlib" title="Permalink to this headline">¶</a></h3>
<p>可视化图表，有相当多种，但常见的也就下面几种，其他比较复杂一点，大都也是基于如下几种进行组合，变换出来的。对于初学者来说，很容易被这官网上众多的图表类型给吓着了，由于种类太多，几种图表的绘制方法很有可能会混淆起来。</p>
<p>因此，在这里，我特地总结了六种常见的基本图表类型，你可以通过对比学习，打下坚实的基础。</p>
<div class="section" id="id1">
<h4>01. 折线图<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>绘制折线图，如果你数据不是很多的话，画出来的图将是曲折状态，但一旦你的数据集大起来，比如下面我们的示例，有100个点，所以我们用肉眼看到的将是一条平滑的曲线。</p>
<p>这里我绘制三条线，只要执行三次<code class="docutils literal notranslate"><span class="pre">plt.plot</span></code>就可以了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">x</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x label&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y label&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Simple Plot&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image</p>
<p><img alt="image0" src="http://image.iswbm.com/20190511164738.png" /></p>
</div>
<div class="section" id="id2">
<h4>02. 散点图<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>其实散点图和折线图是一样的原理，将散点图里的点用线连接起来就是折线图了。所以绘制散点图，只要设置一下线型即可。</p>
<p><strong>注意</strong>：这里我也绘制三条线，和上面不同的是，我只用一个<code class="docutils literal notranslate"><span class="pre">plt.plot</span></code>就可以了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># 红色破折号, 蓝色方块 ，绿色三角块</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bs&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;g^&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image1" src="http://image.iswbm.com/20190511164753.png" /></p>
</div>
<div class="section" id="id3">
<h4>03. 直方图<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>直方图，大家也不算陌生了。这里小明加大难度，在一张图里，画出两个频度直方图。这应该在实际场景上也会遇到吧，因为这样真的很方便比较，有木有？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">19680801</span><span class="p">)</span>

<span class="n">mu1</span><span class="p">,</span> <span class="n">sigma1</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">15</span>
<span class="n">mu2</span><span class="p">,</span> <span class="n">sigma2</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">15</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">mu1</span> <span class="o">+</span> <span class="n">sigma1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">mu2</span> <span class="o">+</span> <span class="n">sigma2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># the histogram of the data</span>
<span class="c1"># 50：将数据分成50组</span>
<span class="c1"># facecolor：颜色；alpha：透明度</span>
<span class="c1"># density：是密度而不是具体数值</span>
<span class="n">n1</span><span class="p">,</span> <span class="n">bins1</span><span class="p">,</span> <span class="n">patches1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">n2</span><span class="p">,</span> <span class="n">bins2</span><span class="p">,</span> <span class="n">patches2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># n：概率值；bins：具体数值；patches：直方图对象。</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Smarts&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of IQ&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="o">.</span><span class="mo">025</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\mu=100,\ \sigma=15$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="o">.</span><span class="mo">025</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\mu=80,\ \sigma=15$&#39;</span><span class="p">)</span>

<span class="c1"># 设置x，y轴的具体范围</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">40</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image</p>
<p><img alt="image2" src="http://image.iswbm.com/20190511164802.png" /></p>
</div>
<div class="section" id="id4">
<h4>04. 柱状图<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>同样的，简单的柱状图，我就不画了，这里画三种比较难的图。</p>
<div class="section" id="id5">
<h5>4.1 并列柱状图<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">size</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

<span class="c1"># 有多少个类型，只需更改n即可</span>
<span class="n">total_width</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">total_width</span> <span class="o">/</span> <span class="n">n</span>

<span class="c1"># 重新拟定x的坐标</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="c1"># 这里使用的是偏移</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>  <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image</p>
<p><img alt="image3" src="http://image.iswbm.com/20190511164814.png" /></p>
</div>
<div class="section" id="id6">
<h5>4.2 叠加柱状图<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">size</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

<span class="c1"># 这里使用的是偏移</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="n">fc</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image4" src="http://image.iswbm.com/20190511164825.png" /></p>
</div>
</div>
<div class="section" id="id7">
<h4>05. 饼图<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id8">
<h5>5.1 普通饼图<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">labels</span> <span class="o">=</span> <span class="s1">&#39;Frogs&#39;</span><span class="p">,</span> <span class="s1">&#39;Hogs&#39;</span><span class="p">,</span> <span class="s1">&#39;Dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;Logs&#39;</span>
<span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1"># 设置分离的距离，0表示不分离</span>
<span class="n">explode</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">explode</span><span class="o">=</span><span class="n">explode</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">autopct</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.1f%%</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">shadow</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">startangle</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>

<span class="c1"># Equal aspect ratio 保证画出的图是正圆形</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image5" src="http://image.iswbm.com/20190511164835.png" /></p>
</div>
<div class="section" id="id9">
<h5>5.2 嵌套饼图<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c1"># 设置每环的宽度</span>
<span class="n">size</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">60.</span><span class="p">,</span> <span class="mf">32.</span><span class="p">],</span> <span class="p">[</span><span class="mf">37.</span><span class="p">,</span> <span class="mf">40.</span><span class="p">],</span> <span class="p">[</span><span class="mf">29.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">]])</span>

<span class="c1"># 通过get_cmap随机获取颜色</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;tab20c&quot;</span><span class="p">)</span>
<span class="n">outer_colors</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="n">inner_colors</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span>

<span class="k">print</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># [92. 77. 39.]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">outer_colors</span><span class="p">,</span>
       <span class="n">wedgeprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="c1"># [60. 32. 37. 40. 29. 10.]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">inner_colors</span><span class="p">,</span>
       <span class="n">wedgeprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">))</span>

<span class="c1"># equal 使得为正圆</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image6" src="http://image.iswbm.com/20190511164843.png" /></p>
</div>
<div class="section" id="id10">
<h5>5.3 极轴饼图<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>要说酷炫，极轴饼图也是数一数二的了，这里肯定也要学一下。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">19680801</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">radii</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
<span class="n">bars</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="c1"># left表示从哪开始，</span>
<span class="c1"># radii表示从中心点向边缘绘制的长度（半径）</span>
<span class="c1"># width表示末端的弧长</span>

<span class="c1"># 自定义颜色和不透明度</span>
<span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">bar</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="n">bars</span><span class="p">):</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">))</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image7" src="http://image.iswbm.com/20190511164852.png" /></p>
</div>
</div>
<div class="section" id="id11">
<h4>06. 三维图<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id12">
<h5>6.1 绘制三维散点图<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>  <span class="c1"># 创建一个三维的绘图工程</span>
<span class="c1">#  将数据点分成三部分画，在颜色上有区分度</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">z</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>  <span class="c1"># 绘制数据点</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">40</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">40</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">40</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>  <span class="c1"># 坐标轴</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image8" src="http://image.iswbm.com/20190511164900.png" /></p>
</div>
<div class="section" id="id13">
<h5>6.2 绘制三维平面图<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">Axes3D</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="c1"># 具体函数方法可用 help(function) 查看，如：help(ax.plot_surface)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image9" src="http://image.iswbm.com/20190511164915.png" /></p>
<hr class="docutils" />
<p><img alt="image10" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
</div>
<span id="document-c14/c14_03"></span><div class="section" id="matplotlib">
<h3>14.3 【可视化之matplotlib】 绘制正余弦函数图象<a class="headerlink" href="#matplotlib" title="Permalink to this headline">¶</a></h3>
<p>今天打算通过绘制正弦和余弦函数，从默认的设置开始，一步一步地调整改进，让它变得好看，变成我们初高中学习过的图象那样。通过这个过程来学习如何进行对图表的一些元素的进行调整。</p>
<div class="section" id="id1">
<h4>1. 简单绘图<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>matplotlib有一套允许定制各种属性的默认设置。你可以几乎控制matplotlib中的每一个默认属性：图像大小，每英寸点数，线宽，色彩和样式，子图(axes)，坐标轴和网格属性，文字和字体属性，等等。</p>
<p>虽然matplotlib的默认设置在大多数情况下相当好，你却可能想要在一些特别的情形下更改一些属性。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">C</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">C</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>

<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image0" src="http://image.iswbm.com/20190511164936.png" /></p>
</div>
<div class="section" id="id2">
<h4>2. 设置基本元素<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>这边的基本元素主要有几下几点：</p>
<ol class="arabic simple">
<li><p>线的颜色，粗细，和线型</p></li>
<li><p>刻度和标签</p></li>
<li><p>还有图例</p></li>
</ol>
<p>代码比较简单，基本上在我的第一讲内容里都讲过了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">C</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 设置线的颜色，粗细，和线型</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$sin(x)$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>  <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$cos(x)$&#39;</span><span class="p">)</span>

<span class="c1"># 如果觉得线条离边界太近了，可以加大距离</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>

<span class="c1"># 当前的刻度并不清晰，需要重新设定,并加上更直观的标签</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span>
          <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$-\pi$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$-\pi/2$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$0$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$+\pi/2$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$+\pi$&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
          <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$-1$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$0$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$1$&#39;</span><span class="p">])</span>

<span class="c1"># 添加图例</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>show image <img alt="image1" src="http://image.iswbm.com/20190511164949.png" /></p>
</div>
<div class="section" id="id3">
<h4>3. 移动轴线<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>还记得我们在初高中学习的三角函数图象，可不是这样，它应该是有四个象限的。而这里却是一个四四方方的图表。</p>
<p>所以接下来，我们要做的就是移动轴线，让它变成我们熟悉的样子。</p>
<p>我们只需要两轴线（x和y轴），所以我们需要将顶部和右边的轴线给隐藏起来（颜色设置为None即可）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># plt.gca()，全称是get current axis</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="c1"># 由于我们移动的是左边和底部的轴，所以不用设置这两个也可以</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>

<span class="c1"># 指定data类型，就是移动到指定数值</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>关于<code class="docutils literal notranslate"><span class="pre">set_position()</span></code>这个函数中的data是啥意思？我查了下官网。解释如下
<img alt="image2" src="http://image.iswbm.com/20190511165003.png" /> 然后最后发现，上面的写法可以用一定更简洁的方式设置，是等价的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>show image <img alt="image3" src="http://image.iswbm.com/20190511165013.png" /></p>
</div>
<div class="section" id="id4">
<h4>4. 添加注释<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>现在的图形部分已经成型，接下让我们现在使用annotate命令注解一些我们感兴趣的点。</p>
<p>我们选择<code class="docutils literal notranslate"><span class="pre">2π/3</span></code>作为我们想要注解的正弦和余弦值。我们将在曲线上做一个标记和一个垂直的虚线。然后，使用annotate命令来显示一个箭头和一些文本。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>

<span class="c1"># 利用plt.plot绘制向下的一条垂直的线，利用plt.scatter绘制一个点。</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">t</span><span class="p">,],[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$&#39;</span><span class="p">,</span>
         <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
         <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="o">+</span><span class="mi">30</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
         <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3,rad=.2&quot;</span><span class="p">))</span>

<span class="c1"># 利用plt.plot绘制向上的一条垂直的线，利用plt.scatter绘制一个点。</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">t</span><span class="p">,],[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$cos(\frac{2\pi}{3})=-\frac{1}{2}$&#39;</span><span class="p">,</span>
         <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
         <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
         <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3,rad=.2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>在这里，你可能会对<code class="docutils literal notranslate"><span class="pre">plt.annotate</span></code>这个函数的用法，有所陌生。这里也解释一下。</p>
<p>第一个参数，就是注释内容；
第二个参数，<code class="docutils literal notranslate"><span class="pre">xy</span></code>，就是对哪一点进行注释；
第三个参数，<code class="docutils literal notranslate"><span class="pre">xycoords</span></code>，指定类型，data 是说基于数值来定位；
第四个参数，<code class="docutils literal notranslate"><span class="pre">xytext</span></code>，是注释的位置，结合第五个参数，就是根据偏移量来决定注释位置；
第五个参数，<code class="docutils literal notranslate"><span class="pre">textcoords</span></code>，值为offset points，就是说是相对位置；
第六个参数，<code class="docutils literal notranslate"><span class="pre">fontsize</span></code>，注释大小；
第七个参数，<code class="docutils literal notranslate"><span class="pre">arrowprops</span></code>，对箭头的类型的一些设置。</p>
<p>show image <img alt="image4" src="http://image.iswbm.com/20190511165020.png" /></p>
</div>
<div class="section" id="id5">
<h4>5. 完整代码<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>以上都是对片段代码进行解释，这里放出完整的代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">C</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># 设置线的颜色，粗细，和线型</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$sin(x)$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>  <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$cos(x)$&#39;</span><span class="p">)</span>

<span class="c1"># 如果觉得线条离边界太近了，可以加大距离</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>

<span class="c1"># 当前的刻度并不清晰，需要重新设定,并加上更直观的标签</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span>
          <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$-\pi$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$-\pi/2$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$0$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$+\pi/2$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$+\pi$&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
          <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$-1$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$1$&#39;</span><span class="p">])</span>

<span class="c1"># 添加图例</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

<span class="c1"># plt.gca()，全称是get current axis</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="c1"># 由于我们移动的是左边和底部的轴，所以不用设置这两个也可以</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>

<span class="c1"># 指定data类型，就是移动到指定数值</span>
<span class="c1"># ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>

<span class="c1"># 利用plt.plot绘制向下的一条垂直的线，利用plt.scatter绘制一个点。</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">t</span><span class="p">,],[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$&#39;</span><span class="p">,</span>
         <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
         <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="o">+</span><span class="mi">30</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
         <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3,rad=.2&quot;</span><span class="p">))</span>

<span class="c1"># 利用plt.plot绘制向上的一条垂直的线，利用plt.scatter绘制一个点。</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">t</span><span class="p">,],[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$cos(\frac{2\pi}{3})=-\frac{1}{2}$&#39;</span><span class="p">,</span>
         <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
         <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
         <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3,rad=.2&quot;</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<hr class="docutils" />
<p><img alt="image5" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
<span id="document-c14/c14_04"></span><div class="section" id="matplotlib">
<h3>14.4 【可视化之matplotlib】难点：子图与子区<a class="headerlink" href="#matplotlib" title="Permalink to this headline">¶</a></h3>
<p>在 matplotlib 中有两个非常重要，而且很容易混淆的概念，一个是
subplot，一个是axes。这两个概念将贯穿整个 matplotlib
学习历程。在往后进行深度研究之前呢，务必要先弄懂这两个概念，否则将后面的绘制代码，我相信你一定会一头雾水的。</p>
<p>在查阅了一些相关中文文档后，我暂且将 subplot 称为 子区，而将 axes 称之为
子图。这些只是为了方便后续的描述。</p>
<p>你会发现，即使翻译成中文后，还是无法帮助我们直观的理解这两个概念。因此我特地画了几张图，来解释这两者到底是啥区别。</p>
<div class="section" id="id1">
<h4>1. 子区<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>子区（subplot），是基于 网格（grid）来规划的。</p>
<p>比如，这个写法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>是将当前图像（figure）按 2 行 2 列的布局进行分割，然后取索引为 1
的子图。注意 matlibplot 是完全借鉴了 MATLAB 的思想，所以的起始索引为
1，不像 Python 的起始索引为 0。 <img alt="image0" src="http://image.iswbm.com/20190511165103.png" /></p>
<p>他有好几种写法，这里写我在官网学到的几个方法。</p>
<p>这几种写法是等价的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 第一种写法</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># 第二种写法</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># 第三种写法: GridSpec</span>
<span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="kn">as</span> <span class="nn">gridspec</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>这第二种写法呢，是将图像分成 2 行 2 列，再取 第 0 索引行（第一行），第 0
索引列（第一列）。</p>
<p>学完了以上内容，我们来使用最简单的方法（第一种）来实践一下。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">fig</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># 等同于 plt.subplot(2, 1，1)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">fig</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">fig</span><span class="p">(</span><span class="n">t2</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

<span class="c1"># 等同于 plt.subplot(2, 1，2)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t2</span><span class="p">),</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image1" src="http://image.iswbm.com/20190511165132.png" /></p>
</div>
<div class="section" id="id2">
<h4>2. 子图<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>子图（axes），和子区(subplot)非常相似，一个子图可能是由一个或多个子区域构成的。它比子区更加灵活。</p>
<p>它可以是这样 <img alt="image2" src="http://image.iswbm.com/20190511165152.png" /></p>
<p>要实现如上这个效果。常用的有两种方法。</p>
<p>第一种，使用 <code class="docutils literal notranslate"><span class="pre">subplot2grid</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">axes1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">colspan</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">axes2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">colspan</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">axes3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">rowspan</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">axes4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">axes5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>第二种，使用 <code class="docutils literal notranslate"><span class="pre">GridSpec</span></code> （可以切片）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="kn">as</span> <span class="nn">gridspec</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">ax5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>这个比较规则的划分我们举个例子看看。</p>
<p><img alt="image3" src="http://image.iswbm.com/20190511165159.png" /></p>
<p>代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>


<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>


<span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>           <span class="c1"># Default margin is 0.05, value 0 means fit</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

<span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">221</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>           <span class="c1"># Values &gt;0.0 zoom out</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Zoomed out&#39;</span><span class="p">)</span>

<span class="n">ax3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">222</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=-</span><span class="mf">0.25</span><span class="p">)</span>   <span class="c1"># Values in (-0.5, 0.0) zooms in to center</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Zoomed in&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>为什么说，子图的灵活性更高呢，因为它允许把图片放置到图像(figure)中的任何地方（如下图）。所以如果我们想要在一个大图片中嵌套一个小点的图片，我们通过子图(axes)来完成它。</p>
<p><img alt="image4" src="http://image.iswbm.com/20190511165211.png" /></p>
<p>图中的 axes
是如何实现的，刚开始我也有点懵逼，在查阅了官方文档后，我才明白。
<img alt="image5" src="http://image.iswbm.com/20190511165221.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">left</span></code> 是指，离左边界的距离。 <code class="docutils literal notranslate"><span class="pre">bottom</span></code> 是指，离底边的距离。
<code class="docutils literal notranslate"><span class="pre">width</span></code> 是指，子图的宽度。 <code class="docutils literal notranslate"><span class="pre">height</span></code> 是指，子图的高度。</p>
<p>以上四个参数，是一个（0, 1）的比例（相比于figure），而不是具体数值。</p>
<p>同样地，这个我们也来看一个例子。</p>
<p>这个图的亮点，在于中间，多了两个子图，就像往图中贴上了两个插画一样。
<img alt="image6" src="http://image.iswbm.com/20190511165229.png" /></p>
<p>那么这个如何实现呢？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># Fixing random state for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">19680801</span><span class="p">)</span>


<span class="c1"># create some data to use for the plot</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span> <span class="o">/</span> <span class="mf">0.05</span><span class="p">)</span>  <span class="c1"># impulse response</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">*</span> <span class="n">dt</span>  <span class="c1"># colored noise</span>

<span class="c1"># the main axes is subplot(111) by default</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;current (nA)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gaussian colored noise&#39;</span><span class="p">)</span>

<span class="c1"># this is an inset axes over the main axes</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="o">.</span><span class="mi">65</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">],</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">n</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Probability&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>

<span class="c1"># this is another inset axes over the main axes</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">],</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)],</span> <span class="n">r</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Impulse response&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<hr class="docutils" />
<p><img alt="image7" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
<span id="document-c14/c14_05"></span><div class="section" id="matplotlibgif">
<h3>14.5 【可视化之matplotlib】绘制酷炫的gif动态图<a class="headerlink" href="#matplotlibgif" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 准备工作<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>在 Jupyter Notebook 里要对动态图进行保存，需要 <code class="docutils literal notranslate"><span class="pre">ImageMagick</span></code>
这个超强大的图形处理软件的支持。</p>
<p>所以在往下学习之前，你需要先安装这个工具。安装方法请自行搜索引擎解决哈。</p>
<p>安装完成后，请打开 CMD
终端，检验一下是否成功安装，如果执行没有报错，则已成功安装。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">magick</span> <span class="o">--</span><span class="n">version</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 绘制原理<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>首先，我们要清楚的是，matplotlib
只能对静态图进行绘制展示。那么动态图是如何实现的？动态图和视频一样，都是由一帧一帧的画面组合而成。将这些画面拼接起来的工作，就是由
<code class="docutils literal notranslate"><span class="pre">ImageMagick</span></code> 来完成的。</p>
<p>问题又来了，如何在程序里可以生成这些一帧一帧的画面呢？</p>
<p>matplotlib 给我们提供了一个函数，<code class="docutils literal notranslate"><span class="pre">animation.FuncAnimation</span></code>
用它我们就可以很轻松的完成这些画面展示。最后才能交由 <code class="docutils literal notranslate"><span class="pre">ImageMagick</span></code>
来处理。</p>
<p>接下来，来看看绘制的整体代码框架（伪代码）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 导入相关模块</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

<span class="c1"># 生成数据（用于传入updata函数）</span>
<span class="k">def</span> <span class="nf">data_gen</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="c1"># 初始化图像（譬如 坐标范围）</span>
<span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="c1"># 将最新数据添加到图像中</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># 核心方法入口</span>
<span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">()</span>

<span class="c1"># 保存 gif 动态图</span>
<span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;ming.gif&#39;</span><span class="p">,</span><span class="n">writer</span><span class="o">=</span><span class="n">writer</span><span class="p">)</span>

<span class="c1"># 将 gif 图展示在页面上</span>
<span class="n">Image</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;./ming.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 方法参数<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>本节最重要的知识点，其实就一个函数（<code class="docutils literal notranslate"><span class="pre">FuncAnimation</span></code>），他可以接收很多参数。要使用它，必须得先知道这些参数都有什么用途。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fig</span></code>：进行动画绘制的figure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init_func</span></code>：自定义开始帧，即传入刚定义的函数init</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interval</span></code>：更新频率，以ms计。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blit</span></code>：选择更新所有点，还是仅更新产生变化的点。应选择True。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code>：接收来自 frames 函数传来的 frame
值，作为更新图像最新数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frames</span></code>：可接收对象有 iterable, int, generator function, or
None。用途生成数据传递给func函数</p></li>
</ul>
</div>
<div class="section" id="id4">
<h4>4. 实战讲解<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>经过我的一番尝试，发现在 Notebook 无法直接使用<code class="docutils literal notranslate"><span class="pre">ImageMagick</span></code>。</p>
<p>我们必须显式地指定其路径，并生成一个 ImageMagickFileWriter
实例，用于后面保存图像使用。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;animation.convert_path&#39;</span><span class="p">]</span> <span class="o">=</span> \
             <span class="s1">&#39;E:\Program Files\ImageMagick-7.0.8-Q16\magick.exe&#39;</span>

<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">ImageMagickFileWriter</span>
<span class="n">writer</span> <span class="o">=</span> <span class="n">ImageMagickFileWriter</span><span class="p">()</span>
</pre></div>
</div>
<p>具体绘制代码如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 导入相关模块</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="k">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="k">import</span> <span class="n">FuncAnimation</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="c1"># 注意这边的 &quot;,&quot; 不能省</span>
<span class="n">ln</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">animated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># 初始化图像（譬如 坐标范围）</span>
<span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
    <span class="c1"># 注意这边的 &quot;,&quot; 也不能省</span>
    <span class="k">return</span> <span class="n">ln</span><span class="p">,</span>

<span class="c1"># 将最新数据添加到图像中</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="n">xdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="n">ydata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
    <span class="n">ln</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
    <span class="c1"># 注意这边的 &quot;,&quot; 也不能省</span>
    <span class="k">return</span> <span class="n">ln</span><span class="p">,</span>

<span class="c1"># 核心方法入口</span>
<span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span>
                    <span class="n">update</span><span class="p">,</span>
                    <span class="n">frames</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
                    <span class="n">interval</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                    <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># 保存 gif 动态图</span>
<span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;ming.gif&#39;</span><span class="p">,</span><span class="n">writer</span><span class="o">=</span><span class="n">writer</span><span class="p">)</span>

<span class="c1"># 将 gif 图展示在页面上</span>
<span class="n">Image</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;./ming.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>绘制出来的结果如下： <img alt="image0" src="https://i.loli.net/2018/12/25/5c2226078799b.gif" /></p>
<hr class="docutils" />
<p><img alt="image1" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
<span id="document-c14/c14_06"></span><div class="section" id="matplotlib">
<h3>14.6 【可视化之matplotlib】自动生成图像视频<a class="headerlink" href="#matplotlib" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>1. 准备工作<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>如果你和我一样使用的是 Jupyter
这个工具的话，在绘制之前，需要安装一个工具，就是 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code>。</p>
<p>安装方法，可以参考
「<a class="reference external" href="https://zh.wikihow.com/%E5%9C%A8Windows%E4%B8%8A%E5%AE%89%E8%A3%85FFmpeg%E7%A8%8B%E5%BA%8F">在Windows上安装FFmpeg程序</a>」</p>
<p>由于我使用的是 Anaconda
，我需要将其安装到我的环境中。首先打开我们的命令行（注意不是一般的CMD），使用windows
的查找入口：</p>
<p><img alt="image0" src="http://image.iswbm.com/20190511165315.png" /></p>
<p>然后执行如下命令安装</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">c</span> <span class="n">conda</span><span class="o">-</span><span class="n">forge</span> <span class="n">ffmpeg</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 绘制原理<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>我们都知道，视频是由一帧一帧的图片画面组合而成的。只不过其切换的速度很快，过渡平滑，才让我们看起来毫无违和感。</p>
<p>视频的录制，其实和上一章的 gif
动态图用法是一致的，只不过有用的工具方法有所不同而已。这里使用的是<code class="docutils literal notranslate"><span class="pre">HTML(ani.to_html5_video())</span></code></p>
<p>接下来，来看看绘制的整体代码框架（伪代码）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 导入相关模块</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span>
<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

<span class="c1"># 生成数据（用于传入updata函数）</span>
<span class="k">def</span> <span class="nf">data_gen</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="c1"># 初始化图像（譬如 坐标范围）</span>
<span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="c1"># 将最新数据添加到图像中</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># 核心方法入口</span>
<span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">()</span>

<span class="c1"># 生成一个视频动画</span>
<span class="n">HTML</span><span class="p">(</span><span class="n">ani</span><span class="o">.</span><span class="n">to_html5_video</span><span class="p">())</span>
</pre></div>
</div>
<p>需要注意的是，最后一个 HTML 函数里指定 <code class="docutils literal notranslate"><span class="pre">to_html5_video</span></code>
方法，能和这一整个变化的过程，转换成一个视频片段。可以很方便的让我们在
Jupyter NoteBook 里观察整个变化的过程。</p>
<p>生成的视频，可以反复播放，当然也可以右键进行<code class="docutils literal notranslate"><span class="pre">下载</span></code>。</p>
</div>
<div class="section" id="id3">
<h4>3. 方法参数<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>本节最重要的知识点，其实就一个函数（<code class="docutils literal notranslate"><span class="pre">FuncAnimation</span></code>），他可以接收很多参数。要使用它，必须得先知道这些参数都有什么用途。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fig</span></code>：进行动画绘制的figure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init_func</span></code>：自定义开始帧，即传入刚定义的函数init</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interval</span></code>：更新频率，以ms计。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blit</span></code>：选择更新所有点，还是仅更新产生变化的点。应选择True。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code>：接收来自 frames 函数传来的 frame
值，作为更新图像最新数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frames</span></code>：可接收对象有 iterable, int, generator function, or
None。用途生成数据传递给func函数</p></li>
</ul>
</div>
<div class="section" id="id4">
<h4>4. 录制实战<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>这里截取官网上一个小例子，来做个演示。代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span>
<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

<span class="c1"># 生成数据（用于传入updata函数）</span>
<span class="k">def</span> <span class="nf">data_gen</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.1</span>
        <span class="k">yield</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="mf">10.</span><span class="p">)</span>

<span class="c1"># 初始化图像（譬如 坐标范围）</span>
<span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">xdata</span><span class="p">[:]</span>
    <span class="k">del</span> <span class="n">ydata</span><span class="p">[:]</span>
    <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

<span class="c1"># 将最新数据添加到图像中</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">xdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ydata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

<span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                    <span class="n">func</span><span class="o">=</span><span class="n">update</span><span class="p">,</span>
                    <span class="n">frames</span><span class="o">=</span><span class="n">data_gen</span><span class="p">,</span>
                    <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                    <span class="n">interval</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                    <span class="n">repeat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">blit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">HTML</span><span class="p">(</span><span class="n">ani</span><span class="o">.</span><span class="n">to_html5_video</span><span class="p">())</span>
</pre></div>
</div>
<p>将这段代码放入，NoteBook 里运行后。会输出一个小短片。</p>
<p>我将这个小短片下载并上传至后台，你可以点击
<a class="reference external" href="https://mp.weixin.qq.com/s/BU4DtJQxtxwEMhGZE8t3CQ">公众号原文</a>
感受一下。</p>
<hr class="docutils" />
<p><img alt="image1" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
<span id="document-c14/c14_07"></span><div class="section" id="plotly-express">
<h3>14.7 【可视化神器】最高级的可视化神器： plotly_express<a class="headerlink" href="#plotly-express" title="Permalink to this headline">¶</a></h3>
<p>matplotlib
是一切画图的基础，但是使用它要想画出好看酷炫的插图，是非常考验功力的。</p>
<p>因此在日常使用过程中，通常会使用经过封装的高级库，比如
<code class="docutils literal notranslate"><span class="pre">plotly_express</span></code>，它上手非常的简单，基本所有的图都只要一行代码就能绘出一张非常酷炫的可视化图。</p>
<p>下面来具体讲解一下，如何使用 <code class="docutils literal notranslate"><span class="pre">plotly_express</span></code>。</p>
<div class="section" id="id1">
<h4>1. 环境准备<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>本文的是在如下环境下测试完成的。</p>
<ul class="simple">
<li><p>Python3.7</p></li>
<li><p>Jupyter notebook</p></li>
<li><p>Pandas1.1.3</p></li>
<li><p>Plotly_express0.4.1</p></li>
</ul>
<p>其中 Plotly_express0.4.1 是本文的主角，安装它非常简单，只需要使用 pip
install 就可以</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python3 -m pip install plotly_express
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>2. 概述<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>在说
<code class="docutils literal notranslate"><span class="pre">plotly_express</span></code>之前，我们先了解下<code class="docutils literal notranslate"><span class="pre">plotly</span></code>。<code class="docutils literal notranslate"><span class="pre">Plotly</span></code>是新一代的可视化神器，由<code class="docutils literal notranslate"><span class="pre">TopQ</span></code>量化团队开源。虽然<code class="docutils literal notranslate"><span class="pre">Ploltly</span></code>功能非常之强大，但是一直没有得到重视，主要原因还是其设置过于繁琐。因此，<code class="docutils literal notranslate"><span class="pre">Plotly</span></code>推出了其简化接口：<code class="docutils literal notranslate"><span class="pre">Plotly_express</span></code>，下文中统一简称为<code class="docutils literal notranslate"><span class="pre">px</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">px</span></code>是对<code class="docutils literal notranslate"><span class="pre">Plotly.py</span></code>的一种高级封装，其内置了很多实用且现代的绘图模板，用户只需要调用简单的API函数即可实用，从而快速绘制出漂亮且动态的可视化图表。</p>
<p><code class="docutils literal notranslate"><span class="pre">px</span></code>是完全免费的，用户可以任意使用它。最重要的是，<code class="docutils literal notranslate"><span class="pre">px</span></code>和<code class="docutils literal notranslate"><span class="pre">plotly</span></code>生态系统的其他部分是完全兼容的。用户不仅可以在<code class="docutils literal notranslate"><span class="pre">Dash</span></code>中使用，还能通过<code class="docutils literal notranslate"><span class="pre">Orca</span></code>将数据导出为几乎任意文件格式。</p>
<p>官网的学习资料：<a class="reference external" href="https://plotly.com/">https://plotly.com/</a></p>
<p>px的安装是非常简单的，只需要通过<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">plotly_express</span></code>来安装即可。安装之后的使用：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">plotly_express</span> <span class="kn">as</span> <span class="nn">px</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>3. 开始绘图<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>接下来我们通过px中自带的数据集来绘制各种精美的图形。</p>
<ul class="simple">
<li><p>gapminder</p></li>
<li><p>tips</p></li>
<li><p>wind</p></li>
</ul>
<div class="section" id="id4">
<h5>3.1 数据集<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>首先我们看下<code class="docutils literal notranslate"><span class="pre">px</span></code>中自带的数据集：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">plotly_express</span> <span class="kn">as</span> <span class="nn">px</span>  <span class="c1"># 现在这种方式也可行：import plotly.express as px</span>

<span class="c1"># 数据集</span>
<span class="n">gapminder</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">gapminder</span><span class="p">()</span>
<span class="n">gapminder</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>  <span class="c1"># 取出前5条数据</span>
</pre></div>
</div>
<p><img alt="image0" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk62la4jdj30w80di76a.jpg" /></p>
<p>我们看看全部属性值：</p>
<p><img alt="image1" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk63x8e6jj30xg05gq3p.jpg" /></p>
</div>
<div class="section" id="id5">
<h5>3.2 线型图<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>线型图line在可视化制图中是很常见的。利用px能够快速地制作线型图：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># line 图</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">line</span><span class="p">(</span>
  <span class="n">gapminder</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;lifeExp&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span><span class="p">,</span>  <span class="c1"># 颜色的数据</span>
  <span class="n">line_group</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span><span class="p">,</span>  <span class="c1"># 线性分组</span>
  <span class="n">hover_name</span><span class="o">=</span><span class="s2">&quot;country&quot;</span><span class="p">,</span>   <span class="c1"># 悬停hover的数据</span>
  <span class="n">line_shape</span><span class="o">=</span><span class="s2">&quot;spline&quot;</span><span class="p">,</span>  <span class="c1"># 线的形状</span>
  <span class="n">render_mode</span><span class="o">=</span><span class="s2">&quot;svg&quot;</span>  <span class="c1"># 生成的图片模式</span>
<span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image2" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk661hcg9j31ds0oik1w.jpg" /></p>
<p>再来制作面积图：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># area 图</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">area</span><span class="p">(</span>
  <span class="n">gapminder</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span><span class="p">,</span>   <span class="c1"># 颜色</span>
  <span class="n">line_group</span><span class="o">=</span><span class="s2">&quot;country&quot;</span>  <span class="c1"># 线性组别</span>
<span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image3" src="https://i.loli.net/2020/12/15/B5meiFSvxtQXa4W.gif" /></p>
</div>
<div class="section" id="id6">
<h5>3.3 散点图<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>散点图的制作调用<code class="docutils literal notranslate"><span class="pre">scatter</span></code>方法：</p>
<p><img alt="image4" src="https://i.loli.net/2020/12/15/vJWuqwMgaLPc3TH.gif" /></p>
<p>指定size参数还能改变每个点的大小：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
  <span class="n">gapminder2007</span>   <span class="c1"># 绘图DataFrame数据集</span>
  <span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;gdpPercap&quot;</span>  <span class="c1"># 横坐标</span>
  <span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="s2">&quot;lifeExp&quot;</span>  <span class="c1"># 纵坐标</span>
  <span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span>  <span class="c1"># 区分颜色</span>
  <span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s2">&quot;pop&quot;</span>   <span class="c1"># 区分圆的大小</span>
  <span class="p">,</span><span class="n">size_max</span><span class="o">=</span><span class="mi">60</span>  <span class="c1"># 散点大小</span>
<span class="p">)</span>
</pre></div>
</div>
<p><img alt="image5" src="https://i.loli.net/2020/12/15/tCNrGpK3bVxyi8m.gif" /></p>
<p>通过指定<code class="docutils literal notranslate"><span class="pre">facet_col</span></code>、<code class="docutils literal notranslate"><span class="pre">animation_frame</span></code>参数还能将散点进行分块显示：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
  <span class="n">gapminder</span>   <span class="c1"># 绘图使用的数据</span>
  <span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;gdpPercap&quot;</span> <span class="c1"># 横纵坐标使用的数据</span>
  <span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="s2">&quot;lifeExp&quot;</span>  <span class="c1"># 纵坐标数据</span>
  <span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span>  <span class="c1"># 区分颜色的属性</span>
  <span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s2">&quot;pop&quot;</span>   <span class="c1"># 区分圆的大小</span>
  <span class="p">,</span><span class="n">size_max</span><span class="o">=</span><span class="mi">60</span>  <span class="c1"># 圆的最大值</span>
  <span class="p">,</span><span class="n">hover_name</span><span class="o">=</span><span class="s2">&quot;country&quot;</span>  <span class="c1"># 图中可视化最上面的名字</span>
  <span class="p">,</span><span class="n">animation_frame</span><span class="o">=</span><span class="s2">&quot;year&quot;</span>  <span class="c1"># 横轴滚动栏的属性year</span>
  <span class="p">,</span><span class="n">animation_group</span><span class="o">=</span><span class="s2">&quot;country&quot;</span>  <span class="c1"># 标注的分组</span>
  <span class="p">,</span><span class="n">facet_col</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span>   <span class="c1"># 按照国家country属性进行分格显示</span>
  <span class="p">,</span><span class="n">log_x</span><span class="o">=</span><span class="bp">True</span>  <span class="c1"># 横坐标表取对数</span>
  <span class="p">,</span><span class="n">range_x</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100000</span><span class="p">]</span>  <span class="c1"># 横轴取值范围</span>
  <span class="p">,</span><span class="n">range_y</span><span class="o">=</span><span class="p">[</span><span class="mi">25</span><span class="p">,</span><span class="mi">90</span><span class="p">]</span>  <span class="c1"># 纵轴范围</span>
  <span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="s2">&quot;Populations&quot;</span><span class="p">,</span>  <span class="c1"># 属性名字的变化，更直观</span>
               <span class="n">gdpPercap</span><span class="o">=</span><span class="s2">&quot;GDP per Capital&quot;</span><span class="p">,</span>
               <span class="n">lifeExp</span><span class="o">=</span><span class="s2">&quot;Life Expectancy&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p><img alt="image6" src="https://i.loli.net/2020/12/15/Kt19NOsTuShmico.gif" /></p>
</div>
<div class="section" id="id7">
<h5>3.4 地理数据绘图<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>在实际的工作中，我们可能会接触到中国地图甚至是全球地图，使用px也能制作：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">choropleth</span><span class="p">(</span>
  <span class="n">gapminder</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">locations</span><span class="o">=</span><span class="s2">&quot;iso_alpha&quot;</span><span class="p">,</span>  <span class="c1"># 配合颜色color显示</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lifeExp&quot;</span><span class="p">,</span> <span class="c1"># 颜色的字段选择</span>
  <span class="n">hover_name</span><span class="o">=</span><span class="s2">&quot;country&quot;</span><span class="p">,</span>  <span class="c1"># 悬停字段名字</span>
  <span class="n">animation_frame</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span>  <span class="c1"># 注释</span>
  <span class="n">color_continuous_scale</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">sequential</span><span class="o">.</span><span class="n">Plasma</span><span class="p">,</span>  <span class="c1"># 颜色变化</span>
  <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;natural earth&quot;</span>  <span class="c1"># 全球地图</span>
             <span class="p">)</span>
</pre></div>
</div>
<p><img alt="image7" src="https://i.loli.net/2020/12/15/3qtTVYO7y4fHRFL.gif" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">scatter_geo</span><span class="p">(</span>
  <span class="n">gapminder</span><span class="p">,</span>   <span class="c1"># 数据</span>
  <span class="n">locations</span><span class="o">=</span><span class="s2">&quot;iso_alpha&quot;</span><span class="p">,</span>  <span class="c1"># 配合颜色color显示</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span><span class="p">,</span> <span class="c1"># 颜色</span>
  <span class="n">hover_name</span><span class="o">=</span><span class="s2">&quot;country&quot;</span><span class="p">,</span> <span class="c1"># 悬停数据</span>
  <span class="n">size</span><span class="o">=</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span>  <span class="c1"># 大小</span>
  <span class="n">animation_frame</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span>  <span class="c1"># 数据帧的选择</span>
  <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;natural earth&quot;</span>  <span class="c1"># 全球地图</span>
                    <span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image8" src="https://i.loli.net/2020/12/15/advwYLRzDIfbpur.gif" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter_geo</span><span class="p">(</span>
  <span class="n">gapminder</span><span class="p">,</span> <span class="c1"># 数据集</span>
  <span class="n">locations</span><span class="o">=</span><span class="s2">&quot;iso_alpha&quot;</span><span class="p">,</span>  <span class="c1"># 配和color显示颜色</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span><span class="p">,</span>  <span class="c1"># 颜色的字段显示</span>
  <span class="n">hover_name</span><span class="o">=</span><span class="s2">&quot;country&quot;</span><span class="p">,</span>  <span class="c1"># 悬停数据</span>
  <span class="n">size</span><span class="o">=</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span>  <span class="c1"># 大小</span>
  <span class="n">animation_frame</span><span class="o">=</span><span class="s2">&quot;year&quot;</span>  <span class="c1"># 数据联动变化的选择</span>
  <span class="c1">#,projection=&quot;natural earth&quot;   # 去掉projection参数</span>
<span class="p">)</span>
</pre></div>
</div>
<p><img alt="image9" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6g82rp2j31ay0okq7k.jpg" /></p>
<p>使用line_geo来制图：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">line_geo</span><span class="p">(</span>
  <span class="n">gapminder2007</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">locations</span><span class="o">=</span><span class="s2">&quot;iso_alpha&quot;</span><span class="p">,</span>  <span class="c1"># 配合和color显示数据</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;continent&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;orthographic&quot;</span><span class="p">)</span>   <span class="c1"># 球形的地图</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image10" src="https://i.loli.net/2020/12/15/Ha6rnAKlUpJ5sLd.gif" /></p>
</div>
<div class="section" id="iris">
<h5>3.5 使用内置iris数据<a class="headerlink" href="#iris" title="Permalink to this headline">¶</a></h5>
<p>我们先看看怎么使用px来查看内置数据的文档：</p>
<p><img alt="image11" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6ixs3tvj31920ok77p.jpg" /></p>
<p><strong>选择两个属性制图</strong></p>
<p>选择两个属性作为横纵坐标来绘制散点图</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span>  <span class="c1"># 纵坐标</span>
                <span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image12" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6k3lryrj31fs0nkq4u.jpg" /></p>
<p>通过color参数来显示不同的颜色：</p>
<p><img alt="image13" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6odk1ioj31hw0se0w9.jpg" /></p>
</div>
<div class="section" id="id8">
<h5>3.6 联合分布图<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>我们一个图形中能够将散点图和直方图组合在一起显示：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span> <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标直方图</span>
  <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;rug&quot;</span>   <span class="c1"># 细条图</span>
<span class="p">)</span>
</pre></div>
</div>
<p><img alt="image14" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6pidvfvj31ck0po76k.jpg" /></p>
</div>
<div class="section" id="id9">
<h5>3.7 小提琴图<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>小提琴图能够很好的显示数据的分布和误差情况，一行代码利用也能显示小提琴图：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;violin&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标小提琴图</span>
  <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标箱型图</span>
  <span class="n">trendline</span><span class="o">=</span><span class="s2">&quot;ols&quot;</span>  <span class="c1"># 趋势线</span>
<span class="p">)</span>
</pre></div>
</div>
<p><img alt="image15" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6remny7j31c60o0dis.jpg" /></p>
</div>
<div class="section" id="id10">
<h5>3.8 散点矩阵图<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter_matrix</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据</span>
  <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span><span class="s2">&quot;petal_width&quot;</span><span class="p">,</span><span class="s2">&quot;petal_length&quot;</span><span class="p">],</span>  <span class="c1"># 维度选择</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">)</span>  <span class="c1"># 颜色</span>
</pre></div>
</div>
<p><img alt="image16" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6spx69yj31d00okguk.jpg" /></p>
</div>
<div class="section" id="id11">
<h5>3.9 平行坐标图<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">parallel_coordinates</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>   <span class="c1"># 数据集</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species_id&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;species_id&quot;</span><span class="p">:</span><span class="s2">&quot;Species&quot;</span><span class="p">,</span>  <span class="c1"># 各种标签值</span>
          <span class="s2">&quot;sepal_width&quot;</span><span class="p">:</span><span class="s2">&quot;Sepal Width&quot;</span><span class="p">,</span>
          <span class="s2">&quot;sepal_length&quot;</span><span class="p">:</span><span class="s2">&quot;Sepal Length&quot;</span><span class="p">,</span>
          <span class="s2">&quot;petal_length&quot;</span><span class="p">:</span><span class="s2">&quot;Petal Length&quot;</span><span class="p">,</span>
          <span class="s2">&quot;petal_width&quot;</span><span class="p">:</span><span class="s2">&quot;Petal Width&quot;</span><span class="p">},</span>
  <span class="n">color_continuous_scale</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">diverging</span><span class="o">.</span><span class="n">Tealrose</span><span class="p">,</span>
  <span class="n">color_continuous_midpoint</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="image17" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6tr14hcj31c80oa4qp.jpg" /></p>
</div>
<div class="section" id="id12">
<h5>3.10 箱体误差图<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 对当前值加上下两个误差值</span>
<span class="n">iris</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iris</span><span class="p">[</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">100</span>
<span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 绘图数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色值</span>
  <span class="n">error_x</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="p">,</span>  <span class="c1"># 横轴误差</span>
  <span class="n">error_y</span><span class="o">=</span><span class="s2">&quot;e&quot;</span>  <span class="c1"># 纵轴误差</span>
          <span class="p">)</span>
</pre></div>
</div>
<p><img alt="image18" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6vzx7k5j31cy0oadia.jpg" /></p>
</div>
<div class="section" id="id13">
<h5>3.11 等高线图<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>等高线图反映数据的密度情况：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">density_contour</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 绘图数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标值</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span>  <span class="c1"># 颜色</span>
<span class="p">)</span>
</pre></div>
</div>
<p><img alt="image19" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6yewy18j31dm0oc7be.jpg" /></p>
<p>等高线图和直方图的俩和使用：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">density_contour</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span> <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标值</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标值</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;rug&quot;</span><span class="p">,</span>  <span class="c1"># 横轴为线条图</span>
  <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span>   <span class="c1"># 纵轴为直方图</span>
                  <span class="p">)</span>
</pre></div>
</div>
<p><img alt="image20" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk6zf3tauj31cy0pkteb.jpg" /></p>
</div>
<div class="section" id="id14">
<h5>3.12 密度热力图<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">density_heatmap</span><span class="p">(</span>
  <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>   <span class="c1"># 横坐标值</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标值</span>
  <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;rug&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标值为线型图</span>
  <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span>  <span class="c1"># 直方图</span>
                  <span class="p">)</span>
</pre></div>
</div>
<p><img alt="image21" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk71h3i9gj31ek0oa405.jpg" /></p>
</div>
<div class="section" id="id15">
<h5>3.13 并行类别图<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>在接下来的图形中我们使用的小费tips实例，首先是导入数据：</p>
<p><img alt="image22" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk72rdtkij30om0by0ty.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">parallel_categories</span><span class="p">(</span>
  <span class="n">tips</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;size&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">color_continuous_scale</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">sequential</span><span class="o">.</span><span class="n">Inferno</span><span class="p">)</span>  <span class="c1"># 颜色变化取值</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h5>3.14 柱状图<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p><img alt="image23" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7bq5f2ij30y00dcwg5.jpg" /></p>
<p><img alt="image24" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7bv73pvj31eq0n8wfy.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span>
  <span class="n">tips</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span>  <span class="c1"># 横轴</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;total_bill&quot;</span><span class="p">,</span>  <span class="c1"># 纵轴</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;smoker&quot;</span><span class="p">,</span>  <span class="c1"># 颜色参数取值</span>
  <span class="n">barmode</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">,</span>  <span class="c1"># 柱状图模式取值</span>
  <span class="n">facet_row</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>  <span class="c1"># 行取值</span>
  <span class="n">facet_col</span><span class="o">=</span><span class="s2">&quot;day&quot;</span><span class="p">,</span>  <span class="c1"># 列元素取值</span>
  <span class="n">category_orders</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;day&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Thur&quot;</span><span class="p">,</span><span class="s2">&quot;Fri&quot;</span><span class="p">,</span><span class="s2">&quot;Sat&quot;</span><span class="p">,</span><span class="s2">&quot;Sun&quot;</span><span class="p">],</span>  <span class="c1"># 分类顺序</span>
    <span class="s2">&quot;time&quot;</span><span class="p">:[</span><span class="s2">&quot;Lunch&quot;</span><span class="p">,</span> <span class="s2">&quot;Dinner&quot;</span><span class="p">]})</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image25" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7cgpo52j31e20oe40q.jpg" /></p>
</div>
<div class="section" id="id17">
<h5>3.15 直方图<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
  <span class="n">tips</span><span class="p">,</span>  <span class="c1"># 绘图数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span>  <span class="c1"># 横轴为性别</span>
  <span class="n">y</span><span class="o">=</span><span class="s2">&quot;tip&quot;</span><span class="p">,</span>  <span class="c1"># 纵轴为费用</span>
  <span class="n">histfunc</span><span class="o">=</span><span class="s2">&quot;avg&quot;</span><span class="p">,</span>  <span class="c1"># 直方图显示的函数</span>
  <span class="n">color</span><span class="o">=</span><span class="s2">&quot;smoker&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
  <span class="n">barmode</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">,</span>  <span class="c1"># 柱状图模式</span>
  <span class="n">facet_row</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>  <span class="c1"># 行取值</span>
  <span class="n">facet_col</span><span class="o">=</span><span class="s2">&quot;day&quot;</span><span class="p">,</span>   <span class="c1"># 列取值</span>
  <span class="n">category_orders</span><span class="o">=</span><span class="p">{</span>  <span class="c1"># 分类顺序</span>
    <span class="s2">&quot;day&quot;</span><span class="p">:[</span><span class="s2">&quot;Thur&quot;</span><span class="p">,</span><span class="s2">&quot;Fri&quot;</span><span class="p">,</span><span class="s2">&quot;Sat&quot;</span><span class="p">,</span><span class="s2">&quot;Sun&quot;</span><span class="p">],</span>
    <span class="s2">&quot;time&quot;</span><span class="p">:[</span><span class="s2">&quot;Lunch&quot;</span><span class="p">,</span><span class="s2">&quot;Dinner&quot;</span><span class="p">]}</span>
<span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image26" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7d33olyj31ce0oqtad.jpg" /></p>
</div>
<div class="section" id="id18">
<h5>3.16 箱型图<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h5>
<p>箱型图也是现实数据的误差和分布情况：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># notched=True显示连接处的锥形部分</span>
<span class="n">px</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">tips</span><span class="p">,</span>  <span class="c1"># 数据集</span>
       <span class="n">x</span><span class="o">=</span><span class="s2">&quot;day&quot;</span><span class="p">,</span>  <span class="c1"># 横轴数据</span>
       <span class="n">y</span><span class="o">=</span><span class="s2">&quot;total_bill&quot;</span><span class="p">,</span>  <span class="c1"># 纵轴数据</span>
       <span class="n">color</span><span class="o">=</span><span class="s2">&quot;smoker&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
       <span class="n">notched</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 连接处的锥形部分显示出来</span>
</pre></div>
</div>
<p><img alt="image27" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll5hkq4caj31o40u0go6.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">box</span><span class="p">(</span>
  <span class="n">tips</span><span class="p">,</span>  <span class="c1"># 数据集</span>
  <span class="n">x</span><span class="o">=</span><span class="s2">&quot;day&quot;</span><span class="p">,</span>  <span class="c1"># 横轴</span>
    <span class="n">y</span><span class="o">=</span><span class="s2">&quot;total_bill&quot;</span><span class="p">,</span>  <span class="c1"># 纵轴</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;smoker&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
<span class="c1">#         notched=True   # 隐藏参数</span>
      <span class="p">)</span>
</pre></div>
</div>
<p><img alt="image28" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll5k37ya3j31oa0u0myz.jpg" /></p>
<p>再来画一次小提琴图：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">violin</span><span class="p">(</span>
    <span class="n">tips</span><span class="p">,</span>   <span class="c1"># 数据集</span>
    <span class="n">x</span><span class="o">=</span><span class="s2">&quot;smoker&quot;</span><span class="p">,</span>  <span class="c1"># 横轴坐标</span>
    <span class="n">y</span><span class="o">=</span><span class="s2">&quot;tip&quot;</span><span class="p">,</span>  <span class="c1"># 纵轴坐标</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span>   <span class="c1"># 颜色参数取值</span>
    <span class="n">box</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>   <span class="c1"># box是显示内部的箱体</span>
    <span class="n">points</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>  <span class="c1"># 同时显示数值点</span>
    <span class="n">hover_data</span><span class="o">=</span><span class="n">tips</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>  <span class="c1"># 结果中显示全部数据</span>
</pre></div>
</div>
<p><img alt="image29" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll5mz0lplj31m70u0jv3.jpg" /></p>
</div>
<div class="section" id="id19">
<h5>3.17 极坐标图<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h5>
<p>在这里我们使用的是内置的wind数据：</p>
<p><img alt="image30" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7ft5phfj30iw0boq3n.jpg" /></p>
<p><strong>散点极坐标图</strong></p>
<p><img alt="image31" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll5rv6absj31bz0u00zy.jpg" /></p>
<p><strong>线性极坐标图</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">line_polar</span><span class="p">(</span>
    <span class="n">wind</span><span class="p">,</span>  <span class="c1"># 数据集</span>
    <span class="n">r</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>  <span class="c1"># 半径</span>
    <span class="n">theta</span><span class="o">=</span><span class="s2">&quot;direction&quot;</span><span class="p">,</span>  <span class="c1"># 角度</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;strength&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
    <span class="n">line_close</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>  <span class="c1"># 线性闭合</span>
    <span class="n">color_discrete_sequence</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">sequential</span><span class="o">.</span><span class="n">Plasma_r</span><span class="p">)</span>  <span class="c1"># 颜色变化</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image32" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll5tkatigj318q0qgtf7.jpg" /></p>
<p><strong>柱状极坐标图</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">bar_polar</span><span class="p">(</span>
    <span class="n">wind</span><span class="p">,</span>   <span class="c1"># 数据集</span>
    <span class="n">r</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>   <span class="c1"># 半径</span>
    <span class="n">theta</span><span class="o">=</span><span class="s2">&quot;direction&quot;</span><span class="p">,</span>  <span class="c1"># 角度</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;strength&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
    <span class="n">template</span><span class="o">=</span><span class="s2">&quot;plotly_dark&quot;</span><span class="p">,</span>  <span class="c1"># 主题</span>
    <span class="n">color_discrete_sequence</span><span class="o">=</span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">sequential</span><span class="o">.</span><span class="n">Plasma_r</span><span class="p">)</span>  <span class="c1"># 颜色变化</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image33" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll5vly8zhj31gs0ru107.jpg" /></p>
</div>
</div>
<div class="section" id="id20">
<h4>4. 颜色面板<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>在px中有很多的颜色可以供选择，提供了一个颜色面板：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">qualitative</span><span class="o">.</span><span class="n">swatches</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image34" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7iq5d86j311t0u0acb.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">sequential</span><span class="o">.</span><span class="n">swatches</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image35" src="https://tva1.sinaimg.cn/large/0081Kckwgy1glk7jjgu8bj31a40qmwg7.jpg" /></p>
</div>
<div class="section" id="id21">
<h4>5. 主题<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>px中存在3种主题：</p>
<ul class="simple">
<li><p>plotly</p></li>
<li><p>plotly_white</p></li>
<li><p>plotly_dark</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
    <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标值</span>
    <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标取值</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
    <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标为箱型图</span>
    <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标为直方图</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>  <span class="c1"># 高度</span>
    <span class="n">trendline</span><span class="o">=</span><span class="s2">&quot;ols&quot;</span><span class="p">,</span>  <span class="c1"># 显示趋势线</span>
    <span class="n">template</span><span class="o">=</span><span class="s2">&quot;plotly&quot;</span><span class="p">)</span>  <span class="c1"># 主题</span>
</pre></div>
</div>
<p><img alt="image36" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll601dlxwj31gk0u0gp5.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
    <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标值</span>
    <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标取值</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
    <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标为箱型图</span>
    <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标为直方图</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>  <span class="c1"># 高度</span>
    <span class="n">trendline</span><span class="o">=</span><span class="s2">&quot;ols&quot;</span><span class="p">,</span>  <span class="c1"># 显示趋势线</span>
    <span class="n">template</span><span class="o">=</span><span class="s2">&quot;plotly_white&quot;</span><span class="p">)</span>  <span class="c1"># 主题</span>
</pre></div>
</div>
<p><img alt="image37" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll60rstnej31fn0u00w3.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">px</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">iris</span><span class="p">,</span>  <span class="c1"># 数据集</span>
    <span class="n">x</span><span class="o">=</span><span class="s2">&quot;sepal_width&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标值</span>
    <span class="n">y</span><span class="o">=</span><span class="s2">&quot;sepal_length&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标取值</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span>  <span class="c1"># 颜色</span>
    <span class="n">marginal_x</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>  <span class="c1"># 横坐标为箱型图</span>
    <span class="n">marginal_y</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span>  <span class="c1"># 纵坐标为直方图</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>  <span class="c1"># 高度</span>
    <span class="n">trendline</span><span class="o">=</span><span class="s2">&quot;ols&quot;</span><span class="p">,</span>  <span class="c1"># 显示趋势线</span>
    <span class="n">template</span><span class="o">=</span><span class="s2">&quot;plotly_dark&quot;</span><span class="p">)</span>  <span class="c1"># 主题</span>
</pre></div>
</div>
<p><img alt="image38" src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll6290tsnj31g50u00wd.jpg" /></p>
</div>
<div class="section" id="id22">
<h4>6. 总结一下<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>本文中利用大量的篇幅讲解了如何通过plotly_express来绘制：<strong>柱状图、线型图、散点图、小提琴图、极坐标图</strong>等各种常见的图形。通过观察上面<code class="docutils literal notranslate"><span class="pre">Plotly_express</span></code>绘制图形过程，我们不难发现它有三个主要的优点：</p>
<ul class="simple">
<li><p>快速出图，少量的代码就能满足多数的制图要求。基本上都是几个参数的设置我们就能快速出图</p></li>
<li><p>图形漂亮，绘制出来的可视化图形颜色亮丽，也有很多的颜色供选择。</p></li>
<li><p>图形是动态可视化的。文章中图形都是截图，如果是在<code class="docutils literal notranslate"><span class="pre">Jupyter</span> <span class="pre">notebook</span></code>中都是动态图形</p></li>
</ul>
<p>希望通过本文的讲解能够帮助堵住快速入门plotly_express可视化神器。</p>
<p><img alt="image39" src="http://image.iswbm.com/20200607174235.png" /></p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
<span id="document-aboutme"></span><div class="section" id="id1">
<h2>关于作者<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>姓名：     王炳明</p></li>
<li><p>微信：     stromwbm</p></li>
<li><p>公众号：   《Python编程时光》&amp;《Go编程时光》</p></li>
<li><p>Email：    <a class="reference external" href="mailto:wongbingming&#37;&#52;&#48;163&#46;com">wongbingming<span>&#64;</span>163<span>&#46;</span>com</a></p></li>
<li><p>GitHub：   <a class="reference external" href="https://github.com/iswbm">https://github.com/iswbm</a></p></li>
</ul>
<hr class="docutils" />
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
<span id="document-roadmap"></span><div class="section" id="roadmap">
<h2>Roadmap<a class="headerlink" href="#roadmap" title="Permalink to this headline">¶</a></h2>
<p>2020/12/25:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|    github项目搭建，readthedocs文档生成。
|    整个项目的框架完成
</pre></div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>
</div>
<hr class="docutils" />
<div class="figure align-default">
<img alt="http://image.iswbm.com/20200607174235.png" src="http://image.iswbm.com/20200607174235.png" />
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Python编程时光
      
        <span class="commit">
          Revision <code>2da86590</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/en/latest/">latest</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//python.iswbm.com/_/downloads/en/latest/htmlzip/">html</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/python-guide-for-all/?fromdocs=python-guide-for-all">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/python-guide-for-all/?fromdocs=python-guide-for-all">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>